"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client@2.11.3";
exports.ids = ["vendor-chunks/livekit-client@2.11.3"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/livekit-client@2.11.3/node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/livekit-client@2.11.3/node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BackupCodecPolicy: () => (/* binding */ BackupCodecPolicy),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   CheckStatus: () => (/* binding */ CheckStatus),\n/* harmony export */   Checker: () => (/* binding */ Checker),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionErrorReason: () => (/* binding */ ConnectionErrorReason),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorError: () => (/* binding */ CryptorError),\n/* harmony export */   CryptorErrorReason: () => (/* binding */ CryptorErrorReason),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   LoggerNames: () => (/* binding */ LoggerNames),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   Mutex: () => (/* binding */ _),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   ParticipantKind: () => (/* binding */ ParticipantInfo_Kind),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   PublishTrackError: () => (/* binding */ PublishTrackError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   SignalRequestError: () => (/* binding */ SignalRequestError),\n/* harmony export */   SubscriptionError: () => (/* binding */ SubscriptionError),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   TrackType: () => (/* binding */ TrackType),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isAudioTrack: () => (/* binding */ isAudioTrack),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isLocalParticipant: () => (/* binding */ isLocalParticipant),\n/* harmony export */   isLocalTrack: () => (/* binding */ isLocalTrack),\n/* harmony export */   isRemoteParticipant: () => (/* binding */ isRemoteParticipant),\n/* harmony export */   isRemoteTrack: () => (/* binding */ isRemoteTrack),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   isVideoTrack: () => (/* binding */ isVideoTrack),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function (e) {\n    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n      if (k !== 'default' && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n\nvar e = Object.defineProperty;\nvar h = (i, s, t) => s in i ? e(i, s, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: t\n}) : i[s] = t;\nvar o = (i, s, t) => h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n  constructor() {\n    o(this, \"_locking\");\n    o(this, \"_locks\");\n    this._locking = Promise.resolve(), this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let s;\n    const t = new Promise(l => s = () => {\n        this._locks -= 1, l();\n      }),\n      c = this._locking.then(() => s);\n    return this._locking = this._locking.then(() => t), c;\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */\nfunction assert(condition, msg) {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38,\n  FLOAT32_MIN = -34028234663852886e22,\n  UINT32_MAX = 0xffffffff,\n  INT32_MAX = 0x7fffffff,\n  INT32_MIN = -2147483648;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */\nfunction assertInt32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */\nfunction assertUInt32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */\nfunction assertFloat32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n  if (!Number.isFinite(arg)) return;\n  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */\nfunction getEnumType(enumObject) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n  const t = enumObject[enumTypeSymbol];\n  assert(t, \"missing enum type on enum object\");\n  return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */\nfunction setEnumType(enumObject, typeName, values, opt) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map(v => ({\n    no: v.no,\n    name: v.name,\n    localName: enumObject[v.no]\n  })));\n}\n/**\n * Create a new EnumType with the given values.\n */\nfunction makeEnumType(typeName, values,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n  const names = Object.create(null);\n  const numbers = Object.create(null);\n  const normalValues = [];\n  for (const value of values) {\n    // We do not surface options at this time\n    // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n    const n = normalizeEnumValue(value);\n    normalValues.push(n);\n    names[value.name] = n;\n    numbers[value.no] = n;\n  }\n  return {\n    typeName,\n    values: normalValues,\n    // We do not surface options at this time\n    // options: opt?.options ?? Object.create(null),\n    findName(name) {\n      return names[name];\n    },\n    findNumber(no) {\n      return numbers[no];\n    }\n  };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */\nfunction makeEnum(typeName, values, opt) {\n  const enumObject = {};\n  for (const value of values) {\n    const n = normalizeEnumValue(value);\n    enumObject[n.localName] = n.no;\n    enumObject[n.no] = n.localName;\n  }\n  setEnumType(enumObject, typeName, values);\n  return enumObject;\n}\nfunction normalizeEnumValue(value) {\n  if (\"localName\" in value) {\n    return value;\n  }\n  return Object.assign(Object.assign({}, value), {\n    localName: value.name\n  });\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */\nclass Message {\n  /**\n   * Compare with a message of the same type.\n   * Note that this function disregards extensions and unknown fields.\n   */\n  equals(other) {\n    return this.getType().runtime.util.equals(this.getType(), this, other);\n  }\n  /**\n   * Create a deep copy.\n   */\n  clone() {\n    return this.getType().runtime.util.clone(this);\n  }\n  /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */\n  fromBinary(bytes, options) {\n    const type = this.getType(),\n      format = type.runtime.bin,\n      opt = format.makeReadOptions(options);\n    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n    return this;\n  }\n  /**\n   * Parse a message from a JSON value.\n   */\n  fromJson(jsonValue, options) {\n    const type = this.getType(),\n      format = type.runtime.json,\n      opt = format.makeReadOptions(options);\n    format.readMessage(type, jsonValue, opt, this);\n    return this;\n  }\n  /**\n   * Parse a message from a JSON string.\n   */\n  fromJsonString(jsonString, options) {\n    let json;\n    try {\n      json = JSON.parse(jsonString);\n    } catch (e) {\n      throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n    }\n    return this.fromJson(json, options);\n  }\n  /**\n   * Serialize the message to binary data.\n   */\n  toBinary(options) {\n    const type = this.getType(),\n      bin = type.runtime.bin,\n      opt = bin.makeWriteOptions(options),\n      writer = opt.writerFactory();\n    bin.writeMessage(this, writer, opt);\n    return writer.finish();\n  }\n  /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */\n  toJson(options) {\n    const type = this.getType(),\n      json = type.runtime.json,\n      opt = json.makeWriteOptions(options);\n    return json.writeMessage(this, opt);\n  }\n  /**\n   * Serialize the message to a JSON string.\n   */\n  toJsonString(options) {\n    var _a;\n    const value = this.toJson(options);\n    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */\n  toJSON() {\n    return this.toJson({\n      emitDefaultValues: true\n    });\n  }\n  /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */\n  getType() {\n    // Any class that extends Message _must_ provide a complete static\n    // implementation of MessageType.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n    return Object.getPrototypeOf(this).constructor;\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */\nfunction makeMessageType(runtime, typeName, fields, opt) {\n  var _a;\n  const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n  const type = {\n    [localName]: function (data) {\n      runtime.util.initFields(this);\n      runtime.util.initPartial(data, this);\n    }\n  }[localName];\n  Object.setPrototypeOf(type.prototype, new Message());\n  Object.assign(type, {\n    runtime,\n    typeName,\n    fields: runtime.util.newFieldList(fields),\n    fromBinary(bytes, options) {\n      return new type().fromBinary(bytes, options);\n    },\n    fromJson(jsonValue, options) {\n      return new type().fromJson(jsonValue, options);\n    },\n    fromJsonString(jsonString, options) {\n      return new type().fromJsonString(jsonString, options);\n    },\n    equals(a, b) {\n      return runtime.util.equals(type, a, b);\n    }\n  });\n  return type;\n}\n\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nfunction varint64read() {\n  let lowBits = 0;\n  let highBits = 0;\n  for (let shift = 0; shift < 28; shift += 7) {\n    let b = this.buf[this.pos++];\n    lowBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n  let middleByte = this.buf[this.pos++];\n  // last four bits of the first 32 bit number\n  lowBits |= (middleByte & 0x0f) << 28;\n  // 3 upper bits are part of the next 32 bit number\n  highBits = (middleByte & 0x70) >> 4;\n  if ((middleByte & 0x80) == 0) {\n    this.assertBounds();\n    return [lowBits, highBits];\n  }\n  for (let shift = 3; shift <= 31; shift += 7) {\n    let b = this.buf[this.pos++];\n    highBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n  throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nfunction varint64write(lo, hi, bytes) {\n  for (let i = 0; i < 28; i = i + 7) {\n    const shift = lo >>> i;\n    const hasNext = !(shift >>> 7 == 0 && hi == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n  const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n  const hasMoreBits = !(hi >> 3 == 0);\n  bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n  if (!hasMoreBits) {\n    return;\n  }\n  for (let i = 3; i < 31; i = i + 7) {\n    const shift = hi >>> i;\n    const hasNext = !(shift >>> 7 == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n  bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64FromString(dec) {\n  // Check for minus sign.\n  const minus = dec[0] === \"-\";\n  if (minus) {\n    dec = dec.slice(1);\n  }\n  // Work 6 decimal digits at a time, acting like we're converting base 1e6\n  // digits to binary. This is safe to do with floating point math because\n  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n  const base = 1e6;\n  let lowBits = 0;\n  let highBits = 0;\n  function add1e6digit(begin, end) {\n    // Note: Number('') is 0.\n    const digit1e6 = Number(dec.slice(begin, end));\n    highBits *= base;\n    lowBits = lowBits * base + digit1e6;\n    // Carry bits from lowBits to\n    if (lowBits >= TWO_PWR_32_DBL) {\n      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n      lowBits = lowBits % TWO_PWR_32_DBL;\n    }\n  }\n  add1e6digit(-24, -18);\n  add1e6digit(-18, -12);\n  add1e6digit(-12, -6);\n  add1e6digit(-6);\n  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64ToString(lo, hi) {\n  let bits = newBits(lo, hi);\n  // If we're treating the input as a signed value and the high bit is set, do\n  // a manual two's complement conversion before the decimal conversion.\n  const negative = bits.hi & 0x80000000;\n  if (negative) {\n    bits = negate(bits.lo, bits.hi);\n  }\n  const result = uInt64ToString(bits.lo, bits.hi);\n  return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction uInt64ToString(lo, hi) {\n  ({\n    lo,\n    hi\n  } = toUnsigned(lo, hi));\n  // Skip the expensive conversion if the number is small enough to use the\n  // built-in conversions.\n  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n  // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n  // integer precision.\n  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n  if (hi <= 0x1FFFFF) {\n    return String(TWO_PWR_32_DBL * hi + lo);\n  }\n  // What this code is doing is essentially converting the input number from\n  // base-2 to base-1e7, which allows us to represent the 64-bit range with\n  // only 3 (very large) digits. Those digits are then trivial to convert to\n  // a base-10 string.\n  // The magic numbers used here are -\n  // 2^24 = 16777216 = (1,6777216) in base-1e7.\n  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n  // Split 32:32 representation into 16:24:24 representation so our\n  // intermediate digits don't overflow.\n  const low = lo & 0xFFFFFF;\n  const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n  const high = hi >> 16 & 0xFFFF;\n  // Assemble our three base-1e7 digits, ignoring carries. The maximum\n  // value in a digit at this step is representable as a 48-bit integer, which\n  // can be stored in a 64-bit floating point number.\n  let digitA = low + mid * 6777216 + high * 6710656;\n  let digitB = mid + high * 8147497;\n  let digitC = high * 2;\n  // Apply carries from A to B and from B to C.\n  const base = 10000000;\n  if (digitA >= base) {\n    digitB += Math.floor(digitA / base);\n    digitA %= base;\n  }\n  if (digitB >= base) {\n    digitC += Math.floor(digitB / base);\n    digitB %= base;\n  }\n  // If digitC is 0, then we should have returned in the trivial code path\n  // at the top for non-safe integers. Given this, we can assume both digitB\n  // and digitA need leading zeros.\n  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n  return {\n    lo: lo >>> 0,\n    hi: hi >>> 0\n  };\n}\nfunction newBits(lo, hi) {\n  return {\n    lo: lo | 0,\n    hi: hi | 0\n  };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits, highBits) {\n  highBits = ~highBits;\n  if (lowBits) {\n    lowBits = ~lowBits + 1;\n  } else {\n    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n    // adding 1 to that, results in 0x100000000, which leaves\n    // the low bits 0x0 and simply adds one to the high bits.\n    highBits += 1;\n  }\n  return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = digit1e7 => {\n  const partial = String(digit1e7);\n  return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nfunction varint32write(value, bytes) {\n  if (value >= 0) {\n    // write value as varint 32\n    while (value > 0x7f) {\n      bytes.push(value & 0x7f | 0x80);\n      value = value >>> 7;\n    }\n    bytes.push(value);\n  } else {\n    for (let i = 0; i < 9; i++) {\n      bytes.push(value & 127 | 128);\n      value = value >> 7;\n    }\n    bytes.push(1);\n  }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nfunction varint32read() {\n  let b = this.buf[this.pos++];\n  let result = b & 0x7f;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 7;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 14;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 21;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  // Extract only last 4 bits\n  b = this.buf[this.pos++];\n  result |= (b & 0x0f) << 28;\n  for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];\n  if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n  this.assertBounds();\n  // Result can have 32 bits, convert it to unsigned\n  return result >>> 0;\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n  const dv = new DataView(new ArrayBuffer(8));\n  // note that Safari 14 implements BigInt, but not the DataView methods\n  const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n  if (ok) {\n    const MIN = BigInt(\"-9223372036854775808\"),\n      MAX = BigInt(\"9223372036854775807\"),\n      UMIN = BigInt(\"0\"),\n      UMAX = BigInt(\"18446744073709551615\");\n    return {\n      zero: BigInt(0),\n      supported: true,\n      parse(value) {\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\n        if (bi > MAX || bi < MIN) {\n          throw new Error(\"int64 invalid: \".concat(value));\n        }\n        return bi;\n      },\n      uParse(value) {\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\n        if (bi > UMAX || bi < UMIN) {\n          throw new Error(\"uint64 invalid: \".concat(value));\n        }\n        return bi;\n      },\n      enc(value) {\n        dv.setBigInt64(0, this.parse(value), true);\n        return {\n          lo: dv.getInt32(0, true),\n          hi: dv.getInt32(4, true)\n        };\n      },\n      uEnc(value) {\n        dv.setBigInt64(0, this.uParse(value), true);\n        return {\n          lo: dv.getInt32(0, true),\n          hi: dv.getInt32(4, true)\n        };\n      },\n      dec(lo, hi) {\n        dv.setInt32(0, lo, true);\n        dv.setInt32(4, hi, true);\n        return dv.getBigInt64(0, true);\n      },\n      uDec(lo, hi) {\n        dv.setInt32(0, lo, true);\n        dv.setInt32(4, hi, true);\n        return dv.getBigUint64(0, true);\n      }\n    };\n  }\n  const assertInt64String = value => assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n  const assertUInt64String = value => assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n  return {\n    zero: \"0\",\n    supported: false,\n    parse(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertInt64String(value);\n      return value;\n    },\n    uParse(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertUInt64String(value);\n      return value;\n    },\n    enc(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertInt64String(value);\n      return int64FromString(value);\n    },\n    uEnc(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertUInt64String(value);\n      return int64FromString(value);\n    },\n    dec(lo, hi) {\n      return int64ToString(lo, hi);\n    },\n    uDec(lo, hi) {\n      return uInt64ToString(lo, hi);\n    }\n  };\n}\nconst protoInt64 = makeInt64Support();\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nvar ScalarType;\n(function (ScalarType) {\n  // 0 is reserved for errors.\n  // Order is weird for historical reasons.\n  ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n  ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n  // negative values are likely.\n  ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n  ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n  // negative values are likely.\n  ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n  ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n  ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n  ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n  ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n  // Tag-delimited aggregate.\n  // Group type is deprecated and not supported in proto3. However, Proto3\n  // implementations should still be able to parse the group wire format and\n  // treat group fields as unknown fields.\n  // TYPE_GROUP = 10,\n  // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n  // New in version 2.\n  ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n  ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n  // TYPE_ENUM = 14,\n  ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n  ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n  ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n  ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */\nvar LongType;\n(function (LongType) {\n  /**\n   * Use JavaScript BigInt.\n   */\n  LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n  /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */\n  LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if both scalar values are equal.\n */\nfunction scalarEquals(type, a, b) {\n  if (a === b) {\n    // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n    return true;\n  }\n  // Special case BYTES - we need to compare each byte individually\n  if (type == ScalarType.BYTES) {\n    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Special case 64-bit integers - we support number, string and bigint representation.\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (type) {\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      // Loose comparison will match between 0n, 0 and \"0\".\n      return a == b;\n  }\n  // Anything that hasn't been caught by strict comparison or special cased\n  // BYTES and 64-bit integers is not equal.\n  return false;\n}\n/**\n * Returns the zero value for the given scalar type.\n */\nfunction scalarZeroValue(type, longType) {\n  switch (type) {\n    case ScalarType.BOOL:\n      return false;\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n      return longType == 0 ? protoInt64.zero : \"0\";\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      return 0.0;\n    case ScalarType.BYTES:\n      return new Uint8Array(0);\n    case ScalarType.STRING:\n      return \"\";\n    default:\n      // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n      // We do not use individual cases to save a few bytes code size.\n      return 0;\n  }\n}\n/**\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\n *\n * In proto3, zero-values are not written to the wire, unless the field is\n * optional or repeated.\n */\nfunction isScalarZeroValue(type, value) {\n  switch (type) {\n    case ScalarType.BOOL:\n      return value === false;\n    case ScalarType.STRING:\n      return value === \"\";\n    case ScalarType.BYTES:\n      return value instanceof Uint8Array && !value.byteLength;\n    default:\n      return value == 0;\n    // Loose comparison matches 0n, 0 and \"0\"\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nvar WireType;\n(function (WireType) {\n  /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */\n  WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n  /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */\n  WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n  /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */\n  WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n  /**\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n   * in editions with message_encoding = DELIMITED.\n   */\n  WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n  /**\n   * End of a tag-delimited aggregate.\n   */\n  WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n  /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */\n  WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n  constructor(textEncoder) {\n    /**\n     * Previous fork states.\n     */\n    this.stack = [];\n    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n    this.chunks = [];\n    this.buf = [];\n  }\n  /**\n   * Return all bytes written and reset this writer.\n   */\n  finish() {\n    this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n    let len = 0;\n    for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;\n    let bytes = new Uint8Array(len);\n    let offset = 0;\n    for (let i = 0; i < this.chunks.length; i++) {\n      bytes.set(this.chunks[i], offset);\n      offset += this.chunks[i].length;\n    }\n    this.chunks = [];\n    return bytes;\n  }\n  /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */\n  fork() {\n    this.stack.push({\n      chunks: this.chunks,\n      buf: this.buf\n    });\n    this.chunks = [];\n    this.buf = [];\n    return this;\n  }\n  /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */\n  join() {\n    // get chunk of fork\n    let chunk = this.finish();\n    // restore previous state\n    let prev = this.stack.pop();\n    if (!prev) throw new Error(\"invalid state, fork stack empty\");\n    this.chunks = prev.chunks;\n    this.buf = prev.buf;\n    // write length of chunk as varint\n    this.uint32(chunk.byteLength);\n    return this.raw(chunk);\n  }\n  /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */\n  tag(fieldNo, type) {\n    return this.uint32((fieldNo << 3 | type) >>> 0);\n  }\n  /**\n   * Write a chunk of raw bytes.\n   */\n  raw(chunk) {\n    if (this.buf.length) {\n      this.chunks.push(new Uint8Array(this.buf));\n      this.buf = [];\n    }\n    this.chunks.push(chunk);\n    return this;\n  }\n  /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */\n  uint32(value) {\n    assertUInt32(value);\n    // write value as varint 32, inlined for speed\n    while (value > 0x7f) {\n      this.buf.push(value & 0x7f | 0x80);\n      value = value >>> 7;\n    }\n    this.buf.push(value);\n    return this;\n  }\n  /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */\n  int32(value) {\n    assertInt32(value);\n    varint32write(value, this.buf);\n    return this;\n  }\n  /**\n   * Write a `bool` value, a variant.\n   */\n  bool(value) {\n    this.buf.push(value ? 1 : 0);\n    return this;\n  }\n  /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */\n  bytes(value) {\n    this.uint32(value.byteLength); // write length of chunk as varint\n    return this.raw(value);\n  }\n  /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */\n  string(value) {\n    let chunk = this.textEncoder.encode(value);\n    this.uint32(chunk.byteLength); // write length of chunk as varint\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `float` value, 32-bit floating point number.\n   */\n  float(value) {\n    assertFloat32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setFloat32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `double` value, a 64-bit floating point number.\n   */\n  double(value) {\n    let chunk = new Uint8Array(8);\n    new DataView(chunk.buffer).setFloat64(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32(value) {\n    assertUInt32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setUint32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32(value) {\n    assertInt32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setInt32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32(value) {\n    assertInt32(value);\n    // zigzag encode\n    value = (value << 1 ^ value >> 31) >>> 0;\n    varint32write(value, this.buf);\n    return this;\n  }\n  /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64(value) {\n    let chunk = new Uint8Array(8),\n      view = new DataView(chunk.buffer),\n      tc = protoInt64.enc(value);\n    view.setInt32(0, tc.lo, true);\n    view.setInt32(4, tc.hi, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64(value) {\n    let chunk = new Uint8Array(8),\n      view = new DataView(chunk.buffer),\n      tc = protoInt64.uEnc(value);\n    view.setInt32(0, tc.lo, true);\n    view.setInt32(4, tc.hi, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */\n  int64(value) {\n    let tc = protoInt64.enc(value);\n    varint64write(tc.lo, tc.hi, this.buf);\n    return this;\n  }\n  /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64(value) {\n    let tc = protoInt64.enc(value),\n      // zigzag encode\n      sign = tc.hi >> 31,\n      lo = tc.lo << 1 ^ sign,\n      hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n    varint64write(lo, hi, this.buf);\n    return this;\n  }\n  /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */\n  uint64(value) {\n    let tc = protoInt64.uEnc(value);\n    varint64write(tc.lo, tc.hi, this.buf);\n    return this;\n  }\n}\nclass BinaryReader {\n  constructor(buf, textDecoder) {\n    this.varint64 = varint64read; // dirty cast for `this`\n    /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */\n    this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n    this.buf = buf;\n    this.len = buf.length;\n    this.pos = 0;\n    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n  }\n  /**\n   * Reads a tag - field number and wire type.\n   */\n  tag() {\n    let tag = this.uint32(),\n      fieldNo = tag >>> 3,\n      wireType = tag & 7;\n    if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n    return [fieldNo, wireType];\n  }\n  /**\n   * Skip one element and return the skipped data.\n   *\n   * When skipping StartGroup, provide the tags field number to check for\n   * matching field number in the EndGroup tag.\n   */\n  skip(wireType, fieldNo) {\n    let start = this.pos;\n    switch (wireType) {\n      case WireType.Varint:\n        while (this.buf[this.pos++] & 0x80) {\n          // ignore\n        }\n        break;\n      // eslint-disable-next-line\n      // @ts-ignore TS7029: Fallthrough case in switch\n      case WireType.Bit64:\n        this.pos += 4;\n      // eslint-disable-next-line\n      // @ts-ignore TS7029: Fallthrough case in switch\n      case WireType.Bit32:\n        this.pos += 4;\n        break;\n      case WireType.LengthDelimited:\n        let len = this.uint32();\n        this.pos += len;\n        break;\n      case WireType.StartGroup:\n        for (;;) {\n          const [fn, wt] = this.tag();\n          if (wt === WireType.EndGroup) {\n            if (fieldNo !== undefined && fn !== fieldNo) {\n              throw new Error(\"invalid end group tag\");\n            }\n            break;\n          }\n          this.skip(wt, fn);\n        }\n        break;\n      default:\n        throw new Error(\"cant skip wire type \" + wireType);\n    }\n    this.assertBounds();\n    return this.buf.subarray(start, this.pos);\n  }\n  /**\n   * Throws error if position in byte array is out of range.\n   */\n  assertBounds() {\n    if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n  }\n  /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */\n  int32() {\n    return this.uint32() | 0;\n  }\n  /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32() {\n    let zze = this.uint32();\n    // decode zigzag\n    return zze >>> 1 ^ -(zze & 1);\n  }\n  /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */\n  int64() {\n    return protoInt64.dec(...this.varint64());\n  }\n  /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */\n  uint64() {\n    return protoInt64.uDec(...this.varint64());\n  }\n  /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64() {\n    let [lo, hi] = this.varint64();\n    // decode zig zag\n    let s = -(lo & 1);\n    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n    hi = hi >>> 1 ^ s;\n    return protoInt64.dec(lo, hi);\n  }\n  /**\n   * Read a `bool` field, a variant.\n   */\n  bool() {\n    let [lo, hi] = this.varint64();\n    return lo !== 0 || hi !== 0;\n  }\n  /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32() {\n    return this.view.getUint32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32() {\n    return this.view.getInt32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64() {\n    return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64() {\n    return protoInt64.dec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `float` field, 32-bit floating point number.\n   */\n  float() {\n    return this.view.getFloat32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `double` field, a 64-bit floating point number.\n   */\n  double() {\n    return this.view.getFloat64((this.pos += 8) - 8, true);\n  }\n  /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */\n  bytes() {\n    let len = this.uint32(),\n      start = this.pos;\n    this.pos += len;\n    this.assertBounds();\n    return this.buf.subarray(start, start + len);\n  }\n  /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */\n  string() {\n    return this.textDecoder.decode(this.bytes());\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new extension using the given runtime.\n */\nfunction makeExtension(runtime, typeName, extendee, field) {\n  let fi;\n  return {\n    typeName,\n    extendee,\n    get field() {\n      if (!fi) {\n        const i = typeof field == \"function\" ? field() : field;\n        i.name = typeName.split(\".\").pop();\n        i.jsonName = \"[\".concat(typeName, \"]\");\n        fi = runtime.util.newFieldList([i]).list()[0];\n      }\n      return fi;\n    },\n    runtime\n  };\n}\n/**\n * Create a container that allows us to read extension fields into it with the\n * same logic as regular fields.\n */\nfunction createExtensionContainer(extension) {\n  const localName = extension.field.localName;\n  const container = Object.create(null);\n  container[localName] = initExtensionField(extension);\n  return [container, () => container[localName]];\n}\nfunction initExtensionField(ext) {\n  const field = ext.field;\n  if (field.repeated) {\n    return [];\n  }\n  if (field.default !== undefined) {\n    return field.default;\n  }\n  switch (field.kind) {\n    case \"enum\":\n      return field.T.values[0].no;\n    case \"scalar\":\n      return scalarZeroValue(field.T, field.L);\n    case \"message\":\n      // eslint-disable-next-line no-case-declarations\n      const T = field.T,\n        value = new T();\n      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\n    case \"map\":\n      throw \"map fields are not allowed to be extensions\";\n  }\n}\n/**\n * Helper to filter unknown fields, optimized based on field type.\n */\nfunction filterUnknownFields(unknownFields, field) {\n  if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\n    // singular scalar fields do not merge, we pick the last\n    for (let i = unknownFields.length - 1; i >= 0; --i) {\n      if (unknownFields[i].no == field.no) {\n        return [unknownFields[i]];\n      }\n    }\n    return [];\n  }\n  return unknownFields.filter(uf => uf.no === field.no);\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */\n// lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n  /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */\n  dec(base64Str) {\n    // estimate byte size, not accounting for inner padding and whitespace\n    let es = base64Str.length * 3 / 4;\n    if (base64Str[base64Str.length - 2] == \"=\") es -= 2;else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n    let bytes = new Uint8Array(es),\n      bytePos = 0,\n      // position in byte array\n      groupPos = 0,\n      // position in base64 group\n      b,\n      // current byte\n      p = 0; // previous byte\n    for (let i = 0; i < base64Str.length; i++) {\n      b = decTable[base64Str.charCodeAt(i)];\n      if (b === undefined) {\n        switch (base64Str[i]) {\n          // @ts-ignore TS7029: Fallthrough case in switch\n          case \"=\":\n            groupPos = 0;\n          // reset state when padding found\n          // @ts-ignore TS7029: Fallthrough case in switch\n          case \"\\n\":\n          case \"\\r\":\n          case \"\\t\":\n          case \" \":\n            continue;\n          // skip white-space, and padding\n          default:\n            throw Error(\"invalid base64 string.\");\n        }\n      }\n      switch (groupPos) {\n        case 0:\n          p = b;\n          groupPos = 1;\n          break;\n        case 1:\n          bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n          p = b;\n          groupPos = 2;\n          break;\n        case 2:\n          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n          p = b;\n          groupPos = 3;\n          break;\n        case 3:\n          bytes[bytePos++] = (p & 3) << 6 | b;\n          groupPos = 0;\n          break;\n      }\n    }\n    if (groupPos == 1) throw Error(\"invalid base64 string.\");\n    return bytes.subarray(0, bytePos);\n  },\n  /**\n   * Encode a byte array to a base64 string.\n   */\n  enc(bytes) {\n    let base64 = \"\",\n      groupPos = 0,\n      // position in base64 group\n      b,\n      // current byte\n      p = 0; // carry over from previous byte\n    for (let i = 0; i < bytes.length; i++) {\n      b = bytes[i];\n      switch (groupPos) {\n        case 0:\n          base64 += encTable[b >> 2];\n          p = (b & 3) << 4;\n          groupPos = 1;\n          break;\n        case 1:\n          base64 += encTable[p | b >> 4];\n          p = (b & 15) << 2;\n          groupPos = 2;\n          break;\n        case 2:\n          base64 += encTable[p | b >> 6];\n          base64 += encTable[b & 63];\n          groupPos = 0;\n          break;\n      }\n    }\n    // add output padding\n    if (groupPos) {\n      base64 += encTable[p];\n      base64 += \"=\";\n      if (groupPos == 1) base64 += \"=\";\n    }\n    return base64;\n  }\n};\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Retrieve an extension value from a message.\n *\n * The function never returns undefined. Use hasExtension() to check whether an\n * extension is set. If the extension is not set, this function returns the\n * default value (if one was specified in the protobuf source), or the zero value\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\n * an empty message instance for message fields).\n *\n * Extensions are stored as unknown fields on a message. To mutate an extension\n * value, make sure to store the new value with setExtension() after mutating.\n *\n * If the extension does not extend the given message, an error is raised.\n */\nfunction getExtension(message, extension, options) {\n  assertExtendee(extension, message);\n  const opt = extension.runtime.bin.makeReadOptions(options);\n  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\n  const [container, get] = createExtensionContainer(extension);\n  for (const uf of ufs) {\n    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\n  }\n  return get();\n}\n/**\n * Set an extension value on a message. If the message already has a value for\n * this extension, the value is replaced.\n *\n * If the extension does not extend the given message, an error is raised.\n */\nfunction setExtension(message, extension, value, options) {\n  assertExtendee(extension, message);\n  const readOpt = extension.runtime.bin.makeReadOptions(options);\n  const writeOpt = extension.runtime.bin.makeWriteOptions(options);\n  if (hasExtension(message, extension)) {\n    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter(uf => uf.no != extension.field.no);\n    message.getType().runtime.bin.discardUnknownFields(message);\n    for (const uf of ufs) {\n      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\n    }\n  }\n  const writer = writeOpt.writerFactory();\n  let f = extension.field;\n  // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\n  // We patch the field info to use explicit presence:\n  if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\n    f = Object.assign(Object.assign({}, extension.field), {\n      opt: true\n    });\n  }\n  extension.runtime.bin.writeField(f, value, writer, writeOpt);\n  const reader = readOpt.readerFactory(writer.finish());\n  while (reader.pos < reader.len) {\n    const [no, wireType] = reader.tag();\n    const data = reader.skip(wireType, no);\n    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\n  }\n}\n/**\n * Check whether an extension is set on a message.\n */\nfunction hasExtension(message, extension) {\n  const messageType = message.getType();\n  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find(uf => uf.no == extension.field.no);\n}\nfunction assertExtendee(extension, message) {\n  assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if the field is set.\n */\nfunction isFieldSet(field, target) {\n  const localName = field.localName;\n  if (field.repeated) {\n    return target[localName].length > 0;\n  }\n  if (field.oneof) {\n    return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\n  }\n  switch (field.kind) {\n    case \"enum\":\n    case \"scalar\":\n      if (field.opt || field.req) {\n        // explicit presence\n        return target[localName] !== undefined;\n      }\n      // implicit presence\n      if (field.kind == \"enum\") {\n        return target[localName] !== field.T.values[0].no;\n      }\n      return !isScalarZeroValue(field.T, target[localName]);\n    case \"message\":\n      return target[localName] !== undefined;\n    case \"map\":\n      return Object.keys(target[localName]).length > 0;\n    // eslint-disable-line @typescript-eslint/no-unsafe-argument\n  }\n}\n/**\n * Resets the field, so that isFieldSet() will return false.\n */\nfunction clearField(field, target) {\n  const localName = field.localName;\n  const implicitPresence = !field.opt && !field.req;\n  if (field.repeated) {\n    target[localName] = [];\n  } else if (field.oneof) {\n    target[field.oneof.localName] = {\n      case: undefined\n    };\n  } else {\n    switch (field.kind) {\n      case \"map\":\n        target[localName] = {};\n        break;\n      case \"enum\":\n        target[localName] = implicitPresence ? field.T.values[0].no : undefined;\n        break;\n      case \"scalar\":\n        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\n        break;\n      case \"message\":\n        target[localName] = undefined;\n        break;\n    }\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Check whether the given object is any subtype of Message or is a specific\n * Message by passing the type.\n *\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\n * `isMessage` is that it compares identity by the message type name, not by\n * class identity. This makes it robust against the dual package hazard and\n * similar situations, where the same message is duplicated.\n *\n * This function is _mostly_ equivalent to the `instanceof` operator. For\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\n * `isMessage` should be preferred over `instanceof`.\n *\n * However, due to the fact that `isMessage` does not use class identity, there\n * are subtle differences between this function and `instanceof`. Notably,\n * calling `isMessage` on an explicit type of Message will return false.\n */\nfunction isMessage(arg, type) {\n  if (arg === null || typeof arg != \"object\") {\n    return false;\n  }\n  if (!Object.getOwnPropertyNames(Message.prototype).every(m => m in arg && typeof arg[m] == \"function\")) {\n    return false;\n  }\n  const actualType = arg.getType();\n  if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\n    return false;\n  }\n  return type === undefined ? true : actualType.typeName == type.typeName;\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */\nfunction wrapField(type, value) {\n  if (isMessage(value) || !type.fieldWrapper) {\n    return value;\n  }\n  return type.fieldWrapper.wrapField(value);\n}\n({\n  \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n  \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n  \"google.protobuf.Int64Value\": ScalarType.INT64,\n  \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n  \"google.protobuf.Int32Value\": ScalarType.INT32,\n  \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n  \"google.protobuf.BoolValue\": ScalarType.BOOL,\n  \"google.protobuf.StringValue\": ScalarType.STRING,\n  \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */\n// Default options for parsing JSON.\nconst jsonReadDefaults = {\n  ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n  emitDefaultValues: false,\n  enumAsInteger: false,\n  useProtoFieldName: false,\n  prettySpaces: 0\n};\nfunction makeReadOptions$1(options) {\n  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions$1(options) {\n  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nconst tokenNull = Symbol();\nconst tokenIgnoredUnknownEnum = Symbol();\nfunction makeJsonFormat() {\n  return {\n    makeReadOptions: makeReadOptions$1,\n    makeWriteOptions: makeWriteOptions$1,\n    readMessage(type, json, options, message) {\n      if (json == null || Array.isArray(json) || typeof json != \"object\") {\n        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n      }\n      message = message !== null && message !== void 0 ? message : new type();\n      const oneofSeen = new Map();\n      const registry = options.typeRegistry;\n      for (const [jsonKey, jsonValue] of Object.entries(json)) {\n        const field = type.fields.findJsonName(jsonKey);\n        if (field) {\n          if (field.oneof) {\n            if (jsonValue === null && field.kind == \"scalar\") {\n              // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}\n              continue;\n            }\n            const seen = oneofSeen.get(field.oneof);\n            if (seen !== undefined) {\n              throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\n            }\n            oneofSeen.set(field.oneof, jsonKey);\n          }\n          readField$1(message, jsonValue, field, options, type);\n        } else {\n          let found = false;\n          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\n            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\n            if (ext && ext.extendee.typeName == type.typeName) {\n              found = true;\n              const [container, get] = createExtensionContainer(ext);\n              readField$1(container, jsonValue, ext.field, options, ext);\n              // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\n              // so that users can bring their own binary reader and writer factories\n              // if necessary.\n              setExtension(message, ext, get(), options);\n            }\n          }\n          if (!found && !options.ignoreUnknownFields) {\n            throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\n          }\n        }\n      }\n      return message;\n    },\n    writeMessage(message, options) {\n      const type = message.getType();\n      const json = {};\n      let field;\n      try {\n        for (field of type.fields.byNumber()) {\n          if (!isFieldSet(field, message)) {\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (field.req) {\n              throw \"required field not set\";\n            }\n            if (!options.emitDefaultValues) {\n              continue;\n            }\n            if (!canEmitFieldDefaultValue(field)) {\n              continue;\n            }\n          }\n          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n          const jsonValue = writeField$1(field, value, options);\n          if (jsonValue !== undefined) {\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n          }\n        }\n        const registry = options.typeRegistry;\n        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\n          for (const uf of type.runtime.bin.listUnknownFields(message)) {\n            const ext = registry.findExtensionFor(type.typeName, uf.no);\n            if (ext && hasExtension(message, ext)) {\n              // We pass on the options as BinaryReadOptions, so that users can bring their own\n              // binary reader factory if necessary.\n              const value = getExtension(message, ext, options);\n              const jsonValue = writeField$1(ext.field, value, options);\n              if (jsonValue !== undefined) {\n                json[ext.field.jsonName] = jsonValue;\n              }\n            }\n          }\n        }\n      } catch (e) {\n        const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n        const r = e instanceof Error ? e.message : String(e);\n        throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n      }\n      return json;\n    },\n    readScalar(type, json, longType) {\n      // The signature of our internal function has changed. For backwards-\n      // compatibility, we support the old form that is part of the public API\n      // through the interface JsonFormat.\n      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\n    },\n    writeScalar(type, value, emitDefaultValues) {\n      // The signature of our internal function has changed. For backwards-\n      // compatibility, we support the old form that is part of the public API\n      // through the interface JsonFormat.\n      if (value === undefined) {\n        return undefined;\n      }\n      if (emitDefaultValues || isScalarZeroValue(type, value)) {\n        return writeScalar$1(type, value);\n      }\n      return undefined;\n    },\n    debug: debugJsonValue\n  };\n}\nfunction debugJsonValue(json) {\n  if (json === null) {\n    return \"null\";\n  }\n  switch (typeof json) {\n    case \"object\":\n      return Array.isArray(json) ? \"array\" : \"object\";\n    case \"string\":\n      return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\n    default:\n      return String(json);\n  }\n}\n// Read a JSON value for a field.\n// The \"parentType\" argument is only used to provide context in errors.\nfunction readField$1(target, jsonValue, field, options, parentType) {\n  let localName = field.localName;\n  if (field.repeated) {\n    assert(field.kind != \"map\");\n    if (jsonValue === null) {\n      return;\n    }\n    if (!Array.isArray(jsonValue)) {\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n    }\n    const targetArray = target[localName];\n    for (const jsonItem of jsonValue) {\n      if (jsonItem === null) {\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\n      }\n      switch (field.kind) {\n        case \"message\":\n          targetArray.push(field.T.fromJson(jsonItem, options));\n          break;\n        case \"enum\":\n          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\n          if (enumValue !== tokenIgnoredUnknownEnum) {\n            targetArray.push(enumValue);\n          }\n          break;\n        case \"scalar\":\n          try {\n            targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\n          } catch (e) {\n            let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\n            if (e instanceof Error && e.message.length > 0) {\n              m += \": \".concat(e.message);\n            }\n            throw new Error(m);\n          }\n          break;\n      }\n    }\n  } else if (field.kind == \"map\") {\n    if (jsonValue === null) {\n      return;\n    }\n    if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n    }\n    const targetMap = target[localName];\n    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {\n      if (jsonMapValue === null) {\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n      }\n      let key;\n      try {\n        key = readMapKey(field.K, jsonMapKey);\n      } catch (e) {\n        let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n        if (e instanceof Error && e.message.length > 0) {\n          m += \": \".concat(e.message);\n        }\n        throw new Error(m);\n      }\n      switch (field.V.kind) {\n        case \"message\":\n          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\n          break;\n        case \"enum\":\n          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\n          if (enumValue !== tokenIgnoredUnknownEnum) {\n            targetMap[key] = enumValue;\n          }\n          break;\n        case \"scalar\":\n          try {\n            targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\n          } catch (e) {\n            let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n            if (e instanceof Error && e.message.length > 0) {\n              m += \": \".concat(e.message);\n            }\n            throw new Error(m);\n          }\n          break;\n      }\n    }\n  } else {\n    if (field.oneof) {\n      target = target[field.oneof.localName] = {\n        case: localName\n      };\n      localName = \"value\";\n    }\n    switch (field.kind) {\n      case \"message\":\n        const messageType = field.T;\n        if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n          return;\n        }\n        let currentValue = target[localName];\n        if (isMessage(currentValue)) {\n          currentValue.fromJson(jsonValue, options);\n        } else {\n          target[localName] = currentValue = messageType.fromJson(jsonValue, options);\n          if (messageType.fieldWrapper && !field.oneof) {\n            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\n          }\n        }\n        break;\n      case \"enum\":\n        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\n        switch (enumValue) {\n          case tokenNull:\n            clearField(field, target);\n            break;\n          case tokenIgnoredUnknownEnum:\n            break;\n          default:\n            target[localName] = enumValue;\n            break;\n        }\n        break;\n      case \"scalar\":\n        try {\n          const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\n          switch (scalarValue) {\n            case tokenNull:\n              clearField(field, target);\n              break;\n            default:\n              target[localName] = scalarValue;\n              break;\n          }\n        } catch (e) {\n          let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n          if (e instanceof Error && e.message.length > 0) {\n            m += \": \".concat(e.message);\n          }\n          throw new Error(m);\n        }\n        break;\n    }\n  }\n}\nfunction readMapKey(type, json) {\n  if (type === ScalarType.BOOL) {\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch (json) {\n      case \"true\":\n        json = true;\n        break;\n      case \"false\":\n        json = false;\n        break;\n    }\n  }\n  return readScalar$1(type, json, LongType.BIGINT, true).toString();\n}\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\n  if (json === null) {\n    if (nullAsZeroValue) {\n      return scalarZeroValue(type, longType);\n    }\n    return tokenNull;\n  }\n  // every valid case in the switch below returns, and every fall\n  // through is regarded as a failure.\n  switch (type) {\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      if (json === \"NaN\") return Number.NaN;\n      if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n      if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n      if (json === \"\") {\n        // empty string is not a number\n        break;\n      }\n      if (typeof json == \"string\" && json.trim().length !== json.length) {\n        // extra whitespace\n        break;\n      }\n      if (typeof json != \"string\" && typeof json != \"number\") {\n        break;\n      }\n      const float = Number(json);\n      if (Number.isNaN(float)) {\n        // not a number\n        break;\n      }\n      if (!Number.isFinite(float)) {\n        // infinity and -infinity are handled by string representation above, so this is an error\n        break;\n      }\n      if (type == ScalarType.FLOAT) assertFloat32(float);\n      return float;\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.UINT32:\n      let int32;\n      if (typeof json == \"number\") int32 = json;else if (typeof json == \"string\" && json.length > 0) {\n        if (json.trim().length === json.length) int32 = Number(json);\n      }\n      if (int32 === undefined) break;\n      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);else assertInt32(int32);\n      return int32;\n    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      if (typeof json != \"number\" && typeof json != \"string\") break;\n      const long = protoInt64.parse(json);\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      return longType ? long.toString() : long;\n    case ScalarType.FIXED64:\n    case ScalarType.UINT64:\n      if (typeof json != \"number\" && typeof json != \"string\") break;\n      const uLong = protoInt64.uParse(json);\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      return longType ? uLong.toString() : uLong;\n    // bool:\n    case ScalarType.BOOL:\n      if (typeof json !== \"boolean\") break;\n      return json;\n    // string:\n    case ScalarType.STRING:\n      if (typeof json !== \"string\") {\n        break;\n      }\n      // A string must always contain UTF-8 encoded or 7-bit ASCII.\n      // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n      try {\n        encodeURIComponent(json);\n      } catch (e) {\n        throw new Error(\"invalid UTF8\");\n      }\n      return json;\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n    case ScalarType.BYTES:\n      if (json === \"\") return new Uint8Array(0);\n      if (typeof json !== \"string\") break;\n      return protoBase64.dec(json);\n  }\n  throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\n  if (json === null) {\n    if (type.typeName == \"google.protobuf.NullValue\") {\n      return 0; // google.protobuf.NullValue.NULL_VALUE = 0\n    }\n    return nullAsZeroValue ? type.values[0].no : tokenNull;\n  }\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (typeof json) {\n    case \"number\":\n      if (Number.isInteger(json)) {\n        return json;\n      }\n      break;\n    case \"string\":\n      const value = type.findName(json);\n      if (value !== undefined) {\n        return value.no;\n      }\n      if (ignoreUnknownFields) {\n        return tokenIgnoredUnknownEnum;\n      }\n      break;\n  }\n  throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\nfunction canEmitFieldDefaultValue(field) {\n  if (field.repeated || field.kind == \"map\") {\n    // maps are {}, repeated fields are []\n    return true;\n  }\n  if (field.oneof) {\n    // oneof fields are never emitted\n    return false;\n  }\n  if (field.kind == \"message\") {\n    // singular message field are allowed to emit JSON null, but we do not\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (field.opt || field.req) {\n    // the field uses explicit presence, so we cannot emit a zero value\n    return false;\n  }\n  return true;\n}\nfunction writeField$1(field, value, options) {\n  if (field.kind == \"map\") {\n    assert(typeof value == \"object\" && value != null);\n    const jsonObj = {};\n    const entries = Object.entries(value);\n    switch (field.V.kind) {\n      case \"scalar\":\n        for (const [entryKey, entryValue] of entries) {\n          jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\n        }\n        break;\n      case \"message\":\n        for (const [entryKey, entryValue] of entries) {\n          // JSON standard allows only (double quoted) string as property key\n          jsonObj[entryKey.toString()] = entryValue.toJson(options);\n        }\n        break;\n      case \"enum\":\n        const enumType = field.V.T;\n        for (const [entryKey, entryValue] of entries) {\n          // JSON standard allows only (double quoted) string as property key\n          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\n        }\n        break;\n    }\n    return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\n  }\n  if (field.repeated) {\n    assert(Array.isArray(value));\n    const jsonArr = [];\n    switch (field.kind) {\n      case \"scalar\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(writeScalar$1(field.T, value[i]));\n        }\n        break;\n      case \"enum\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\n        }\n        break;\n      case \"message\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(value[i].toJson(options));\n        }\n        break;\n    }\n    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n  }\n  switch (field.kind) {\n    case \"scalar\":\n      return writeScalar$1(field.T, value);\n    case \"enum\":\n      return writeEnum(field.T, value, options.enumAsInteger);\n    case \"message\":\n      return wrapField(field.T, value).toJson(options);\n  }\n}\nfunction writeEnum(type, value, enumAsInteger) {\n  var _a;\n  assert(typeof value == \"number\");\n  if (type.typeName == \"google.protobuf.NullValue\") {\n    return null;\n  }\n  if (enumAsInteger) {\n    return value;\n  }\n  const val = type.findNumber(value);\n  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar$1(type, value) {\n  switch (type) {\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n    case ScalarType.INT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n      assert(typeof value == \"number\");\n      return value;\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\n    case ScalarType.FLOAT:\n    // assertFloat32(value);\n    case ScalarType.DOUBLE:\n      // eslint-disable-line no-fallthrough\n      assert(typeof value == \"number\");\n      if (Number.isNaN(value)) return \"NaN\";\n      if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n      if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n      return value;\n    // string:\n    case ScalarType.STRING:\n      assert(typeof value == \"string\");\n      return value;\n    // bool:\n    case ScalarType.BOOL:\n      assert(typeof value == \"boolean\");\n      return value;\n    // JSON value will be a decimal string. Either numbers or strings are accepted.\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n      return value.toString();\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n    case ScalarType.BYTES:\n      assert(value instanceof Uint8Array);\n      return protoBase64.enc(value);\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n  readUnknownFields: true,\n  readerFactory: bytes => new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n  writeUnknownFields: true,\n  writerFactory: () => new BinaryWriter()\n};\nfunction makeReadOptions(options) {\n  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormat() {\n  return {\n    makeReadOptions,\n    makeWriteOptions,\n    listUnknownFields(message) {\n      var _a;\n      return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n    },\n    discardUnknownFields(message) {\n      delete message[unknownFieldsSymbol];\n    },\n    writeUnknownFields(message, writer) {\n      const m = message;\n      const c = m[unknownFieldsSymbol];\n      if (c) {\n        for (const f of c) {\n          writer.tag(f.no, f.wireType).raw(f.data);\n        }\n      }\n    },\n    onUnknownField(message, no, wireType, data) {\n      const m = message;\n      if (!Array.isArray(m[unknownFieldsSymbol])) {\n        m[unknownFieldsSymbol] = [];\n      }\n      m[unknownFieldsSymbol].push({\n        no,\n        wireType,\n        data\n      });\n    },\n    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n      const type = message.getType();\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\n      let fieldNo, wireType;\n      while (reader.pos < end) {\n        [fieldNo, wireType] = reader.tag();\n        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\n          break;\n        }\n        const field = type.fields.find(fieldNo);\n        if (!field) {\n          const data = reader.skip(wireType, fieldNo);\n          if (options.readUnknownFields) {\n            this.onUnknownField(message, fieldNo, wireType, data);\n          }\n          continue;\n        }\n        readField(message, reader, field, wireType, options);\n      }\n      if (delimitedMessageEncoding && (\n      // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n      wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n        throw new Error(\"invalid end group tag\");\n      }\n    },\n    readField,\n    writeMessage(message, writer, options) {\n      const type = message.getType();\n      for (const field of type.fields.byNumber()) {\n        if (!isFieldSet(field, message)) {\n          if (field.req) {\n            throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\n          }\n          continue;\n        }\n        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n        writeField(field, value, writer, options);\n      }\n      if (options.writeUnknownFields) {\n        this.writeUnknownFields(message, writer);\n      }\n      return writer;\n    },\n    writeField(field, value, writer, options) {\n      // The behavior of our internal function has changed, it does no longer\n      // accept `undefined` values for singular scalar and map.\n      // For backwards-compatibility, we support the old form that is part of\n      // the public API through the interface BinaryFormat.\n      if (value === undefined) {\n        return undefined;\n      }\n      writeField(field, value, writer, options);\n    }\n  };\n}\nfunction readField(target,\n// eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\nreader, field, wireType, options) {\n  let {\n    repeated,\n    localName\n  } = field;\n  if (field.oneof) {\n    target = target[field.oneof.localName];\n    if (target.case != localName) {\n      delete target.value;\n    }\n    target.case = localName;\n    localName = \"value\";\n  }\n  switch (field.kind) {\n    case \"scalar\":\n    case \"enum\":\n      const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n      let read = readScalar;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n      if (field.kind == \"scalar\" && field.L > 0) {\n        read = readScalarLTString;\n      }\n      if (repeated) {\n        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\n        if (isPacked) {\n          let e = reader.uint32() + reader.pos;\n          while (reader.pos < e) {\n            arr.push(read(reader, scalarType));\n          }\n        } else {\n          arr.push(read(reader, scalarType));\n        }\n      } else {\n        target[localName] = read(reader, scalarType);\n      }\n      break;\n    case \"message\":\n      const messageType = field.T;\n      if (repeated) {\n        // safe to assume presence of array, oneof cannot contain repeated values\n        target[localName].push(readMessageField(reader, new messageType(), options, field));\n      } else {\n        if (isMessage(target[localName])) {\n          readMessageField(reader, target[localName], options, field);\n        } else {\n          target[localName] = readMessageField(reader, new messageType(), options, field);\n          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n          }\n        }\n      }\n      break;\n    case \"map\":\n      let [mapKey, mapVal] = readMapEntry(field, reader, options);\n      // safe to assume presence of map object, oneof cannot contain repeated values\n      target[localName][mapKey] = mapVal;\n      break;\n  }\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n  const format = message.getType().runtime.bin;\n  const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n  format.readMessage(message, reader, delimited ? field.no : reader.uint32(),\n  // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n  options, delimited);\n  return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n  const length = reader.uint32(),\n    end = reader.pos + length;\n  let key, val;\n  while (reader.pos < end) {\n    const [fieldNo] = reader.tag();\n    switch (fieldNo) {\n      case 1:\n        key = readScalar(reader, field.K);\n        break;\n      case 2:\n        switch (field.V.kind) {\n          case \"scalar\":\n            val = readScalar(reader, field.V.T);\n            break;\n          case \"enum\":\n            val = reader.int32();\n            break;\n          case \"message\":\n            val = readMessageField(reader, new field.V.T(), options, undefined);\n            break;\n        }\n        break;\n    }\n  }\n  if (key === undefined) {\n    key = scalarZeroValue(field.K, LongType.BIGINT);\n  }\n  if (typeof key != \"string\" && typeof key != \"number\") {\n    key = key.toString();\n  }\n  if (val === undefined) {\n    switch (field.V.kind) {\n      case \"scalar\":\n        val = scalarZeroValue(field.V.T, LongType.BIGINT);\n        break;\n      case \"enum\":\n        val = field.V.T.values[0].no;\n        break;\n      case \"message\":\n        val = new field.V.T();\n        break;\n    }\n  }\n  return [key, val];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n  const v = readScalar(reader, type);\n  return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n  switch (type) {\n    case ScalarType.STRING:\n      return reader.string();\n    case ScalarType.BOOL:\n      return reader.bool();\n    case ScalarType.DOUBLE:\n      return reader.double();\n    case ScalarType.FLOAT:\n      return reader.float();\n    case ScalarType.INT32:\n      return reader.int32();\n    case ScalarType.INT64:\n      return reader.int64();\n    case ScalarType.UINT64:\n      return reader.uint64();\n    case ScalarType.FIXED64:\n      return reader.fixed64();\n    case ScalarType.BYTES:\n      return reader.bytes();\n    case ScalarType.FIXED32:\n      return reader.fixed32();\n    case ScalarType.SFIXED32:\n      return reader.sfixed32();\n    case ScalarType.SFIXED64:\n      return reader.sfixed64();\n    case ScalarType.SINT64:\n      return reader.sint64();\n    case ScalarType.UINT32:\n      return reader.uint32();\n    case ScalarType.SINT32:\n      return reader.sint32();\n  }\n}\nfunction writeField(field, value, writer, options) {\n  assert(value !== undefined);\n  const repeated = field.repeated;\n  switch (field.kind) {\n    case \"scalar\":\n    case \"enum\":\n      let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n      if (repeated) {\n        assert(Array.isArray(value));\n        if (field.packed) {\n          writePacked(writer, scalarType, field.no, value);\n        } else {\n          for (const item of value) {\n            writeScalar(writer, scalarType, field.no, item);\n          }\n        }\n      } else {\n        writeScalar(writer, scalarType, field.no, value);\n      }\n      break;\n    case \"message\":\n      if (repeated) {\n        assert(Array.isArray(value));\n        for (const item of value) {\n          writeMessageField(writer, options, field, item);\n        }\n      } else {\n        writeMessageField(writer, options, field, value);\n      }\n      break;\n    case \"map\":\n      assert(typeof value == \"object\" && value != null);\n      for (const [key, val] of Object.entries(value)) {\n        writeMapEntry(writer, options, field, key, val);\n      }\n      break;\n  }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n  writer.tag(field.no, WireType.LengthDelimited);\n  writer.fork();\n  // javascript only allows number or string for object properties\n  // we convert from our representation to the protobuf type\n  let keyValue = key;\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n  switch (field.K) {\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n      keyValue = Number.parseInt(key);\n      break;\n    case ScalarType.BOOL:\n      assert(key == \"true\" || key == \"false\");\n      keyValue = key == \"true\";\n      break;\n  }\n  // write key, expecting key field number = 1\n  writeScalar(writer, field.K, 1, keyValue);\n  // write value, expecting value field number = 2\n  switch (field.V.kind) {\n    case \"scalar\":\n      writeScalar(writer, field.V.T, 2, value);\n      break;\n    case \"enum\":\n      writeScalar(writer, ScalarType.INT32, 2, value);\n      break;\n    case \"message\":\n      assert(value !== undefined);\n      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\n      break;\n  }\n  writer.join();\n}\n// Value must not be undefined\nfunction writeMessageField(writer, options, field, value) {\n  const message = wrapField(field.T, value);\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\n}\nfunction writeScalar(writer, type, fieldNo, value) {\n  assert(value !== undefined);\n  let [wireType, method] = scalarTypeInfo(type);\n  writer.tag(fieldNo, wireType)[method](value);\n}\nfunction writePacked(writer, type, fieldNo, value) {\n  if (!value.length) {\n    return;\n  }\n  writer.tag(fieldNo, WireType.LengthDelimited).fork();\n  let [, method] = scalarTypeInfo(type);\n  for (let i = 0; i < value.length; i++) {\n    writer[method](value[i]);\n  }\n  writer.join();\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */\n// TODO replace call-sites writeScalar() and writePacked(), then remove\nfunction scalarTypeInfo(type) {\n  let wireType = WireType.Varint;\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n  switch (type) {\n    case ScalarType.BYTES:\n    case ScalarType.STRING:\n      wireType = WireType.LengthDelimited;\n      break;\n    case ScalarType.DOUBLE:\n    case ScalarType.FIXED64:\n    case ScalarType.SFIXED64:\n      wireType = WireType.Bit64;\n      break;\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.FLOAT:\n      wireType = WireType.Bit32;\n      break;\n  }\n  const method = ScalarType[type].toLowerCase();\n  return [wireType, method];\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\nfunction makeUtilCommon() {\n  return {\n    setEnumType,\n    initPartial(source, target) {\n      if (source === undefined) {\n        return;\n      }\n      const type = target.getType();\n      for (const member of type.fields.byMember()) {\n        const localName = member.localName,\n          t = target,\n          s = source;\n        if (s[localName] == null) {\n          // TODO if source is a Message instance, we should use isFieldSet() here to support future field presence\n          continue;\n        }\n        switch (member.kind) {\n          case \"oneof\":\n            const sk = s[localName].case;\n            if (sk === undefined) {\n              continue;\n            }\n            const sourceField = member.findField(sk);\n            let val = s[localName].value;\n            if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\n              val = new sourceField.T(val);\n            } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n              val = toU8Arr(val);\n            }\n            t[localName] = {\n              case: sk,\n              value: val\n            };\n            break;\n          case \"scalar\":\n          case \"enum\":\n            let copy = s[localName];\n            if (member.T === ScalarType.BYTES) {\n              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n            }\n            t[localName] = copy;\n            break;\n          case \"map\":\n            switch (member.V.kind) {\n              case \"scalar\":\n              case \"enum\":\n                if (member.V.T === ScalarType.BYTES) {\n                  for (const [k, v] of Object.entries(s[localName])) {\n                    t[localName][k] = toU8Arr(v);\n                  }\n                } else {\n                  Object.assign(t[localName], s[localName]);\n                }\n                break;\n              case \"message\":\n                const messageType = member.V.T;\n                for (const k of Object.keys(s[localName])) {\n                  let val = s[localName][k];\n                  if (!messageType.fieldWrapper) {\n                    // We only take partial input for messages that are not a wrapper type.\n                    // For those messages, we recursively normalize the partial input.\n                    val = new messageType(val);\n                  }\n                  t[localName][k] = val;\n                }\n                break;\n            }\n            break;\n          case \"message\":\n            const mt = member.T;\n            if (member.repeated) {\n              t[localName] = s[localName].map(val => isMessage(val, mt) ? val : new mt(val));\n            } else {\n              const val = s[localName];\n              if (mt.fieldWrapper) {\n                if (\n                // We can't use BytesValue.typeName as that will create a circular import\n                mt.typeName === \"google.protobuf.BytesValue\") {\n                  t[localName] = toU8Arr(val);\n                } else {\n                  t[localName] = val;\n                }\n              } else {\n                t[localName] = isMessage(val, mt) ? val : new mt(val);\n              }\n            }\n            break;\n        }\n      }\n    },\n    // TODO use isFieldSet() here to support future field presence\n    equals(type, a, b) {\n      if (a === b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      return type.fields.byMember().every(m => {\n        const va = a[m.localName];\n        const vb = b[m.localName];\n        if (m.repeated) {\n          if (va.length !== vb.length) {\n            return false;\n          }\n          // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n          switch (m.kind) {\n            case \"message\":\n              return va.every((a, i) => m.T.equals(a, vb[i]));\n            case \"scalar\":\n              return va.every((a, i) => scalarEquals(m.T, a, vb[i]));\n            case \"enum\":\n              return va.every((a, i) => scalarEquals(ScalarType.INT32, a, vb[i]));\n          }\n          throw new Error(\"repeated cannot contain \".concat(m.kind));\n        }\n        switch (m.kind) {\n          case \"message\":\n            return m.T.equals(va, vb);\n          case \"enum\":\n            return scalarEquals(ScalarType.INT32, va, vb);\n          case \"scalar\":\n            return scalarEquals(m.T, va, vb);\n          case \"oneof\":\n            if (va.case !== vb.case) {\n              return false;\n            }\n            const s = m.findField(va.case);\n            if (s === undefined) {\n              return true;\n            }\n            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n            switch (s.kind) {\n              case \"message\":\n                return s.T.equals(va.value, vb.value);\n              case \"enum\":\n                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n              case \"scalar\":\n                return scalarEquals(s.T, va.value, vb.value);\n            }\n            throw new Error(\"oneof cannot contain \".concat(s.kind));\n          case \"map\":\n            const keys = Object.keys(va).concat(Object.keys(vb));\n            switch (m.V.kind) {\n              case \"message\":\n                const messageType = m.V.T;\n                return keys.every(k => messageType.equals(va[k], vb[k]));\n              case \"enum\":\n                return keys.every(k => scalarEquals(ScalarType.INT32, va[k], vb[k]));\n              case \"scalar\":\n                const scalarType = m.V.T;\n                return keys.every(k => scalarEquals(scalarType, va[k], vb[k]));\n            }\n            break;\n        }\n      });\n    },\n    // TODO use isFieldSet() here to support future field presence\n    clone(message) {\n      const type = message.getType(),\n        target = new type(),\n        any = target;\n      for (const member of type.fields.byMember()) {\n        const source = message[member.localName];\n        let copy;\n        if (member.repeated) {\n          copy = source.map(cloneSingularField);\n        } else if (member.kind == \"map\") {\n          copy = any[member.localName];\n          for (const [key, v] of Object.entries(source)) {\n            copy[key] = cloneSingularField(v);\n          }\n        } else if (member.kind == \"oneof\") {\n          const f = member.findField(source.case);\n          copy = f ? {\n            case: source.case,\n            value: cloneSingularField(source.value)\n          } : {\n            case: undefined\n          };\n        } else {\n          copy = cloneSingularField(source);\n        }\n        any[member.localName] = copy;\n      }\n      for (const uf of type.runtime.bin.listUnknownFields(message)) {\n        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\n      }\n      return target;\n    }\n  };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n  if (value === undefined) {\n    return value;\n  }\n  if (isMessage(value)) {\n    return value.clone();\n  }\n  if (value instanceof Uint8Array) {\n    const c = new Uint8Array(value.byteLength);\n    c.set(value);\n    return c;\n  }\n  return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n  return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\n  return {\n    syntax,\n    json: makeJsonFormat(),\n    bin: makeBinaryFormat(),\n    util: Object.assign(Object.assign({}, makeUtilCommon()), {\n      newFieldList,\n      initFields\n    }),\n    makeMessageType(typeName, fields, opt) {\n      return makeMessageType(this, typeName, fields, opt);\n    },\n    makeEnum,\n    makeEnumType,\n    getEnumType,\n    makeExtension(typeName, extendee, field) {\n      return makeExtension(this, typeName, extendee, field);\n    }\n  };\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n  constructor(fields, normalizer) {\n    this._fields = fields;\n    this._normalizer = normalizer;\n  }\n  findJsonName(jsonName) {\n    if (!this.jsonNames) {\n      const t = {};\n      for (const f of this.list()) {\n        t[f.jsonName] = t[f.name] = f;\n      }\n      this.jsonNames = t;\n    }\n    return this.jsonNames[jsonName];\n  }\n  find(fieldNo) {\n    if (!this.numbers) {\n      const t = {};\n      for (const f of this.list()) {\n        t[f.no] = f;\n      }\n      this.numbers = t;\n    }\n    return this.numbers[fieldNo];\n  }\n  list() {\n    if (!this.all) {\n      this.all = this._normalizer(this._fields);\n    }\n    return this.all;\n  }\n  byNumber() {\n    if (!this.numbersAsc) {\n      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);\n    }\n    return this.numbersAsc;\n  }\n  byMember() {\n    if (!this.members) {\n      this.members = [];\n      const a = this.members;\n      let o;\n      for (const f of this.list()) {\n        if (f.oneof) {\n          if (f.oneof !== o) {\n            o = f.oneof;\n            a.push(o);\n          }\n        } else {\n          a.push(f);\n        }\n      }\n    }\n    return this.members;\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */\n/**\n * Returns the name of a field in generated code.\n */\nfunction localFieldName(protoName, inOneof) {\n  const name = protoCamelCase(protoName);\n  if (inOneof) {\n    // oneof member names are not properties, but values of the `case` property.\n    return name;\n  }\n  return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */\nfunction localOneofName(protoName) {\n  return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */\nconst fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */\nfunction protoCamelCase(snakeCase) {\n  let capNext = false;\n  const b = [];\n  for (let i = 0; i < snakeCase.length; i++) {\n    let c = snakeCase.charAt(i);\n    switch (c) {\n      case \"_\":\n        capNext = true;\n        break;\n      case \"0\":\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        b.push(c);\n        capNext = false;\n        break;\n      default:\n        if (capNext) {\n          capNext = false;\n          c = c.toUpperCase();\n        }\n        b.push(c);\n        break;\n    }\n  }\n  return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst reservedObjectProperties = new Set([\n// names reserved by JavaScript\n\"constructor\", \"toString\", \"toJSON\", \"valueOf\"]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */\nconst reservedMessageProperties = new Set([\n// names reserved by the runtime\n\"getType\", \"clone\", \"equals\", \"fromBinary\", \"fromJson\", \"fromJsonString\", \"toBinary\", \"toJson\", \"toJsonString\",\n// names reserved by the runtime for the future\n\"toObject\"]);\nconst fallback = name => \"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */\nconst safeMessageProperty = name => {\n  if (reservedMessageProperties.has(name)) {\n    return fallback(name);\n  }\n  return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst safeObjectProperty = name => {\n  if (reservedObjectProperties.has(name)) {\n    return fallback(name);\n  }\n  return name;\n};\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n  constructor(name) {\n    this.kind = \"oneof\";\n    this.repeated = false;\n    this.packed = false;\n    this.opt = false;\n    this.req = false;\n    this.default = undefined;\n    this.fields = [];\n    this.name = name;\n    this.localName = localOneofName(name);\n  }\n  addField(field) {\n    assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n    this.fields.push(field);\n  }\n  findField(localName) {\n    if (!this._lookup) {\n      this._lookup = Object.create(null);\n      for (let i = 0; i < this.fields.length; i++) {\n        this._lookup[this.fields[i].localName] = this.fields[i];\n      }\n    }\n    return this._lookup[localName];\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Convert a collection of field info to an array of normalized FieldInfo.\n *\n * The argument `packedByDefault` specifies whether fields that do not specify\n * `packed` should be packed (proto3) or unpacked (proto2).\n */\nfunction normalizeFieldInfos(fieldInfos, packedByDefault) {\n  var _a, _b, _c, _d, _e, _f;\n  const r = [];\n  let o;\n  for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos) {\n    const f = field;\n    f.localName = localFieldName(field.name, field.oneof !== undefined);\n    f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n    f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n    if (field.kind == \"scalar\") {\n      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n    }\n    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\n    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\n    if (field.packed === undefined) {\n      {\n        f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n      }\n    }\n    // We do not surface options at this time\n    // f.options = field.options ?? emptyReadonlyObject;\n    if (field.oneof !== undefined) {\n      const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n      if (!o || o.name != ooname) {\n        o = new InternalOneofInfo(ooname);\n      }\n      f.oneof = o;\n      o.addField(f);\n    }\n    r.push(f);\n  }\n  return r;\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */\nconst proto3 = makeProtoRuntime(\"proto3\", fields => {\n  return new InternalFieldList(fields, source => normalizeFieldInfos(source));\n},\n// TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\ntarget => {\n  for (const member of target.getType().fields.byMember()) {\n    if (member.opt) {\n      continue;\n    }\n    const name = member.localName,\n      t = target;\n    if (member.repeated) {\n      t[name] = [];\n      continue;\n    }\n    switch (member.kind) {\n      case \"oneof\":\n        t[name] = {\n          case: undefined\n        };\n        break;\n      case \"enum\":\n        t[name] = 0;\n        break;\n      case \"map\":\n        t[name] = {};\n        break;\n      case \"scalar\":\n        t[name] = scalarZeroValue(member.T, member.L);\n        break;\n    }\n  }\n});\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */\nclass Timestamp extends Message {\n  constructor(data) {\n    super();\n    /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */\n    this.seconds = protoInt64.zero;\n    /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */\n    this.nanos = 0;\n    proto3.util.initPartial(data, this);\n  }\n  fromJson(json, options) {\n    if (typeof json !== \"string\") {\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n    }\n    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n    if (!matches) {\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n    }\n    const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n    if (Number.isNaN(ms)) {\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n    }\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n      throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n    }\n    this.seconds = protoInt64.parse(ms / 1000);\n    this.nanos = 0;\n    if (matches[7]) {\n      this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n    }\n    return this;\n  }\n  toJson(options) {\n    const ms = Number(this.seconds) * 1000;\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n    }\n    if (this.nanos < 0) {\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n    }\n    let z = \"Z\";\n    if (this.nanos > 0) {\n      const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n      if (nanosStr.substring(3) === \"000000\") {\n        z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n      } else if (nanosStr.substring(6) === \"000\") {\n        z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n      } else {\n        z = \".\" + nanosStr + \"Z\";\n      }\n    }\n    return new Date(ms).toISOString().replace(\".000Z\", z);\n  }\n  toDate() {\n    return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n  }\n  static now() {\n    return Timestamp.fromDate(new Date());\n  }\n  static fromDate(date) {\n    const ms = date.getTime();\n    return new Timestamp({\n      seconds: protoInt64.parse(Math.floor(ms / 1000)),\n      nanos: ms % 1000 * 1000000\n    });\n  }\n  static fromBinary(bytes, options) {\n    return new Timestamp().fromBinary(bytes, options);\n  }\n  static fromJson(jsonValue, options) {\n    return new Timestamp().fromJson(jsonValue, options);\n  }\n  static fromJsonString(jsonString, options) {\n    return new Timestamp().fromJsonString(jsonString, options);\n  }\n  static equals(a, b) {\n    return proto3.util.equals(Timestamp, a, b);\n  }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"seconds\",\n  kind: \"scalar\",\n  T: 3 /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"nanos\",\n  kind: \"scalar\",\n  T: 5 /* ScalarType.INT32 */\n}]);\n\nconst MetricsBatch = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricsBatch\", () => [{\n  no: 1,\n  name: \"timestamp_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"normalized_timestamp\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 3,\n  name: \"str_data\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 4,\n  name: \"time_series\",\n  kind: \"message\",\n  T: TimeSeriesMetric,\n  repeated: true\n}, {\n  no: 5,\n  name: \"events\",\n  kind: \"message\",\n  T: EventMetric,\n  repeated: true\n}]);\nconst TimeSeriesMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimeSeriesMetric\", () => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"samples\",\n  kind: \"message\",\n  T: MetricSample,\n  repeated: true\n}, {\n  no: 5,\n  name: \"rid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst MetricSample = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricSample\", () => [{\n  no: 1,\n  name: \"timestamp_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"normalized_timestamp\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 3,\n  name: \"value\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}]);\nconst EventMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.EventMetric\", () => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"start_timestamp_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 5,\n  name: \"end_timestamp_ms\",\n  kind: \"scalar\",\n  T: 3,\n  opt: true\n}, {\n  no: 6,\n  name: \"normalized_start_timestamp\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 7,\n  name: \"normalized_end_timestamp\",\n  kind: \"message\",\n  T: Timestamp,\n  opt: true\n}, {\n  no: 8,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"rid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst BackupCodecPolicy$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.BackupCodecPolicy\", [{\n  no: 0,\n  name: \"PREFER_REGRESSION\"\n}, {\n  no: 1,\n  name: \"SIMULCAST\"\n}, {\n  no: 2,\n  name: \"REGRESSION\"\n}]);\nconst TrackType = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackType\", [{\n  no: 0,\n  name: \"AUDIO\"\n}, {\n  no: 1,\n  name: \"VIDEO\"\n}, {\n  no: 2,\n  name: \"DATA\"\n}]);\nconst TrackSource = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackSource\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"CAMERA\"\n}, {\n  no: 2,\n  name: \"MICROPHONE\"\n}, {\n  no: 3,\n  name: \"SCREEN_SHARE\"\n}, {\n  no: 4,\n  name: \"SCREEN_SHARE_AUDIO\"\n}]);\nconst VideoQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.VideoQuality\", [{\n  no: 0,\n  name: \"LOW\"\n}, {\n  no: 1,\n  name: \"MEDIUM\"\n}, {\n  no: 2,\n  name: \"HIGH\"\n}, {\n  no: 3,\n  name: \"OFF\"\n}]);\nconst ConnectionQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.ConnectionQuality\", [{\n  no: 0,\n  name: \"POOR\"\n}, {\n  no: 1,\n  name: \"GOOD\"\n}, {\n  no: 2,\n  name: \"EXCELLENT\"\n}, {\n  no: 3,\n  name: \"LOST\"\n}]);\nconst ClientConfigSetting = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientConfigSetting\", [{\n  no: 0,\n  name: \"UNSET\"\n}, {\n  no: 1,\n  name: \"DISABLED\"\n}, {\n  no: 2,\n  name: \"ENABLED\"\n}]);\nconst DisconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.DisconnectReason\", [{\n  no: 0,\n  name: \"UNKNOWN_REASON\"\n}, {\n  no: 1,\n  name: \"CLIENT_INITIATED\"\n}, {\n  no: 2,\n  name: \"DUPLICATE_IDENTITY\"\n}, {\n  no: 3,\n  name: \"SERVER_SHUTDOWN\"\n}, {\n  no: 4,\n  name: \"PARTICIPANT_REMOVED\"\n}, {\n  no: 5,\n  name: \"ROOM_DELETED\"\n}, {\n  no: 6,\n  name: \"STATE_MISMATCH\"\n}, {\n  no: 7,\n  name: \"JOIN_FAILURE\"\n}, {\n  no: 8,\n  name: \"MIGRATION\"\n}, {\n  no: 9,\n  name: \"SIGNAL_CLOSE\"\n}, {\n  no: 10,\n  name: \"ROOM_CLOSED\"\n}, {\n  no: 11,\n  name: \"USER_UNAVAILABLE\"\n}, {\n  no: 12,\n  name: \"USER_REJECTED\"\n}, {\n  no: 13,\n  name: \"SIP_TRUNK_FAILURE\"\n}]);\nconst ReconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.ReconnectReason\", [{\n  no: 0,\n  name: \"RR_UNKNOWN\"\n}, {\n  no: 1,\n  name: \"RR_SIGNAL_DISCONNECTED\"\n}, {\n  no: 2,\n  name: \"RR_PUBLISHER_FAILED\"\n}, {\n  no: 3,\n  name: \"RR_SUBSCRIBER_FAILED\"\n}, {\n  no: 4,\n  name: \"RR_SWITCH_CANDIDATE\"\n}]);\nconst SubscriptionError = /* @__PURE__ */proto3.makeEnum(\"livekit.SubscriptionError\", [{\n  no: 0,\n  name: \"SE_UNKNOWN\"\n}, {\n  no: 1,\n  name: \"SE_CODEC_UNSUPPORTED\"\n}, {\n  no: 2,\n  name: \"SE_TRACK_NOTFOUND\"\n}]);\nconst AudioTrackFeature = /* @__PURE__ */proto3.makeEnum(\"livekit.AudioTrackFeature\", [{\n  no: 0,\n  name: \"TF_STEREO\"\n}, {\n  no: 1,\n  name: \"TF_NO_DTX\"\n}, {\n  no: 2,\n  name: \"TF_AUTO_GAIN_CONTROL\"\n}, {\n  no: 3,\n  name: \"TF_ECHO_CANCELLATION\"\n}, {\n  no: 4,\n  name: \"TF_NOISE_SUPPRESSION\"\n}, {\n  no: 5,\n  name: \"TF_ENHANCED_NOISE_CANCELLATION\"\n}]);\nconst Room$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.Room\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"empty_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 14,\n  name: \"departure_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"max_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"creation_time\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 15,\n  name: \"creation_time_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 6,\n  name: \"turn_password\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"enabled_codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}, {\n  no: 8,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"num_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"num_publishers\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 10,\n  name: \"active_recording\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 13,\n  name: \"version\",\n  kind: \"message\",\n  T: TimedVersion\n}]);\nconst Codec = /* @__PURE__ */proto3.makeMessageType(\"livekit.Codec\", () => [{\n  no: 1,\n  name: \"mime\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"fmtp_line\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ParticipantPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantPermission\", () => [{\n  no: 1,\n  name: \"can_subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"can_publish\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"can_publish_data\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 9,\n  name: \"can_publish_sources\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource),\n  repeated: true\n}, {\n  no: 7,\n  name: \"hidden\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"recorder\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 10,\n  name: \"can_update_metadata\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 11,\n  name: \"agent\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 12,\n  name: \"can_subscribe_metrics\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst ParticipantInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantInfo\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"state\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_State)\n}, {\n  no: 4,\n  name: \"tracks\",\n  kind: \"message\",\n  T: TrackInfo,\n  repeated: true\n}, {\n  no: 5,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"joined_at\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 17,\n  name: \"joined_at_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 9,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"permission\",\n  kind: \"message\",\n  T: ParticipantPermission\n}, {\n  no: 12,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"is_publisher\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 14,\n  name: \"kind\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_Kind)\n}, {\n  no: 15,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 16,\n  name: \"disconnect_reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DisconnectReason)\n}, {\n  no: 18,\n  name: \"kind_details\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_KindDetail),\n  repeated: true\n}]);\nconst ParticipantInfo_State = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.State\", [{\n  no: 0,\n  name: \"JOINING\"\n}, {\n  no: 1,\n  name: \"JOINED\"\n}, {\n  no: 2,\n  name: \"ACTIVE\"\n}, {\n  no: 3,\n  name: \"DISCONNECTED\"\n}]);\nconst ParticipantInfo_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [{\n  no: 0,\n  name: \"STANDARD\"\n}, {\n  no: 1,\n  name: \"INGRESS\"\n}, {\n  no: 2,\n  name: \"EGRESS\"\n}, {\n  no: 3,\n  name: \"SIP\"\n}, {\n  no: 4,\n  name: \"AGENT\"\n}]);\nconst ParticipantInfo_KindDetail = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [{\n  no: 0,\n  name: \"CLOUD_AGENT\"\n}, {\n  no: 1,\n  name: \"FORWARDED\"\n}]);\nconst Encryption_Type = /* @__PURE__ */proto3.makeEnum(\"livekit.Encryption.Type\", [{\n  no: 0,\n  name: \"NONE\"\n}, {\n  no: 1,\n  name: \"GCM\"\n}, {\n  no: 2,\n  name: \"CUSTOM\"\n}]);\nconst SimulcastCodecInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", () => [{\n  no: 1,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"mid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}]);\nconst TrackInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackInfo\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackType)\n}, {\n  no: 3,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 5,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 7,\n  name: \"simulcast\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"disable_dtx\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 9,\n  name: \"source\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource)\n}, {\n  no: 10,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}, {\n  no: 11,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"mid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"codecs\",\n  kind: \"message\",\n  T: SimulcastCodecInfo,\n  repeated: true\n}, {\n  no: 14,\n  name: \"stereo\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 15,\n  name: \"disable_red\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 16,\n  name: \"encryption\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 17,\n  name: \"stream\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 18,\n  name: \"version\",\n  kind: \"message\",\n  T: TimedVersion\n}, {\n  no: 19,\n  name: \"audio_features\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioTrackFeature),\n  repeated: true\n}, {\n  no: 20,\n  name: \"backup_codec_policy\",\n  kind: \"enum\",\n  T: proto3.getEnumType(BackupCodecPolicy$1)\n}]);\nconst VideoLayer = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoLayer\", () => [{\n  no: 1,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 2,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"bitrate\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"ssrc\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst DataPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataPacket\", () => [{\n  no: 1,\n  name: \"kind\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DataPacket_Kind)\n}, {\n  no: 4,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"destination_identities\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"user\",\n  kind: \"message\",\n  T: UserPacket,\n  oneof: \"value\"\n}, {\n  no: 3,\n  name: \"speaker\",\n  kind: \"message\",\n  T: ActiveSpeakerUpdate,\n  oneof: \"value\"\n}, {\n  no: 6,\n  name: \"sip_dtmf\",\n  kind: \"message\",\n  T: SipDTMF,\n  oneof: \"value\"\n}, {\n  no: 7,\n  name: \"transcription\",\n  kind: \"message\",\n  T: Transcription,\n  oneof: \"value\"\n}, {\n  no: 8,\n  name: \"metrics\",\n  kind: \"message\",\n  T: MetricsBatch,\n  oneof: \"value\"\n}, {\n  no: 9,\n  name: \"chat_message\",\n  kind: \"message\",\n  T: ChatMessage,\n  oneof: \"value\"\n}, {\n  no: 10,\n  name: \"rpc_request\",\n  kind: \"message\",\n  T: RpcRequest,\n  oneof: \"value\"\n}, {\n  no: 11,\n  name: \"rpc_ack\",\n  kind: \"message\",\n  T: RpcAck,\n  oneof: \"value\"\n}, {\n  no: 12,\n  name: \"rpc_response\",\n  kind: \"message\",\n  T: RpcResponse,\n  oneof: \"value\"\n}, {\n  no: 13,\n  name: \"stream_header\",\n  kind: \"message\",\n  T: DataStream_Header,\n  oneof: \"value\"\n}, {\n  no: 14,\n  name: \"stream_chunk\",\n  kind: \"message\",\n  T: DataStream_Chunk,\n  oneof: \"value\"\n}, {\n  no: 15,\n  name: \"stream_trailer\",\n  kind: \"message\",\n  T: DataStream_Trailer,\n  oneof: \"value\"\n}]);\nconst DataPacket_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.DataPacket.Kind\", [{\n  no: 0,\n  name: \"RELIABLE\"\n}, {\n  no: 1,\n  name: \"LOSSY\"\n}]);\nconst ActiveSpeakerUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", () => [{\n  no: 1,\n  name: \"speakers\",\n  kind: \"message\",\n  T: SpeakerInfo,\n  repeated: true\n}]);\nconst SpeakerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakerInfo\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"level\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}, {\n  no: 3,\n  name: \"active\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst UserPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.UserPacket\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 3,\n  name: \"destination_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 6,\n  name: \"destination_identities\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 4,\n  name: \"topic\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 8,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 9,\n  name: \"start_time\",\n  kind: \"scalar\",\n  T: 4,\n  opt: true\n}, {\n  no: 10,\n  name: \"end_time\",\n  kind: \"scalar\",\n  T: 4,\n  opt: true\n}, {\n  no: 11,\n  name: \"nonce\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}]);\nconst SipDTMF = /* @__PURE__ */proto3.makeMessageType(\"livekit.SipDTMF\", () => [{\n  no: 3,\n  name: \"code\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"digit\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst Transcription = /* @__PURE__ */proto3.makeMessageType(\"livekit.Transcription\", () => [{\n  no: 2,\n  name: \"transcribed_participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"track_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"segments\",\n  kind: \"message\",\n  T: TranscriptionSegment,\n  repeated: true\n}]);\nconst TranscriptionSegment = /* @__PURE__ */proto3.makeMessageType(\"livekit.TranscriptionSegment\", () => [{\n  no: 1,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"text\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"start_time\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 4,\n  name: \"end_time\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 5,\n  name: \"final\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 6,\n  name: \"language\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ChatMessage = /* @__PURE__ */proto3.makeMessageType(\"livekit.ChatMessage\", () => [{\n  no: 1,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 3,\n  name: \"edit_timestamp\",\n  kind: \"scalar\",\n  T: 3,\n  opt: true\n}, {\n  no: 4,\n  name: \"message\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"deleted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 6,\n  name: \"generated\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst RpcRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcRequest\", () => [{\n  no: 1,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"method\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"response_timeout_ms\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst RpcAck = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcAck\", () => [{\n  no: 1,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst RpcResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcResponse\", () => [{\n  no: 1,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 9,\n  oneof: \"value\"\n}, {\n  no: 3,\n  name: \"error\",\n  kind: \"message\",\n  T: RpcError$1,\n  oneof: \"value\"\n}]);\nconst RpcError$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcError\", () => [{\n  no: 1,\n  name: \"code\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"message\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"data\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ParticipantTracks = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantTracks\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}]);\nconst ServerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ServerInfo\", () => [{\n  no: 1,\n  name: \"edition\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ServerInfo_Edition)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"node_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"debug_info\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"agent_protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}]);\nconst ServerInfo_Edition = /* @__PURE__ */proto3.makeEnum(\"livekit.ServerInfo.Edition\", [{\n  no: 0,\n  name: \"Standard\"\n}, {\n  no: 1,\n  name: \"Cloud\"\n}]);\nconst ClientInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientInfo\", () => [{\n  no: 1,\n  name: \"sdk\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientInfo_SDK)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"os\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"os_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"device_model\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"browser\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 8,\n  name: \"browser_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"address\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"network\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 11,\n  name: \"other_sdks\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ClientInfo_SDK = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientInfo.SDK\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"JS\"\n}, {\n  no: 2,\n  name: \"SWIFT\"\n}, {\n  no: 3,\n  name: \"ANDROID\"\n}, {\n  no: 4,\n  name: \"FLUTTER\"\n}, {\n  no: 5,\n  name: \"GO\"\n}, {\n  no: 6,\n  name: \"UNITY\"\n}, {\n  no: 7,\n  name: \"REACT_NATIVE\"\n}, {\n  no: 8,\n  name: \"RUST\"\n}, {\n  no: 9,\n  name: \"PYTHON\"\n}, {\n  no: 10,\n  name: \"CPP\"\n}, {\n  no: 11,\n  name: \"UNITY_WEB\"\n}, {\n  no: 12,\n  name: \"NODE\"\n}]);\nconst ClientConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientConfiguration\", () => [{\n  no: 1,\n  name: \"video\",\n  kind: \"message\",\n  T: VideoConfiguration\n}, {\n  no: 2,\n  name: \"screen\",\n  kind: \"message\",\n  T: VideoConfiguration\n}, {\n  no: 3,\n  name: \"resume_connection\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}, {\n  no: 4,\n  name: \"disabled_codecs\",\n  kind: \"message\",\n  T: DisabledCodecs\n}, {\n  no: 5,\n  name: \"force_relay\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}]);\nconst VideoConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoConfiguration\", () => [{\n  no: 1,\n  name: \"hardware_encoder\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}]);\nconst DisabledCodecs = /* @__PURE__ */proto3.makeMessageType(\"livekit.DisabledCodecs\", () => [{\n  no: 1,\n  name: \"codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}, {\n  no: 2,\n  name: \"publish\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}]);\nconst TimedVersion = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimedVersion\", () => [{\n  no: 1,\n  name: \"unix_micro\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"ticks\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}]);\nconst DataStream_OperationType = /* @__PURE__ */proto3.makeEnum(\"livekit.DataStream.OperationType\", [{\n  no: 0,\n  name: \"CREATE\"\n}, {\n  no: 1,\n  name: \"UPDATE\"\n}, {\n  no: 2,\n  name: \"DELETE\"\n}, {\n  no: 3,\n  name: \"REACTION\"\n}]);\nconst DataStream_TextHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.TextHeader\", () => [{\n  no: 1,\n  name: \"operation_type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DataStream_OperationType)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 3,\n  name: \"reply_to_stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"attached_stream_ids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 5,\n  name: \"generated\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}], {\n  localName: \"DataStream_TextHeader\"\n});\nconst DataStream_ByteHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", () => [{\n  no: 1,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}], {\n  localName: \"DataStream_ByteHeader\"\n});\nconst DataStream_Header = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Header\", () => [{\n  no: 1,\n  name: \"stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 3,\n  name: \"topic\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"total_length\",\n  kind: \"scalar\",\n  T: 4,\n  opt: true\n}, {\n  no: 7,\n  name: \"encryption_type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 8,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 9,\n  name: \"text_header\",\n  kind: \"message\",\n  T: DataStream_TextHeader,\n  oneof: \"content_header\"\n}, {\n  no: 10,\n  name: \"byte_header\",\n  kind: \"message\",\n  T: DataStream_ByteHeader,\n  oneof: \"content_header\"\n}], {\n  localName: \"DataStream_Header\"\n});\nconst DataStream_Chunk = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Chunk\", () => [{\n  no: 1,\n  name: \"stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"chunk_index\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 3,\n  name: \"content\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 4,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 5,\n  name: \"iv\",\n  kind: \"scalar\",\n  T: 12,\n  opt: true\n}], {\n  localName: \"DataStream_Chunk\"\n});\nconst DataStream_Trailer = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Trailer\", () => [{\n  no: 1,\n  name: \"stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}], {\n  localName: \"DataStream_Trailer\"\n});\nconst SignalTarget = /* @__PURE__ */proto3.makeEnum(\"livekit.SignalTarget\", [{\n  no: 0,\n  name: \"PUBLISHER\"\n}, {\n  no: 1,\n  name: \"SUBSCRIBER\"\n}]);\nconst StreamState = /* @__PURE__ */proto3.makeEnum(\"livekit.StreamState\", [{\n  no: 0,\n  name: \"ACTIVE\"\n}, {\n  no: 1,\n  name: \"PAUSED\"\n}]);\nconst CandidateProtocol = /* @__PURE__ */proto3.makeEnum(\"livekit.CandidateProtocol\", [{\n  no: 0,\n  name: \"UDP\"\n}, {\n  no: 1,\n  name: \"TCP\"\n}, {\n  no: 2,\n  name: \"TLS\"\n}]);\nconst SignalRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalRequest\", () => [{\n  no: 1,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 2,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 3,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"message\"\n}, {\n  no: 4,\n  name: \"add_track\",\n  kind: \"message\",\n  T: AddTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 5,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 6,\n  name: \"subscription\",\n  kind: \"message\",\n  T: UpdateSubscription,\n  oneof: \"message\"\n}, {\n  no: 7,\n  name: \"track_setting\",\n  kind: \"message\",\n  T: UpdateTrackSettings,\n  oneof: \"message\"\n}, {\n  no: 8,\n  name: \"leave\",\n  kind: \"message\",\n  T: LeaveRequest,\n  oneof: \"message\"\n}, {\n  no: 10,\n  name: \"update_layers\",\n  kind: \"message\",\n  T: UpdateVideoLayers,\n  oneof: \"message\"\n}, {\n  no: 11,\n  name: \"subscription_permission\",\n  kind: \"message\",\n  T: SubscriptionPermission,\n  oneof: \"message\"\n}, {\n  no: 12,\n  name: \"sync_state\",\n  kind: \"message\",\n  T: SyncState,\n  oneof: \"message\"\n}, {\n  no: 13,\n  name: \"simulate\",\n  kind: \"message\",\n  T: SimulateScenario,\n  oneof: \"message\"\n}, {\n  no: 14,\n  name: \"ping\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"message\"\n}, {\n  no: 15,\n  name: \"update_metadata\",\n  kind: \"message\",\n  T: UpdateParticipantMetadata,\n  oneof: \"message\"\n}, {\n  no: 16,\n  name: \"ping_req\",\n  kind: \"message\",\n  T: Ping,\n  oneof: \"message\"\n}, {\n  no: 17,\n  name: \"update_audio_track\",\n  kind: \"message\",\n  T: UpdateLocalAudioTrack,\n  oneof: \"message\"\n}, {\n  no: 18,\n  name: \"update_video_track\",\n  kind: \"message\",\n  T: UpdateLocalVideoTrack,\n  oneof: \"message\"\n}]);\nconst SignalResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalResponse\", () => [{\n  no: 1,\n  name: \"join\",\n  kind: \"message\",\n  T: JoinResponse,\n  oneof: \"message\"\n}, {\n  no: 2,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 3,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 4,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"message\"\n}, {\n  no: 5,\n  name: \"update\",\n  kind: \"message\",\n  T: ParticipantUpdate,\n  oneof: \"message\"\n}, {\n  no: 6,\n  name: \"track_published\",\n  kind: \"message\",\n  T: TrackPublishedResponse,\n  oneof: \"message\"\n}, {\n  no: 8,\n  name: \"leave\",\n  kind: \"message\",\n  T: LeaveRequest,\n  oneof: \"message\"\n}, {\n  no: 9,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 10,\n  name: \"speakers_changed\",\n  kind: \"message\",\n  T: SpeakersChanged,\n  oneof: \"message\"\n}, {\n  no: 11,\n  name: \"room_update\",\n  kind: \"message\",\n  T: RoomUpdate,\n  oneof: \"message\"\n}, {\n  no: 12,\n  name: \"connection_quality\",\n  kind: \"message\",\n  T: ConnectionQualityUpdate,\n  oneof: \"message\"\n}, {\n  no: 13,\n  name: \"stream_state_update\",\n  kind: \"message\",\n  T: StreamStateUpdate,\n  oneof: \"message\"\n}, {\n  no: 14,\n  name: \"subscribed_quality_update\",\n  kind: \"message\",\n  T: SubscribedQualityUpdate,\n  oneof: \"message\"\n}, {\n  no: 15,\n  name: \"subscription_permission_update\",\n  kind: \"message\",\n  T: SubscriptionPermissionUpdate,\n  oneof: \"message\"\n}, {\n  no: 16,\n  name: \"refresh_token\",\n  kind: \"scalar\",\n  T: 9,\n  oneof: \"message\"\n}, {\n  no: 17,\n  name: \"track_unpublished\",\n  kind: \"message\",\n  T: TrackUnpublishedResponse,\n  oneof: \"message\"\n}, {\n  no: 18,\n  name: \"pong\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"message\"\n}, {\n  no: 19,\n  name: \"reconnect\",\n  kind: \"message\",\n  T: ReconnectResponse,\n  oneof: \"message\"\n}, {\n  no: 20,\n  name: \"pong_resp\",\n  kind: \"message\",\n  T: Pong,\n  oneof: \"message\"\n}, {\n  no: 21,\n  name: \"subscription_response\",\n  kind: \"message\",\n  T: SubscriptionResponse,\n  oneof: \"message\"\n}, {\n  no: 22,\n  name: \"request_response\",\n  kind: \"message\",\n  T: RequestResponse,\n  oneof: \"message\"\n}, {\n  no: 23,\n  name: \"track_subscribed\",\n  kind: \"message\",\n  T: TrackSubscribed,\n  oneof: \"message\"\n}]);\nconst SimulcastCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodec\", () => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst AddTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.AddTrackRequest\", () => [{\n  no: 1,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackType)\n}, {\n  no: 4,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"disable_dtx\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"source\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource)\n}, {\n  no: 9,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}, {\n  no: 10,\n  name: \"simulcast_codecs\",\n  kind: \"message\",\n  T: SimulcastCodec,\n  repeated: true\n}, {\n  no: 11,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"stereo\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 13,\n  name: \"disable_red\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 14,\n  name: \"encryption\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 15,\n  name: \"stream\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 16,\n  name: \"backup_codec_policy\",\n  kind: \"enum\",\n  T: proto3.getEnumType(BackupCodecPolicy$1)\n}]);\nconst TrickleRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrickleRequest\", () => [{\n  no: 1,\n  name: \"candidateInit\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"target\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SignalTarget)\n}, {\n  no: 3,\n  name: \"final\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst MuteTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.MuteTrackRequest\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst JoinResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.JoinResponse\", () => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}, {\n  no: 2,\n  name: \"participant\",\n  kind: \"message\",\n  T: ParticipantInfo\n}, {\n  no: 3,\n  name: \"other_participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: true\n}, {\n  no: 4,\n  name: \"server_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"ice_servers\",\n  kind: \"message\",\n  T: ICEServer,\n  repeated: true\n}, {\n  no: 6,\n  name: \"subscriber_primary\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"alternative_url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 8,\n  name: \"client_configuration\",\n  kind: \"message\",\n  T: ClientConfiguration\n}, {\n  no: 9,\n  name: \"server_region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"ping_timeout\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 11,\n  name: \"ping_interval\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 12,\n  name: \"server_info\",\n  kind: \"message\",\n  T: ServerInfo\n}, {\n  no: 13,\n  name: \"sif_trailer\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 14,\n  name: \"enabled_publish_codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}, {\n  no: 15,\n  name: \"fast_publish\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst ReconnectResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.ReconnectResponse\", () => [{\n  no: 1,\n  name: \"ice_servers\",\n  kind: \"message\",\n  T: ICEServer,\n  repeated: true\n}, {\n  no: 2,\n  name: \"client_configuration\",\n  kind: \"message\",\n  T: ClientConfiguration\n}]);\nconst TrackPublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPublishedResponse\", () => [{\n  no: 1,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track\",\n  kind: \"message\",\n  T: TrackInfo\n}]);\nconst TrackUnpublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst SessionDescription = /* @__PURE__ */proto3.makeMessageType(\"livekit.SessionDescription\", () => [{\n  no: 1,\n  name: \"type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"sdp\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ParticipantUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantUpdate\", () => [{\n  no: 1,\n  name: \"participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: true\n}]);\nconst UpdateSubscription = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateSubscription\", () => [{\n  no: 1,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"participant_tracks\",\n  kind: \"message\",\n  T: ParticipantTracks,\n  repeated: true\n}]);\nconst UpdateTrackSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateTrackSettings\", () => [{\n  no: 1,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 3,\n  name: \"disabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 4,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 5,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 7,\n  name: \"fps\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 8,\n  name: \"priority\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst UpdateLocalAudioTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"features\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioTrackFeature),\n  repeated: true\n}]);\nconst UpdateLocalVideoTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst LeaveRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.LeaveRequest\", () => [{\n  no: 1,\n  name: \"can_reconnect\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DisconnectReason)\n}, {\n  no: 3,\n  name: \"action\",\n  kind: \"enum\",\n  T: proto3.getEnumType(LeaveRequest_Action)\n}, {\n  no: 4,\n  name: \"regions\",\n  kind: \"message\",\n  T: RegionSettings\n}]);\nconst LeaveRequest_Action = /* @__PURE__ */proto3.makeEnum(\"livekit.LeaveRequest.Action\", [{\n  no: 0,\n  name: \"DISCONNECT\"\n}, {\n  no: 1,\n  name: \"RESUME\"\n}, {\n  no: 2,\n  name: \"RECONNECT\"\n}]);\nconst UpdateVideoLayers = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateVideoLayers\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}]);\nconst UpdateParticipantMetadata = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", () => [{\n  no: 1,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 4,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst ICEServer = /* @__PURE__ */proto3.makeMessageType(\"livekit.ICEServer\", () => [{\n  no: 1,\n  name: \"urls\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"username\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"credential\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst SpeakersChanged = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakersChanged\", () => [{\n  no: 1,\n  name: \"speakers\",\n  kind: \"message\",\n  T: SpeakerInfo,\n  repeated: true\n}]);\nconst RoomUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomUpdate\", () => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}]);\nconst ConnectionQualityInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ConnectionQuality$1)\n}, {\n  no: 3,\n  name: \"score\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}]);\nconst ConnectionQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", () => [{\n  no: 1,\n  name: \"updates\",\n  kind: \"message\",\n  T: ConnectionQualityInfo,\n  repeated: true\n}]);\nconst StreamStateInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateInfo\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"state\",\n  kind: \"enum\",\n  T: proto3.getEnumType(StreamState)\n}]);\nconst StreamStateUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateUpdate\", () => [{\n  no: 1,\n  name: \"stream_states\",\n  kind: \"message\",\n  T: StreamStateInfo,\n  repeated: true\n}]);\nconst SubscribedQuality = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQuality\", () => [{\n  no: 1,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 2,\n  name: \"enabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst SubscribedCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedCodec\", () => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"qualities\",\n  kind: \"message\",\n  T: SubscribedQuality,\n  repeated: true\n}]);\nconst SubscribedQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"subscribed_qualities\",\n  kind: \"message\",\n  T: SubscribedQuality,\n  repeated: true\n}, {\n  no: 3,\n  name: \"subscribed_codecs\",\n  kind: \"message\",\n  T: SubscribedCodec,\n  repeated: true\n}]);\nconst TrackPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPermission\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"all_tracks\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 4,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst SubscriptionPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermission\", () => [{\n  no: 1,\n  name: \"all_participants\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"track_permissions\",\n  kind: \"message\",\n  T: TrackPermission,\n  repeated: true\n}]);\nconst SubscriptionPermissionUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"allowed\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst SyncState = /* @__PURE__ */proto3.makeMessageType(\"livekit.SyncState\", () => [{\n  no: 1,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 2,\n  name: \"subscription\",\n  kind: \"message\",\n  T: UpdateSubscription\n}, {\n  no: 3,\n  name: \"publish_tracks\",\n  kind: \"message\",\n  T: TrackPublishedResponse,\n  repeated: true\n}, {\n  no: 4,\n  name: \"data_channels\",\n  kind: \"message\",\n  T: DataChannelInfo,\n  repeated: true\n}, {\n  no: 5,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 6,\n  name: \"track_sids_disabled\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}]);\nconst DataChannelInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelInfo\", () => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"target\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SignalTarget)\n}]);\nconst SimulateScenario = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulateScenario\", () => [{\n  no: 1,\n  name: \"speaker_update\",\n  kind: \"scalar\",\n  T: 5,\n  oneof: \"scenario\"\n}, {\n  no: 2,\n  name: \"node_failure\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 3,\n  name: \"migration\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 4,\n  name: \"server_leave\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 5,\n  name: \"switch_candidate_protocol\",\n  kind: \"enum\",\n  T: proto3.getEnumType(CandidateProtocol),\n  oneof: \"scenario\"\n}, {\n  no: 6,\n  name: \"subscriber_bandwidth\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"scenario\"\n}, {\n  no: 7,\n  name: \"disconnect_signal_on_resume\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 8,\n  name: \"disconnect_signal_on_resume_no_messages\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 9,\n  name: \"leave_request_full_reconnect\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}]);\nconst Ping = /* @__PURE__ */proto3.makeMessageType(\"livekit.Ping\", () => [{\n  no: 1,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"rtt\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nconst Pong = /* @__PURE__ */proto3.makeMessageType(\"livekit.Pong\", () => [{\n  no: 1,\n  name: \"last_ping_timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nconst RegionSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionSettings\", () => [{\n  no: 1,\n  name: \"regions\",\n  kind: \"message\",\n  T: RegionInfo,\n  repeated: true\n}]);\nconst RegionInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionInfo\", () => [{\n  no: 1,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"distance\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nconst SubscriptionResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionResponse\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"err\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SubscriptionError)\n}]);\nconst RequestResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RequestResponse\", () => [{\n  no: 1,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(RequestResponse_Reason)\n}, {\n  no: 3,\n  name: \"message\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst RequestResponse_Reason = /* @__PURE__ */proto3.makeEnum(\"livekit.RequestResponse.Reason\", [{\n  no: 0,\n  name: \"OK\"\n}, {\n  no: 1,\n  name: \"NOT_FOUND\"\n}, {\n  no: 2,\n  name: \"NOT_ALLOWED\"\n}, {\n  no: 3,\n  name: \"LIMIT_EXCEEDED\"\n}]);\nconst TrackSubscribed = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackSubscribed\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar loglevel$1 = {exports: {}};\n\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\nvar loglevel = loglevel$1.exports;\nvar hasRequiredLoglevel;\nfunction requireLoglevel() {\n  if (hasRequiredLoglevel) return loglevel$1.exports;\n  hasRequiredLoglevel = 1;\n  (function (module) {\n    (function (root, definition) {\n\n      if (module.exports) {\n        module.exports = definition();\n      } else {\n        root.log = definition();\n      }\n    })(loglevel, function () {\n\n      // Slightly dubious tricks to cut down minimized file size\n      var noop = function () {};\n      var undefinedType = \"undefined\";\n      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n      var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n      var _loggersByName = {};\n      var defaultLogger = null;\n\n      // Cross-browser bind equivalent that works at least back to IE6\n      function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n          return method.bind(obj);\n        } else {\n          try {\n            return Function.prototype.bind.call(method, obj);\n          } catch (e) {\n            // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n            return function () {\n              return Function.prototype.apply.apply(method, [obj, arguments]);\n            };\n          }\n        }\n      }\n\n      // Trace() doesn't print the message in IE, so for that case we need to wrap it\n      function traceForIE() {\n        if (console.log) {\n          if (console.log.apply) {\n            console.log.apply(console, arguments);\n          } else {\n            // In old IE, native console methods themselves don't have apply().\n            Function.prototype.apply.apply(console.log, [console, arguments]);\n          }\n        }\n        if (console.trace) console.trace();\n      }\n\n      // Build the best logging method possible for this env\n      // Wherever possible we want to bind, not wrap, to preserve stack traces\n      function realMethod(methodName) {\n        if (methodName === 'debug') {\n          methodName = 'log';\n        }\n        if (typeof console === undefinedType) {\n          return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n          return traceForIE;\n        } else if (console[methodName] !== undefined) {\n          return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n          return bindMethod(console, 'log');\n        } else {\n          return noop;\n        }\n      }\n\n      // These private functions always need `this` to be set properly\n\n      function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n          var methodName = logMethods[i];\n          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n          return \"No console available for logging\";\n        }\n      }\n\n      // In old IE versions, the console isn't present until you first open it.\n      // We build realMethod() replacements here that regenerate logging methods\n      function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n          if (typeof console !== undefinedType) {\n            replaceLoggingMethods.call(this);\n            this[methodName].apply(this, arguments);\n          }\n        };\n      }\n\n      // By default, we use closely bound real methods wherever possible, and\n      // otherwise we wait for a console to appear, and then try again.\n      function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n      }\n      function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n         * The level inherited from a parent logger (or a global default). We\n         * cache this here rather than delegating to the parent so that it stays\n         * in sync with the actual logging methods that we have installed (the\n         * parent could change levels but we might not have rebuilt the loggers\n         * in this child yet).\n         * @type {number}\n         */\n        var inheritedLevel;\n        /**\n         * The default level for this logger, if any. If set, this overrides\n         * `inheritedLevel`.\n         * @type {number|null}\n         */\n        var defaultLevel;\n        /**\n         * A user-specific level for this logger. If set, this overrides\n         * `defaultLevel`.\n         * @type {number|null}\n         */\n        var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n          storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n          storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n            window.localStorage[storageKey] = levelName;\n            return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n            window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n          var storedLevel;\n          if (typeof window === undefinedType || !storageKey) return;\n          try {\n            storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n            try {\n              var cookie = window.document.cookie;\n              var cookieName = encodeURIComponent(storageKey);\n              var location = cookie.indexOf(cookieName + \"=\");\n              if (location !== -1) {\n                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n              }\n            } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n            storedLevel = undefined;\n          }\n          return storedLevel;\n        }\n        function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n            window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n            window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n            level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n            return level;\n          } else {\n            throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n        }\n\n        /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */\n\n        self.name = name;\n        self.levels = {\n          \"TRACE\": 0,\n          \"DEBUG\": 1,\n          \"INFO\": 2,\n          \"WARN\": 3,\n          \"ERROR\": 4,\n          \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n        };\n        self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {\n            // defaults to true\n            persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n            self.setLevel(level, false);\n          }\n        };\n        self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function (persist) {\n          self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function (persist) {\n          self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function () {\n          if (defaultLogger !== self) {\n            inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n          if (defaultLogger === self) {\n            for (var childName in _loggersByName) {\n              _loggersByName[childName].rebuild();\n            }\n          }\n        };\n\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n      }\n\n      /*\n       *\n       * Top-level API\n       *\n       */\n\n      defaultLogger = new Logger();\n      defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n      };\n\n      // Grab the current global log variable in case of overwrite\n      var _log = typeof window !== undefinedType ? window.log : undefined;\n      defaultLogger.noConflict = function () {\n        if (typeof window !== undefinedType && window.log === defaultLogger) {\n          window.log = _log;\n        }\n        return defaultLogger;\n      };\n      defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n      };\n\n      // ES6 default export, for compatibility\n      defaultLogger['default'] = defaultLogger;\n      return defaultLogger;\n    });\n  })(loglevel$1);\n  return loglevel$1.exports;\n}\n\nvar loglevelExports = requireLoglevel();\n\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n  LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n  LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n  LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n  LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n  LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function (LoggerNames) {\n  LoggerNames[\"Default\"] = \"livekit\";\n  LoggerNames[\"Room\"] = \"livekit-room\";\n  LoggerNames[\"Participant\"] = \"livekit-participant\";\n  LoggerNames[\"Track\"] = \"livekit-track\";\n  LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n  LoggerNames[\"Engine\"] = \"livekit-engine\";\n  LoggerNames[\"Signal\"] = \"livekit-signal\";\n  LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n  LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n  LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger('livekit');\nconst livekitLoggers = Object.values(LoggerNames).map(name => loglevelExports.getLogger(name));\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */\nfunction getLogger(name) {\n  const logger = loglevelExports.getLogger(name);\n  logger.setDefaultLevel(livekitLogger.getLevel());\n  return logger;\n}\nfunction setLogLevel(level, loggerName) {\n  if (loggerName) {\n    loglevelExports.getLogger(loggerName).setLevel(level);\n  } else {\n    for (const logger of livekitLoggers) {\n      logger.setLevel(level);\n    }\n  }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */\nfunction setLogExtension(extension, logger) {\n  const loggers = logger ? [logger] : livekitLoggers;\n  loggers.forEach(logR => {\n    const originalFactory = logR.methodFactory;\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\n      const logLevel = LogLevel[methodName];\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n      return (msg, context) => {\n        if (context) rawMethod(msg, context);else rawMethod(msg);\n        if (needLog) {\n          extension(logLevel, msg, context);\n        }\n      };\n    };\n    logR.setLevel(logR.getLevel());\n  });\n}\nconst workerLogger = loglevelExports.getLogger('lk-e2ee');\n\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\nclass DefaultReconnectPolicy {\n  constructor(retryDelays) {\n    this._retryDelays = retryDelays !== undefined ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;\n  }\n  nextRetryDelayInMs(context) {\n    if (context.retryCount >= this._retryDelays.length) return null;\n    const retryDelay = this._retryDelays[context.retryCount];\n    if (context.retryCount <= 1) return retryDelay;\n    return retryDelay + Math.random() * 1000;\n  }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar events = {exports: {}};\n\nvar hasRequiredEvents;\nfunction requireEvents() {\n  if (hasRequiredEvents) return events.exports;\n  hasRequiredEvents = 1;\n  var R = typeof Reflect === 'object' ? Reflect : null;\n  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n  var ReflectOwnKeys;\n  if (R && typeof R.ownKeys === 'function') {\n    ReflectOwnKeys = R.ownKeys;\n  } else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n  } else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target);\n    };\n  }\n  function ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n  }\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n  };\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n  events.exports = EventEmitter;\n  events.exports.once = once;\n\n  // Backwards-compat with node 0.10.x\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._eventsCount = 0;\n  EventEmitter.prototype._maxListeners = undefined;\n\n  // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n  var defaultMaxListeners = 10;\n  function checkListener(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n  }\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function () {\n      return defaultMaxListeners;\n    },\n    set: function (arg) {\n      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n      }\n      defaultMaxListeners = arg;\n    }\n  });\n  EventEmitter.init = function () {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n  };\n\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    }\n    this._maxListeners = n;\n    return this;\n  };\n  function _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n  };\n  EventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n      var er;\n      if (args.length > 0) er = args[0];\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') {\n      ReflectApply(handler, this, args);\n    } else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n    }\n    return true;\n  };\n  function _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n      events = target._events = Object.create(null);\n      target._eventsCount = 0;\n    } else {\n      // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n      if (events.newListener !== undefined) {\n        target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n        // Re-assign `events` because a newListener handler could have caused the\n        // this._events to be assigned to a new object\n        events = target._events;\n      }\n      existing = events[type];\n    }\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      existing = events[type] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n\n      // Check for listener leak\n      m = _getMaxListeners(target);\n      if (m > 0 && existing.length > m && !existing.warned) {\n        existing.warned = true;\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        ProcessEmitWarning(w);\n      }\n    }\n    return target;\n  }\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  };\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  };\n  function onceWrapper() {\n    if (!this.fired) {\n      this.target.removeListener(this.type, this.wrapFn);\n      this.fired = true;\n      if (arguments.length === 0) return this.listener.call(this.target);\n      return this.listener.apply(this.target, arguments);\n    }\n  }\n  function _onceWrap(target, type, listener) {\n    var state = {\n      fired: false,\n      wrapFn: undefined,\n      target: target,\n      type: type,\n      listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n  }\n  EventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n  };\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  };\n\n  // Emits a 'removeListener' event if and only if the listener was removed.\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else {\n        delete events[type];\n        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n      }\n    } else if (typeof list !== 'function') {\n      position = -1;\n      for (i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener || list[i].listener === listener) {\n          originalListener = list[i].listener;\n          position = i;\n          break;\n        }\n      }\n      if (position < 0) return this;\n      if (position === 0) list.shift();else {\n        spliceOne(list, position);\n      }\n      if (list.length === 1) events[type] = list[0];\n      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n      if (arguments.length === 0) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n      } else if (events[type] !== undefined) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n      }\n      return this;\n    }\n\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n      var keys = Object.keys(events);\n      var key;\n      for (i = 0; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === 'removeListener') continue;\n        this.removeAllListeners(key);\n      }\n      this.removeAllListeners('removeListener');\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n      return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') {\n      this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n      // LIFO order\n      for (i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n    return this;\n  };\n  function _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n  }\n  EventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n  };\n  EventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n  };\n  EventEmitter.listenerCount = function (emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n      return emitter.listenerCount(type);\n    } else {\n      return listenerCount.call(emitter, type);\n    }\n  };\n  EventEmitter.prototype.listenerCount = listenerCount;\n  function listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n      var evlistener = events[type];\n      if (typeof evlistener === 'function') {\n        return 1;\n      } else if (evlistener !== undefined) {\n        return evlistener.length;\n      }\n    }\n    return 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n  };\n  function arrayClone(arr, n) {\n    var copy = new Array(n);\n    for (var i = 0; i < n; ++i) copy[i] = arr[i];\n    return copy;\n  }\n  function spliceOne(list, index) {\n    for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n    list.pop();\n  }\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n  }\n  function once(emitter, name) {\n    return new Promise(function (resolve, reject) {\n      function errorListener(err) {\n        emitter.removeListener(name, resolver);\n        reject(err);\n      }\n      function resolver() {\n        if (typeof emitter.removeListener === 'function') {\n          emitter.removeListener('error', errorListener);\n        }\n        resolve([].slice.call(arguments));\n      }\n      eventTargetAgnosticAddListener(emitter, name, resolver, {\n        once: true\n      });\n      if (name !== 'error') {\n        addErrorHandlerIfEventEmitter(emitter, errorListener, {\n          once: true\n        });\n      }\n    });\n  }\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') {\n      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n    }\n  }\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n      if (flags.once) {\n        emitter.once(name, listener);\n      } else {\n        emitter.on(name, listener);\n      }\n    } else if (typeof emitter.addEventListener === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters, we do not listen for `error` events here.\n      emitter.addEventListener(name, function wrapListener(arg) {\n        // IE does not have builtin `{ once: true }` support so we\n        // have to do it manually.\n        if (flags.once) {\n          emitter.removeEventListener(name, wrapListener);\n        }\n        listener(arg);\n      });\n    } else {\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n  }\n  return events.exports;\n}\n\nvar eventsExports = requireEvents();\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = e => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  // Returned result object.\n  const result = {\n    browser: null,\n    version: null\n  };\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n  const {\n    navigator\n  } = window;\n\n  // Prefer navigator.userAgentData.\n  if (navigator.userAgentData && navigator.userAgentData.brands) {\n    const chromium = navigator.userAgentData.brands.find(brand => {\n      return brand.brand === 'Chromium';\n    });\n    if (chromium) {\n      return {\n        browser: 'chrome',\n        version: parseInt(chromium.version, 10)\n      };\n    }\n  }\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n  return Object.keys(data).reduce(function (accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nconst logging = log;\nfunction shimGetUserMedia$2(window, browserDetails) {\n  const navigator = window && window.navigator;\n  if (!navigator.mediaDevices) {\n    return;\n  }\n  const constraintsToChrome_ = function (c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = typeof c[key] === 'object' ? c[key] : {\n        ideal: c[key]\n      };\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function (prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === 'deviceId' ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n  const shimConstraints_ = function (constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function (obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && (typeof face === 'object' ? face : {\n        ideal: face\n      });\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices().then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {\n                exact: dev.deviceId\n              } : {\n                ideal: dev.deviceId\n              };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n  const shimError_ = function (e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n  const getUserMedia_ = function (constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nfunction shimOnTrack$1(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n    wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => filterStats(result, receiver.track, false));\n    };\n  }\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(s => s.track === track);\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === '') {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nfunction shimPeerConnection$1(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window, browserDetails) {\n  wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n\nvar chromeShim = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  fixNegotiationNeeded: fixNegotiationNeeded,\n  shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n  shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n  shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n  shimGetUserMedia: shimGetUserMedia$2,\n  shimMediaStream: shimMediaStream,\n  shimOnTrack: shimOnTrack$1,\n  shimPeerConnection: shimPeerConnection$1,\n  shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimGetUserMedia$1(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function (obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function () {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n      err.name = 'NotFoundError';\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = {\n        mediaSource: preferredMediaSource\n      };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null]).then(stats => {\n      if (browserDetails.version < 53 && !onSucc) {\n        // Shim only promise getStats with spec-hyphens in type names\n        // Leave callback version alone; misc old uses of forEach before Map\n        try {\n          stats.forEach(stat => {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== 'TypeError') {\n            throw e;\n          }\n          // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n          stats.forEach((stat, i) => {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n  };\n}\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    deprecated('removeStream', 'removeTrack');\n    this.getSenders().forEach(sender => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\nfunction shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      // WebIDL input coercion and validation\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n      if (sendEncodings === undefined) {\n        sendEncodings = [];\n      }\n      sendEncodings = [...sendEncodings];\n      const shouldPerformCheck = sendEncodings.length > 0;\n      if (shouldPerformCheck) {\n        // If sendEncodings params are provided, validate grammar\n        sendEncodings.forEach(encodingParam => {\n          if ('rid' in encodingParam) {\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError('Invalid RID value provided.');\n            }\n          }\n          if ('scaleResolutionDownBy' in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\n            }\n          }\n          if ('maxFramerate' in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError('max_framerate must be >= 0.0');\n            }\n          }\n        });\n      }\n      const transceiver = origAddTransceiver.apply(this, arguments);\n      if (shouldPerformCheck) {\n        // Check if the init options were applied. If not we do this in an\n        // asynchronous way and save the promise reference in a global object.\n        // This is an ugly hack, but at the same time is way more robust than\n        // checking the sender parameters before and after the createOffer\n        // Also note that after the createoffer we are not 100% sure that\n        // the params were asynchronously applied so we might miss the\n        // opportunity to recreate offer.\n        const {\n          sender\n        } = transceiver;\n        const params = sender.getParameters();\n        if (!('encodings' in params) ||\n        // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = sendEncodings;\n          sender.sendEncodings = sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\n            delete sender.sendEncodings;\n          }).catch(() => {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n      return transceiver;\n    };\n  }\n}\nfunction shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\n      const params = origGetParameters.apply(this, arguments);\n      if (!('encodings' in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n      return params;\n    };\n  }\n}\nfunction shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateOffer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n\nvar firefoxShim = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  shimAddTransceiver: shimAddTransceiver,\n  shimCreateAnswer: shimCreateAnswer,\n  shimCreateOffer: shimCreateOffer,\n  shimGetDisplayMedia: shimGetDisplayMedia,\n  shimGetParameters: shimGetParameters,\n  shimGetUserMedia: shimGetUserMedia$1,\n  shimOnTrack: shimOnTrack,\n  shimPeerConnection: shimPeerConnection,\n  shimRTCDataChannel: shimRTCDataChannel,\n  shimReceiverGetStats: shimReceiverGetStats,\n  shimRemoveStream: shimRemoveStream,\n  shimSenderGetStats: shimSenderGetStats\n});\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track, stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track, stream));\n    };\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      if (streams) {\n        streams.forEach(stream => {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        });\n      }\n      return _addTrack.apply(this, arguments);\n    };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      const tracks = stream.getTracks();\n      this.getSenders().forEach(sender => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = e => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      const pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\n          e.streams.forEach(stream => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  let withCallback = function (description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n  withCallback = function (description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n  withCallback = function (candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = constraints => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator);\n  }\n}\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({}, constraints, {\n      video: compactObject(constraints.video)\n    });\n  }\n  return constraints;\n}\nfunction shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n        if (server.urls === undefined && server.url) {\n          deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === 'sendrecv') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('sendonly');\n          } else {\n            audioTransceiver.direction = 'sendonly';\n          }\n        } else if (audioTransceiver.direction === 'recvonly') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('inactive');\n          } else {\n            audioTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver('audio', {\n          direction: 'recvonly'\n        });\n      }\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === 'sendrecv') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('sendonly');\n          } else {\n            videoTransceiver.direction = 'sendonly';\n          }\n        } else if (videoTransceiver.direction === 'recvonly') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('inactive');\n          } else {\n            videoTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver('video', {\n          direction: 'recvonly'\n        });\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}\n\nvar safariShim = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  shimAudioContext: shimAudioContext,\n  shimCallbacksAPI: shimCallbacksAPI,\n  shimConstraints: shimConstraints,\n  shimCreateOfferLegacy: shimCreateOfferLegacy,\n  shimGetUserMedia: shimGetUserMedia,\n  shimLocalStreamsAPI: shimLocalStreamsAPI,\n  shimRTCIceServerUrls: shimRTCIceServerUrls,\n  shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n  shimTrackEventTransceiver: shimTrackEventTransceiver\n});\n\nvar sdp$1 = {exports: {}};\n\n/* eslint-env node */\nvar hasRequiredSdp;\nfunction requireSdp() {\n  if (hasRequiredSdp) return sdp$1.exports;\n  hasRequiredSdp = 1;\n  (function (module) {\n\n    // SDP helpers.\n    const SDPUtils = {};\n\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function () {\n      return Math.random().toString(36).substring(2, 12);\n    };\n\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function (blob) {\n      return blob.trim().split('\\n').map(line => line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function (blob) {\n      const parts = blob.split('\\nm=');\n      return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n    };\n\n    // Returns the session description.\n    SDPUtils.getDescription = function (blob) {\n      const sections = SDPUtils.splitSections(blob);\n      return sections && sections[0];\n    };\n\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function (blob) {\n      const sections = SDPUtils.splitSections(blob);\n      sections.shift();\n      return sections;\n    };\n\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function (blob, prefix) {\n      return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n    };\n\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996\"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function (line) {\n      let parts;\n      // Parse both variants.\n      if (line.indexOf('a=candidate:') === 0) {\n        parts = line.substring(12).split(' ');\n      } else {\n        parts = line.substring(10).split(' ');\n      }\n      const candidate = {\n        foundation: parts[0],\n        component: {\n          1: 'rtp',\n          2: 'rtcp'\n        }[parts[1]] || parts[1],\n        protocol: parts[2].toLowerCase(),\n        priority: parseInt(parts[3], 10),\n        ip: parts[4],\n        address: parts[4],\n        // address is an alias for ip.\n        port: parseInt(parts[5], 10),\n        // skip parts[6] == 'typ'\n        type: parts[7]\n      };\n      for (let i = 8; i < parts.length; i += 2) {\n        switch (parts[i]) {\n          case 'raddr':\n            candidate.relatedAddress = parts[i + 1];\n            break;\n          case 'rport':\n            candidate.relatedPort = parseInt(parts[i + 1], 10);\n            break;\n          case 'tcptype':\n            candidate.tcpType = parts[i + 1];\n            break;\n          case 'ufrag':\n            candidate.ufrag = parts[i + 1]; // for backward compatibility.\n            candidate.usernameFragment = parts[i + 1];\n            break;\n          default:\n            // extension handling, in particular ufrag. Don't overwrite.\n            if (candidate[parts[i]] === undefined) {\n              candidate[parts[i]] = parts[i + 1];\n            }\n            break;\n        }\n      }\n      return candidate;\n    };\n\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function (candidate) {\n      const sdp = [];\n      sdp.push(candidate.foundation);\n      const component = candidate.component;\n      if (component === 'rtp') {\n        sdp.push(1);\n      } else if (component === 'rtcp') {\n        sdp.push(2);\n      } else {\n        sdp.push(component);\n      }\n      sdp.push(candidate.protocol.toUpperCase());\n      sdp.push(candidate.priority);\n      sdp.push(candidate.address || candidate.ip);\n      sdp.push(candidate.port);\n      const type = candidate.type;\n      sdp.push('typ');\n      sdp.push(type);\n      if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n        sdp.push('raddr');\n        sdp.push(candidate.relatedAddress);\n        sdp.push('rport');\n        sdp.push(candidate.relatedPort);\n      }\n      if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n        sdp.push('tcptype');\n        sdp.push(candidate.tcpType);\n      }\n      if (candidate.usernameFragment || candidate.ufrag) {\n        sdp.push('ufrag');\n        sdp.push(candidate.usernameFragment || candidate.ufrag);\n      }\n      return 'candidate:' + sdp.join(' ');\n    };\n\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function (line) {\n      return line.substring(14).split(' ');\n    };\n\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function (line) {\n      let parts = line.substring(9).split(' ');\n      const parsed = {\n        payloadType: parseInt(parts.shift(), 10) // was: id\n      };\n      parts = parts[0].split('/');\n      parsed.name = parts[0];\n      parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n      // legacy alias, got renamed back to channels in ORTC.\n      parsed.numChannels = parsed.channels;\n      return parsed;\n    };\n\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function (codec) {\n      let pt = codec.payloadType;\n      if (codec.preferredPayloadType !== undefined) {\n        pt = codec.preferredPayloadType;\n      }\n      const channels = codec.channels || codec.numChannels || 1;\n      return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n    };\n\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function (line) {\n      const parts = line.substring(9).split(' ');\n      return {\n        id: parseInt(parts[0], 10),\n        direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n        uri: parts[1],\n        attributes: parts.slice(2).join(' ')\n      };\n    };\n\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function (headerExtension) {\n      return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\n    };\n\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function (line) {\n      const parsed = {};\n      let kv;\n      const parts = line.substring(line.indexOf(' ') + 1).split(';');\n      for (let j = 0; j < parts.length; j++) {\n        kv = parts[j].trim().split('=');\n        parsed[kv[0].trim()] = kv[1];\n      }\n      return parsed;\n    };\n\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function (codec) {\n      let line = '';\n      let pt = codec.payloadType;\n      if (codec.preferredPayloadType !== undefined) {\n        pt = codec.preferredPayloadType;\n      }\n      if (codec.parameters && Object.keys(codec.parameters).length) {\n        const params = [];\n        Object.keys(codec.parameters).forEach(param => {\n          if (codec.parameters[param] !== undefined) {\n            params.push(param + '=' + codec.parameters[param]);\n          } else {\n            params.push(param);\n          }\n        });\n        line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n      }\n      return line;\n    };\n\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function (line) {\n      const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n      return {\n        type: parts.shift(),\n        parameter: parts.join(' ')\n      };\n    };\n\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function (codec) {\n      let lines = '';\n      let pt = codec.payloadType;\n      if (codec.preferredPayloadType !== undefined) {\n        pt = codec.preferredPayloadType;\n      }\n      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n        // FIXME: special handling for trr-int?\n        codec.rtcpFeedback.forEach(fb => {\n          lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n        });\n      }\n      return lines;\n    };\n\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function (line) {\n      const sp = line.indexOf(' ');\n      const parts = {\n        ssrc: parseInt(line.substring(7, sp), 10)\n      };\n      const colon = line.indexOf(':', sp);\n      if (colon > -1) {\n        parts.attribute = line.substring(sp + 1, colon);\n        parts.value = line.substring(colon + 1);\n      } else {\n        parts.attribute = line.substring(sp + 1);\n      }\n      return parts;\n    };\n\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function (line) {\n      const parts = line.substring(13).split(' ');\n      return {\n        semantics: parts.shift(),\n        ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n      };\n    };\n\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function (mediaSection) {\n      const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n      if (mid) {\n        return mid.substring(6);\n      }\n    };\n\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function (line) {\n      const parts = line.substring(14).split(' ');\n      return {\n        algorithm: parts[0].toLowerCase(),\n        // algorithm is case-sensitive in Edge.\n        value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n      };\n    };\n\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n      // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n      return {\n        role: 'auto',\n        fingerprints: lines.map(SDPUtils.parseFingerprint)\n      };\n    };\n\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function (params, setupType) {\n      let sdp = 'a=setup:' + setupType + '\\r\\n';\n      params.fingerprints.forEach(fp => {\n        sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n      });\n      return sdp;\n    };\n\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function (line) {\n      const parts = line.substring(9).split(' ');\n      return {\n        tag: parseInt(parts[0], 10),\n        cryptoSuite: parts[1],\n        keyParams: parts[2],\n        sessionParams: parts.slice(3)\n      };\n    };\n    SDPUtils.writeCryptoLine = function (parameters) {\n      return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n    };\n\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function (keyParams) {\n      if (keyParams.indexOf('inline:') !== 0) {\n        return null;\n      }\n      const parts = keyParams.substring(7).split('|');\n      return {\n        keyMethod: 'inline',\n        keySalt: parts[0],\n        lifeTime: parts[1],\n        mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n        mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n      };\n    };\n    SDPUtils.writeCryptoKeyParams = function (keyParams) {\n      return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n    };\n\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n      return lines.map(SDPUtils.parseCryptoLine);\n    };\n\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n      const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n      const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n      if (!(ufrag && pwd)) {\n        return null;\n      }\n      return {\n        usernameFragment: ufrag.substring(12),\n        password: pwd.substring(10)\n      };\n    };\n\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function (params) {\n      let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n      if (params.iceLite) {\n        sdp += 'a=ice-lite\\r\\n';\n      }\n      return sdp;\n    };\n\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function (mediaSection) {\n      const description = {\n        codecs: [],\n        headerExtensions: [],\n        fecMechanisms: [],\n        rtcp: []\n      };\n      const lines = SDPUtils.splitLines(mediaSection);\n      const mline = lines[0].split(' ');\n      description.profile = mline[2];\n      for (let i = 3; i < mline.length; i++) {\n        // find all codecs from mline[3..]\n        const pt = mline[i];\n        const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n        if (rtpmapline) {\n          const codec = SDPUtils.parseRtpMap(rtpmapline);\n          const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n          // Only the first a=fmtp:<pt> is considered.\n          codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n          codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n          description.codecs.push(codec);\n          // parse FEC mechanisms from rtpmap lines.\n          switch (codec.name.toUpperCase()) {\n            case 'RED':\n            case 'ULPFEC':\n              description.fecMechanisms.push(codec.name.toUpperCase());\n              break;\n          }\n        }\n      }\n      SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n        description.headerExtensions.push(SDPUtils.parseExtmap(line));\n      });\n      const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\n      description.codecs.forEach(codec => {\n        wildcardRtcpFb.forEach(fb => {\n          const duplicate = codec.rtcpFeedback.find(existingFeedback => {\n            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n          });\n          if (!duplicate) {\n            codec.rtcpFeedback.push(fb);\n          }\n        });\n      });\n      // FIXME: parse rtcp.\n      return description;\n    };\n\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function (kind, caps) {\n      let sdp = '';\n\n      // Build the mline.\n      sdp += 'm=' + kind + ' ';\n      sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n      sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n      sdp += caps.codecs.map(codec => {\n        if (codec.preferredPayloadType !== undefined) {\n          return codec.preferredPayloadType;\n        }\n        return codec.payloadType;\n      }).join(' ') + '\\r\\n';\n      sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n      sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n      // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n      caps.codecs.forEach(codec => {\n        sdp += SDPUtils.writeRtpMap(codec);\n        sdp += SDPUtils.writeFmtp(codec);\n        sdp += SDPUtils.writeRtcpFb(codec);\n      });\n      let maxptime = 0;\n      caps.codecs.forEach(codec => {\n        if (codec.maxptime > maxptime) {\n          maxptime = codec.maxptime;\n        }\n      });\n      if (maxptime > 0) {\n        sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n      }\n      if (caps.headerExtensions) {\n        caps.headerExtensions.forEach(extension => {\n          sdp += SDPUtils.writeExtmap(extension);\n        });\n      }\n      // FIXME: write fecMechanisms.\n      return sdp;\n    };\n\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n      const encodingParameters = [];\n      const description = SDPUtils.parseRtpParameters(mediaSection);\n      const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n      const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n      // filter a=ssrc:... cname:, ignore PlanB-msid\n      const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n      let secondarySsrc;\n      const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n        const parts = line.substring(17).split(' ');\n        return parts.map(part => parseInt(part, 10));\n      });\n      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n        secondarySsrc = flows[0][1];\n      }\n      description.codecs.forEach(codec => {\n        if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n          let encParam = {\n            ssrc: primarySsrc,\n            codecPayloadType: parseInt(codec.parameters.apt, 10)\n          };\n          if (primarySsrc && secondarySsrc) {\n            encParam.rtx = {\n              ssrc: secondarySsrc\n            };\n          }\n          encodingParameters.push(encParam);\n          if (hasRed) {\n            encParam = JSON.parse(JSON.stringify(encParam));\n            encParam.fec = {\n              ssrc: primarySsrc,\n              mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n            };\n            encodingParameters.push(encParam);\n          }\n        }\n      });\n      if (encodingParameters.length === 0 && primarySsrc) {\n        encodingParameters.push({\n          ssrc: primarySsrc\n        });\n      }\n\n      // we support both b=AS and b=TIAS but interpret AS as TIAS.\n      let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n      if (bandwidth.length) {\n        if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n          bandwidth = parseInt(bandwidth[0].substring(7), 10);\n        } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n          // use formula from JSEP to convert b=AS to TIAS value.\n          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n        } else {\n          bandwidth = undefined;\n        }\n        encodingParameters.forEach(params => {\n          params.maxBitrate = bandwidth;\n        });\n      }\n      return encodingParameters;\n    };\n\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function (mediaSection) {\n      const rtcpParameters = {};\n\n      // Gets the first SSRC. Note that with RTX there might be multiple\n      // SSRCs.\n      const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n      if (remoteSsrc) {\n        rtcpParameters.cname = remoteSsrc.value;\n        rtcpParameters.ssrc = remoteSsrc.ssrc;\n      }\n\n      // Edge uses the compound attribute instead of reducedSize\n      // compound is !reducedSize\n      const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n      rtcpParameters.reducedSize = rsize.length > 0;\n      rtcpParameters.compound = rsize.length === 0;\n\n      // parses the rtcp-mux attrbute.\n      // Note that Edge does not support unmuxed RTCP.\n      const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n      rtcpParameters.mux = mux.length > 0;\n      return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function (rtcpParameters) {\n      let sdp = '';\n      if (rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n      if (rtcpParameters.mux) {\n        sdp += 'a=rtcp-mux\\r\\n';\n      }\n      if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n        sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n      }\n      return sdp;\n    };\n\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function (mediaSection) {\n      let parts;\n      const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n      if (spec.length === 1) {\n        parts = spec[0].substring(7).split(' ');\n        return {\n          stream: parts[0],\n          track: parts[1]\n        };\n      }\n      const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n      if (planB.length > 0) {\n        parts = planB[0].value.split(' ');\n        return {\n          stream: parts[0],\n          track: parts[1]\n        };\n      }\n    };\n\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function (mediaSection) {\n      const mline = SDPUtils.parseMLine(mediaSection);\n      const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n      let maxMessageSize;\n      if (maxSizeLine.length > 0) {\n        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n      }\n      if (isNaN(maxMessageSize)) {\n        maxMessageSize = 65536;\n      }\n      const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n      if (sctpPort.length > 0) {\n        return {\n          port: parseInt(sctpPort[0].substring(12), 10),\n          protocol: mline.fmt,\n          maxMessageSize\n        };\n      }\n      const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n      if (sctpMapLines.length > 0) {\n        const parts = sctpMapLines[0].substring(10).split(' ');\n        return {\n          port: parseInt(parts[0], 10),\n          protocol: parts[1],\n          maxMessageSize\n        };\n      }\n    };\n\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function (media, sctp) {\n      let output = [];\n      if (media.protocol !== 'DTLS/SCTP') {\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n      } else {\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n      }\n      if (sctp.maxMessageSize !== undefined) {\n        output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n      }\n      return output.join('');\n    };\n\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function () {\n      return Math.random().toString().substr(2, 22);\n    };\n\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to 'thisisadapterortc'\n    SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n      let sessionId;\n      const version = sessVer !== undefined ? sessVer : 2;\n      if (sessId) {\n        sessionId = sessId;\n      } else {\n        sessionId = SDPUtils.generateSessionId();\n      }\n      const user = sessUser || 'thisisadapterortc';\n      // FIXME: sess-id should be an NTP timestamp.\n      return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n    };\n\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function (mediaSection, sessionpart) {\n      // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n      const lines = SDPUtils.splitLines(mediaSection);\n      for (let i = 0; i < lines.length; i++) {\n        switch (lines[i]) {\n          case 'a=sendrecv':\n          case 'a=sendonly':\n          case 'a=recvonly':\n          case 'a=inactive':\n            return lines[i].substring(2);\n          // FIXME: What should happen here?\n        }\n      }\n      if (sessionpart) {\n        return SDPUtils.getDirection(sessionpart);\n      }\n      return 'sendrecv';\n    };\n    SDPUtils.getKind = function (mediaSection) {\n      const lines = SDPUtils.splitLines(mediaSection);\n      const mline = lines[0].split(' ');\n      return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function (mediaSection) {\n      return mediaSection.split(' ', 2)[1] === '0';\n    };\n    SDPUtils.parseMLine = function (mediaSection) {\n      const lines = SDPUtils.splitLines(mediaSection);\n      const parts = lines[0].substring(2).split(' ');\n      return {\n        kind: parts[0],\n        port: parseInt(parts[1], 10),\n        protocol: parts[2],\n        fmt: parts.slice(3).join(' ')\n      };\n    };\n    SDPUtils.parseOLine = function (mediaSection) {\n      const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n      const parts = line.substring(2).split(' ');\n      return {\n        username: parts[0],\n        sessionId: parts[1],\n        sessionVersion: parseInt(parts[2], 10),\n        netType: parts[3],\n        addressType: parts[4],\n        address: parts[5]\n      };\n    };\n\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function (blob) {\n      if (typeof blob !== 'string' || blob.length === 0) {\n        return false;\n      }\n      const lines = SDPUtils.splitLines(blob);\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n          return false;\n        }\n        // TODO: check the modifier a bit more.\n      }\n      return true;\n    };\n\n    // Expose public methods.\n    {\n      module.exports = SDPUtils;\n    }\n  })(sdp$1);\n  return sdp$1.exports;\n}\n\nvar sdpExports = requireSdp();\nvar SDPUtils = /*@__PURE__*/getDefaultExportFromCjs(sdpExports);\n\nvar sdp = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: SDPUtils\n}, [sdpExports]);\n\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substring(2);\n    }\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n      for (const key in parsedCandidate) {\n        if (!(key in nativeCandidate)) {\n          Object.defineProperty(nativeCandidate, key, {\n            value: parsedCandidate[key]\n          });\n        }\n      }\n\n      // Override serializer to not serialize the extra attributes.\n      nativeCandidate.toJSON = function toJSON() {\n        return {\n          candidate: nativeCandidate.candidate,\n          sdpMid: nativeCandidate.sdpMid,\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n          usernameFragment: nativeCandidate.usernameFragment\n        };\n      };\n      return nativeCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\nfunction shimRTCIceCandidateRelayProtocol(window) {\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'relayProtocol' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n      if (parsedCandidate.type === 'relay') {\n        // This is a libwebrtc-specific mapping of local type preference\n        // to relayProtocol.\n        e.candidate.relayProtocol = {\n          0: 'tls',\n          1: 'tcp',\n          2: 'udp'\n        }[parsedCandidate.priority >> 24];\n      }\n    }\n    return e;\n  });\n}\nfunction shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n  const sctpInDescription = function (description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = SDPUtils.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = SDPUtils.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n  const getRemoteFirefoxVersion = function (description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n  const getCanSendMaxMessageSize = function (remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n  const getMaxMessageSize = function (description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n    const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substring(19), 10);\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null;\n    // Chrome decided to not expose .sctp in plan-b mode.\n    // As usual, adapter.js has to do an 'ugly worakaround'\n    // to cover up the mess.\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n      const {\n        sdpSemantics\n      } = this.getConfiguration();\n      if (sdpSemantics === 'plan-b') {\n        Object.defineProperty(this, 'sctp', {\n          get() {\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\n          },\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    if (sctpInDescription(arguments[0])) {\n      // Check if the remote is FF.\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n      // Get the maximum message size the local peer is capable of sending\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n      // Get the maximum message size of the remote peer.\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n      // Determine final maximum message size\n      let maxMessageSize;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n      // attribute.\n      const sctp = {};\n      Object.defineProperty(sctp, 'maxMessageSize', {\n        get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ['setLocalDescription', 'setRemoteDescription'].forEach(method => {\n    const origMethod = proto[method];\n    proto[method] = function () {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter(line => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\n      if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n    // in older versions.\n    // Native support for ignoring exists for Chrome M77+.\n    // Safari ignores as well, exact version unknown but works in the same\n    // version that also ignores addIceCandidate(null).\n    if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\n\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    let desc = arguments[0] || {};\n    if (typeof desc !== 'object' || desc.type && desc.sdp) {\n      return nativeSetLocalDescription.apply(this, arguments);\n    }\n    // The remaining steps should technically happen when SLD comes off the\n    // RTCPeerConnection's operations chain (not ahead of going on it), but\n    // this is too difficult to shim. Instead, this shim only covers the\n    // common case where the operations chain is empty. This is imperfect, but\n    // should cover many cases. Rationale: Even if we can't reduce the glare\n    // window to zero on imperfect implementations, there's value in tapping\n    // into the perfect negotiation pattern that several browsers support.\n    desc = {\n      type: desc.type,\n      sdp: desc.sdp\n    };\n    if (!desc.type) {\n      switch (this.signalingState) {\n        case 'stable':\n        case 'have-local-offer':\n        case 'have-remote-pranswer':\n          desc.type = 'offer';\n          break;\n        default:\n          desc.type = 'answer';\n          break;\n      }\n    }\n    if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\n      return nativeSetLocalDescription.apply(this, [desc]);\n    }\n    const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n    return func.apply(this).then(d => nativeSetLocalDescription.apply(this, [d]));\n  };\n}\n\nvar commonShim = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  removeExtmapAllowMixed: removeExtmapAllowMixed,\n  shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n  shimConnectionState: shimConnectionState,\n  shimMaxMessageSize: shimMaxMessageSize,\n  shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n  shimRTCIceCandidate: shimRTCIceCandidate,\n  shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n  shimSendThrowTypeError: shimSendThrowTypeError\n});\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n// Shimming starts here.\nfunction adapterFactory() {\n  let {\n    window\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimSafari: true\n  };\n  // Utils.\n  const logging = log;\n  const browserDetails = detectBrowser(window);\n  const adapter = {\n    browserDetails,\n    commonShim,\n    extractVersion: extractVersion,\n    disableLog: disableLog,\n    disableWarnings: disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n\n      // Must be called before shimPeerConnection.\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      shimParameterlessSetLocalDescription(window);\n      shimGetUserMedia$2(window, browserDetails);\n      shimMediaStream(window);\n      shimPeerConnection$1(window, browserDetails);\n      shimOnTrack$1(window);\n      shimAddTrackRemoveTrack(window, browserDetails);\n      shimGetSendersWithDtmf(window);\n      shimSenderReceiverGetStats(window);\n      fixNegotiationNeeded(window, browserDetails);\n      shimRTCIceCandidate(window);\n      shimRTCIceCandidateRelayProtocol(window);\n      shimConnectionState(window);\n      shimMaxMessageSize(window, browserDetails);\n      shimSendThrowTypeError(window);\n      removeExtmapAllowMixed(window, browserDetails);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n\n      // Must be called before shimPeerConnection.\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      shimParameterlessSetLocalDescription(window);\n      shimGetUserMedia$1(window, browserDetails);\n      shimPeerConnection(window, browserDetails);\n      shimOnTrack(window);\n      shimRemoveStream(window);\n      shimSenderGetStats(window);\n      shimReceiverGetStats(window);\n      shimRTCDataChannel(window);\n      shimAddTransceiver(window);\n      shimGetParameters(window);\n      shimCreateOffer(window);\n      shimCreateAnswer(window);\n      shimRTCIceCandidate(window);\n      shimConnectionState(window);\n      shimMaxMessageSize(window, browserDetails);\n      shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n\n      // Must be called before shimCallbackAPI.\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      shimParameterlessSetLocalDescription(window);\n      shimRTCIceServerUrls(window);\n      shimCreateOfferLegacy(window);\n      shimCallbacksAPI(window);\n      shimLocalStreamsAPI(window);\n      shimRemoteStreamsAPI(window);\n      shimTrackEventTransceiver(window);\n      shimGetUserMedia(window);\n      shimAudioContext(window);\n      shimRTCIceCandidate(window);\n      shimRTCIceCandidateRelayProtocol(window);\n      shimMaxMessageSize(window, browserDetails);\n      shimSendThrowTypeError(window);\n      removeExtmapAllowMixed(window, browserDetails);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n  return adapter;\n}\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nadapterFactory({\n  window: typeof window === 'undefined' ? undefined : window\n});\n\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = 'lk_e2ee';\nconst SALT = 'LKFrameEncryptionKey';\nconst KEY_PROVIDER_DEFAULTS = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n  keyringSize: 16,\n  allowKeyExtraction: false\n};\n\nvar KeyProviderEvent;\n(function (KeyProviderEvent) {\n  KeyProviderEvent[\"SetKey\"] = \"setKey\";\n  KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n  KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function (KeyHandlerEvent) {\n  KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function (EncryptionEvent) {\n  EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function (CryptorEvent) {\n  CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\n\nfunction isE2EESupported() {\n  return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n  // @ts-ignore\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\nfunction isInsertableStreamSupported() {\n  return typeof window.RTCRtpSender !== 'undefined' &&\n  // @ts-ignore\n  typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';\n}\nfunction isVideoFrame(frame) {\n  return 'type' in frame;\n}\nfunction importKey(keyBytes_1) {\n  return __awaiter(this, arguments, void 0, function (keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\n    let extractable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    return function* () {\n      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n      return crypto.subtle.importKey('raw', keyBytes, algorithm, extractable, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']);\n    }();\n  });\n}\nfunction createKeyMaterialFromString(password) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let enc = new TextEncoder();\n    const keyMaterial = yield crypto.subtle.importKey('raw', enc.encode(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveBits', 'deriveKey']);\n    return keyMaterial;\n  });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, ['deriveBits', 'deriveKey']);\n    return keyMaterial;\n  });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128)\n      };\n    case 'PBKDF2':\n      {\n        return {\n          name: 'PBKDF2',\n          salt: encodedSalt,\n          hash: 'SHA-256',\n          iterations: 100000\n        };\n      }\n    default:\n      throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n  }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nfunction deriveKeys(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n    const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128\n    }, false, ['encrypt', 'decrypt']);\n    return {\n      material,\n      encryptionKey\n    };\n  });\n}\nfunction createE2EEKey() {\n  return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nfunction ratchet(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n    return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n  });\n}\nfunction needsRbspUnescaping(frameData) {\n  for (var i = 0; i < frameData.length - 3; i++) {\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n  }\n  return false;\n}\nfunction parseRbsp(stream) {\n  const dataOut = [];\n  var length = stream.length;\n  for (var i = 0; i < stream.length;) {\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n    // above, and that expression will produce the number of bytes left in\n    // the stream including the byte at i.\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n      // Two rbsp bytes.\n      dataOut.push(stream[i++]);\n      dataOut.push(stream[i++]);\n      // Skip the emulation byte.\n      i++;\n    } else {\n      // Single rbsp byte.\n      dataOut.push(stream[i++]);\n    }\n  }\n  return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n  const dataOut = [];\n  var numConsecutiveZeros = 0;\n  for (var i = 0; i < data_in.length; ++i) {\n    var byte = data_in[i];\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n      // Need to escape.\n      dataOut.push(kEmulationByte);\n      numConsecutiveZeros = 0;\n    }\n    dataOut.push(byte);\n    if (byte == 0) {\n      ++numConsecutiveZeros;\n    } else {\n      numConsecutiveZeros = 0;\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n\n/**\n * @experimental\n */\nclass BaseKeyProvider extends eventsExports.EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */\n    this.onKeyRatcheted = (material, keyIndex) => {\n      livekitLogger.debug('key ratcheted event received', {\n        material,\n        keyIndex\n      });\n    };\n    this.keyInfoMap = new Map();\n    this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n    this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n  }\n  /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */\n  onSetEncryptionKey(key, participantIdentity, keyIndex) {\n    const keyInfo = {\n      key,\n      participantIdentity,\n      keyIndex\n    };\n    if (!this.options.sharedKey && !participantIdentity) {\n      throw new Error('participant identity needs to be passed for encryption key if sharedKey option is false');\n    }\n    this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n    this.emit(KeyProviderEvent.SetKey, keyInfo);\n  }\n  getKeys() {\n    return Array.from(this.keyInfoMap.values());\n  }\n  getOptions() {\n    return this.options;\n  }\n  ratchetKey(participantIdentity, keyIndex) {\n    this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n  }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */\nclass ExternalE2EEKeyProvider extends BaseKeyProvider {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const opts = Object.assign(Object.assign({}, options), {\n      sharedKey: true,\n      // for a shared key provider failing to decrypt for a specific participant\n      // should not mark the key as invalid, so we accept wrong keys forever\n      // and won't try to auto-ratchet\n      ratchetWindowSize: 0,\n      failureTolerance: -1\n    });\n    super(opts);\n  }\n  /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */\n  setKey(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const derivedKey = typeof key === 'string' ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n      this.onSetEncryptionKey(derivedKey);\n    });\n  }\n}\n\nclass LivekitError extends Error {\n  constructor(code, message) {\n    super(message || 'an error has occured');\n    this.name = 'LiveKitError';\n    this.code = code;\n  }\n}\nvar ConnectionErrorReason;\n(function (ConnectionErrorReason) {\n  ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\n  ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\n  ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n  ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\n  ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\nclass ConnectionError extends LivekitError {\n  constructor(message, reason, status, context) {\n    super(1, message);\n    this.name = 'ConnectionError';\n    this.status = status;\n    this.reason = reason;\n    this.context = context;\n    this.reasonName = ConnectionErrorReason[reason];\n  }\n}\nclass DeviceUnsupportedError extends LivekitError {\n  constructor(message) {\n    super(21, message !== null && message !== void 0 ? message : 'device is unsupported');\n    this.name = 'DeviceUnsupportedError';\n  }\n}\nclass TrackInvalidError extends LivekitError {\n  constructor(message) {\n    super(20, message !== null && message !== void 0 ? message : 'track is invalid');\n    this.name = 'TrackInvalidError';\n  }\n}\nclass UnsupportedServer extends LivekitError {\n  constructor(message) {\n    super(10, message !== null && message !== void 0 ? message : 'unsupported server');\n    this.name = 'UnsupportedServer';\n  }\n}\nclass UnexpectedConnectionState extends LivekitError {\n  constructor(message) {\n    super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');\n    this.name = 'UnexpectedConnectionState';\n  }\n}\nclass NegotiationError extends LivekitError {\n  constructor(message) {\n    super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');\n    this.name = 'NegotiationError';\n  }\n}\nclass PublishDataError extends LivekitError {\n  constructor(message) {\n    super(14, message !== null && message !== void 0 ? message : 'unable to publish data');\n    this.name = 'PublishDataError';\n  }\n}\nclass PublishTrackError extends LivekitError {\n  constructor(message, status) {\n    super(15, message);\n    this.name = 'PublishTrackError';\n    this.status = status;\n  }\n}\nclass SignalRequestError extends LivekitError {\n  constructor(message, reason) {\n    super(15, message);\n    this.reason = reason;\n    this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];\n  }\n}\nvar MediaDeviceFailure;\n(function (MediaDeviceFailure) {\n  // user rejected permissions\n  MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n  // device is not available\n  MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n  MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function (MediaDeviceFailure) {\n  function getFailure(error) {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n  MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n\nvar CryptorErrorReason;\n(function (CryptorErrorReason) {\n  CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n  CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n  CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n  constructor(message) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n    let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\n    super(40, message);\n    this.reason = reason;\n    this.participantIdentity = participantIdentity;\n  }\n}\n\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */\nvar RoomEvent;\n(function (RoomEvent) {\n  /**\n   * When the connection to the server has been established\n   */\n  RoomEvent[\"Connected\"] = \"connected\";\n  /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */\n  RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n  /**\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\n   */\n  RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\n  /**\n   * Fires when a reconnection has been successful.\n   */\n  RoomEvent[\"Reconnected\"] = \"reconnected\";\n  /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured.\n   *\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\n   *\n   * args: ([[DisconnectReason]])\n   */\n  RoomEvent[\"Disconnected\"] = \"disconnected\";\n  /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */\n  RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n  /**\n   * When input or output devices on the machine have changed.\n   */\n  RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n  /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */\n  RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n  /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */\n  RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n  /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n  /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n  /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n  /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */\n  RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n  /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */\n  RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n  /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */\n  RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */\n  RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */\n  RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n  /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */\n  RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n  /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */\n  RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */\n  RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\n  /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */\n  RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n  /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */\n  RoomEvent[\"DataReceived\"] = \"dataReceived\";\n  /**\n   * SIP DTMF tones received from another participant.\n   *\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\n   */\n  RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n  /**\n   * Transcription received from a participant's track.\n   * @beta\n   */\n  RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */\n  RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */\n  RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n  /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */\n  RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n  /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */\n  RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  /**\n   * Signal connected, can publish tracks.\n   */\n  RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n  /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */\n  RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n  RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n  /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */\n  RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n  /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */\n  RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n  RoomEvent[\"ChatMessage\"] = \"chatMessage\";\n  /**\n   * fired when the first remote participant has subscribed to the localParticipant's track\n   */\n  RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  /**\n   * fired when the client receives connection metrics from other participants\n   */\n  RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function (ParticipantEvent) {\n  /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n  /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n  /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */\n  ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n  /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */\n  ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n  /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n  /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */\n  ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */\n  ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */\n  ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n  /**\n   * SIP DTMF tones received from this participant as sender.\n   *\n   * args: (dtmf: [[DataPacket_Kind]])\n   */\n  ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n  /**\n   * Transcription received from this participant as data source.\n   * @beta\n   */\n  ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */\n  ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n  /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */\n  ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */\n  ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */\n  ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */\n  ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  // fired only on LocalParticipant\n  /** @internal */\n  ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  // fired only on LocalParticipant\n  /** @internal */\n  ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n  /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */\n  ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  /** @internal */\n  ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n  /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\n   * args: (changedAttributes: [[Record<string, string]])\n   */\n  ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\n  /**\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\n   */\n  ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  /** only emitted on local participant */\n  ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */\nvar EngineEvent;\n(function (EngineEvent) {\n  EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n  EngineEvent[\"Connected\"] = \"connected\";\n  EngineEvent[\"Disconnected\"] = \"disconnected\";\n  EngineEvent[\"Resuming\"] = \"resuming\";\n  EngineEvent[\"Resumed\"] = \"resumed\";\n  EngineEvent[\"Restarting\"] = \"restarting\";\n  EngineEvent[\"Restarted\"] = \"restarted\";\n  EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n  EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n  EngineEvent[\"Closing\"] = \"closing\";\n  EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n  EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n  EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n  EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n  EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n  EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n  EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n  EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n  EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n  EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n  EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n  EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n  EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n  EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n  EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  EngineEvent[\"Offline\"] = \"offline\";\n  EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\n  EngineEvent[\"SignalConnected\"] = \"signalConnected\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function (TrackEvent) {\n  TrackEvent[\"Message\"] = \"message\";\n  TrackEvent[\"Muted\"] = \"muted\";\n  TrackEvent[\"Unmuted\"] = \"unmuted\";\n  /**\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"Restarted\"] = \"restarted\";\n  TrackEvent[\"Ended\"] = \"ended\";\n  TrackEvent[\"Subscribed\"] = \"subscribed\";\n  TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n  /** @internal */\n  TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n  /** @internal */\n  TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n  /** @internal */\n  TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n  /** @internal */\n  TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n  /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */\n  TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n  /** @internal */\n  TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n  /** @internal */\n  TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n  /** @internal */\n  TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n  /** @internal */\n  TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n  /** @internal */\n  TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n  /** @internal */\n  TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n  /**\n   * @internal\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n  /**\n   * @internal\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n  /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n  /**\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n  /**\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\n  /**\n   * @beta\n   */\n  TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * @experimental\n   */\n  TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\n})(TrackEvent || (TrackEvent = {}));\n\nfunction cloneDeep(value) {\n  if (typeof value === 'undefined') {\n    return value;\n  }\n  if (typeof structuredClone === 'function') {\n    return structuredClone(value);\n  } else {\n    return JSON.parse(JSON.stringify(value));\n  }\n}\n\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */\nfunction getBrowser(userAgent) {\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {\n    return;\n  }\n  const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n  if (browserDetails === undefined || force) {\n    const browser = browsersList.find(_ref => {\n      let {\n        test\n      } = _ref;\n      return test.test(ua);\n    });\n    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n  }\n  return browserDetails;\n}\nconst browsersList = [{\n  test: /firefox|iceweasel|fxios/i,\n  describe(ua) {\n    const browser = {\n      name: 'Firefox',\n      version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n      os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined,\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}, {\n  test: /chrom|crios|crmo/i,\n  describe(ua) {\n    const browser = {\n      name: 'Chrome',\n      version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n      os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined,\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}, /* Safari */\n{\n  test: /safari|applewebkit/i,\n  describe(ua) {\n    const browser = {\n      name: 'Safari',\n      version: getMatch(commonVersionIdentifier, ua),\n      os: ua.includes('mobile/') ? 'iOS' : 'macOS',\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}];\nfunction getMatch(exp, ua) {\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const match = ua.match(exp);\n  return match && match.length >= id && match[id] || '';\n}\nfunction getOSVersion(ua) {\n  return ua.includes('mac os') ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, '.') : undefined;\n}\n\nvar version$1 = \"2.11.3\";\n\nconst version = version$1;\nconst protocolVersion = 15;\n\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */\nclass CriticalTimers {}\nCriticalTimers.setTimeout = function () {\n  return setTimeout(...arguments);\n};\nCriticalTimers.setInterval =\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nfunction () {\n  return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function () {\n  return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function () {\n  return clearInterval(...arguments);\n};\n\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nvar VideoQuality;\n(function (VideoQuality) {\n  VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n  VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n  VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n  constructor(mediaTrack, kind) {\n    let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a;\n    super();\n    this.attachedElements = [];\n    this.isMuted = false;\n    /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */\n    this.streamState = Track.StreamState.Active;\n    this.isInBackground = false;\n    this._currentBitrate = 0;\n    this.log = livekitLogger;\n    this.appVisibilityChangedListener = () => {\n      if (this.backgroundTimeout) {\n        clearTimeout(this.backgroundTimeout);\n      }\n      // delay app visibility update if it goes to hidden\n      // update immediately if it comes back to focus\n      if (document.visibilityState === 'hidden') {\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n      } else {\n        this.handleAppVisibilityChanged();\n      }\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n    this.loggerContextCb = loggerOptions.loggerContextCb;\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this._mediaStreamTrack = mediaTrack;\n    this._mediaStreamID = mediaTrack.id;\n    this.source = Track.Source.Unknown;\n  }\n  get logContext() {\n    var _a;\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n  }\n  /** current receive bits per second */\n  get currentBitrate() {\n    return this._currentBitrate;\n  }\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */\n  get mediaStreamID() {\n    return this._mediaStreamID;\n  }\n  attach(element) {\n    let elementType = 'audio';\n    if (this.kind === Track.Kind.Video) {\n      elementType = 'video';\n    }\n    if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\n      this.addAppVisibilityListener();\n    }\n    if (!element) {\n      if (elementType === 'audio') {\n        recycledElements.forEach(e => {\n          if (e.parentElement === null && !element) {\n            element = e;\n          }\n        });\n        if (element) {\n          // remove it from pool\n          recycledElements.splice(recycledElements.indexOf(element), 1);\n        }\n      }\n      if (!element) {\n        element = document.createElement(elementType);\n      }\n    }\n    if (!this.attachedElements.includes(element)) {\n      this.attachedElements.push(element);\n    }\n    // even if we believe it's already attached to the element, it's possible\n    // the element's srcObject was set to something else out of band.\n    // we'll want to re-attach it in that case\n    attachToElement(this.mediaStreamTrack, element);\n    // handle auto playback failures\n    const allMediaStreamTracks = element.srcObject.getTracks();\n    const hasAudio = allMediaStreamTracks.some(tr => tr.kind === 'audio');\n    // manually play media to detect auto playback status\n    element.play().then(() => {\n      this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n    }).catch(e => {\n      if (e.name === 'NotAllowedError') {\n        this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n      } else if (e.name === 'AbortError') {\n        // commonly triggered by another `play` request, only log for debugging purposes\n        livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\n      } else {\n        livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\n      }\n      // If audio playback isn't allowed make sure we still play back the video\n      if (hasAudio && element && allMediaStreamTracks.some(tr => tr.kind === 'video') && e.name === 'NotAllowedError') {\n        element.muted = true;\n        element.play().catch(() => {\n          // catch for Safari, exceeded options at this point to automatically play the media element\n        });\n      }\n    });\n    this.emit(TrackEvent.ElementAttached, element);\n    return element;\n  }\n  detach(element) {\n    try {\n      // detach from a single element\n      if (element) {\n        detachTrack(this.mediaStreamTrack, element);\n        const idx = this.attachedElements.indexOf(element);\n        if (idx >= 0) {\n          this.attachedElements.splice(idx, 1);\n          this.recycleElement(element);\n          this.emit(TrackEvent.ElementDetached, element);\n        }\n        return element;\n      }\n      const detached = [];\n      this.attachedElements.forEach(elm => {\n        detachTrack(this.mediaStreamTrack, elm);\n        detached.push(elm);\n        this.recycleElement(elm);\n        this.emit(TrackEvent.ElementDetached, elm);\n      });\n      // remove all tracks\n      this.attachedElements = [];\n      return detached;\n    } finally {\n      if (this.attachedElements.length === 0) {\n        this.removeAppVisibilityListener();\n      }\n    }\n  }\n  stop() {\n    this.stopMonitor();\n    this._mediaStreamTrack.stop();\n  }\n  enable() {\n    this._mediaStreamTrack.enabled = true;\n  }\n  disable() {\n    this._mediaStreamTrack.enabled = false;\n  }\n  /* @internal */\n  stopMonitor() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n    if (this.timeSyncHandle) {\n      cancelAnimationFrame(this.timeSyncHandle);\n    }\n  }\n  /** @internal */\n  updateLoggerOptions(loggerOptions) {\n    if (loggerOptions.loggerName) {\n      this.log = getLogger(loggerOptions.loggerName);\n    }\n    if (loggerOptions.loggerContextCb) {\n      this.loggerContextCb = loggerOptions.loggerContextCb;\n    }\n  }\n  recycleElement(element) {\n    if (element instanceof HTMLAudioElement) {\n      // we only need to re-use a single element\n      let shouldCache = true;\n      element.pause();\n      recycledElements.forEach(e => {\n        if (!e.parentElement) {\n          shouldCache = false;\n        }\n      });\n      if (shouldCache) {\n        recycledElements.push(element);\n      }\n    }\n  }\n  handleAppVisibilityChanged() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isInBackground = document.visibilityState === 'hidden';\n      if (!this.isInBackground && this.kind === Track.Kind.Video) {\n        setTimeout(() => this.attachedElements.forEach(el => el.play().catch(() => {\n          /** catch clause necessary for Safari */\n        })), 0);\n      }\n    });\n  }\n  addAppVisibilityListener() {\n    if (isWeb()) {\n      this.isInBackground = document.visibilityState === 'hidden';\n      document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\n    } else {\n      this.isInBackground = false;\n    }\n  }\n  removeAppVisibilityListener() {\n    if (isWeb()) {\n      document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\n    }\n  }\n}\nfunction attachToElement(track, element) {\n  let mediaStream;\n  if (element.srcObject instanceof MediaStream) {\n    mediaStream = element.srcObject;\n  } else {\n    mediaStream = new MediaStream();\n  }\n  // check if track matches existing track\n  let existingTracks;\n  if (track.kind === 'audio') {\n    existingTracks = mediaStream.getAudioTracks();\n  } else {\n    existingTracks = mediaStream.getVideoTracks();\n  }\n  if (!existingTracks.includes(track)) {\n    existingTracks.forEach(et => {\n      mediaStream.removeTrack(et);\n    });\n    mediaStream.addTrack(track);\n  }\n  if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n    // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n    // when a video starts that has the `autoplay` attribute is set.\n    // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n    element.autoplay = true;\n  }\n  // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n  element.muted = mediaStream.getAudioTracks().length === 0;\n  if (element instanceof HTMLVideoElement) {\n    element.playsInline = true;\n  }\n  // avoid flicker\n  if (element.srcObject !== mediaStream) {\n    element.srcObject = mediaStream;\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n      // Firefox also has a timing issue where video doesn't actually get attached unless\n      // performed out-of-band\n      // Safari 15 has a bug where in certain layouts, video element renders\n      // black until the page is resized or other changes take place.\n      // Resetting the src triggers it to render.\n      // https://developer.apple.com/forums/thread/690523\n      setTimeout(() => {\n        element.srcObject = mediaStream;\n        // Safari 15 sometimes fails to start a video\n        // when the window is backgrounded before the first frame is drawn\n        // manually calling play here seems to fix that\n        element.play().catch(() => {\n          /** do nothing */\n        });\n      }, 0);\n    }\n  }\n}\n/** @internal */\nfunction detachTrack(track, element) {\n  if (element.srcObject instanceof MediaStream) {\n    const mediaStream = element.srcObject;\n    mediaStream.removeTrack(track);\n    if (mediaStream.getTracks().length > 0) {\n      element.srcObject = mediaStream;\n    } else {\n      element.srcObject = null;\n    }\n  }\n}\n(function (Track) {\n  let Kind;\n  (function (Kind) {\n    Kind[\"Audio\"] = \"audio\";\n    Kind[\"Video\"] = \"video\";\n    Kind[\"Unknown\"] = \"unknown\";\n  })(Kind = Track.Kind || (Track.Kind = {}));\n  let Source;\n  (function (Source) {\n    Source[\"Camera\"] = \"camera\";\n    Source[\"Microphone\"] = \"microphone\";\n    Source[\"ScreenShare\"] = \"screen_share\";\n    Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n    Source[\"Unknown\"] = \"unknown\";\n  })(Source = Track.Source || (Track.Source = {}));\n  let StreamState$1;\n  (function (StreamState) {\n    StreamState[\"Active\"] = \"active\";\n    StreamState[\"Paused\"] = \"paused\";\n    StreamState[\"Unknown\"] = \"unknown\";\n  })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n  /** @internal */\n  function kindToProto(k) {\n    switch (k) {\n      case Kind.Audio:\n        return TrackType.AUDIO;\n      case Kind.Video:\n        return TrackType.VIDEO;\n      default:\n        // FIXME this was UNRECOGNIZED before\n        return TrackType.DATA;\n    }\n  }\n  Track.kindToProto = kindToProto;\n  /** @internal */\n  function kindFromProto(t) {\n    switch (t) {\n      case TrackType.AUDIO:\n        return Kind.Audio;\n      case TrackType.VIDEO:\n        return Kind.Video;\n      default:\n        return Kind.Unknown;\n    }\n  }\n  Track.kindFromProto = kindFromProto;\n  /** @internal */\n  function sourceToProto(s) {\n    switch (s) {\n      case Source.Camera:\n        return TrackSource.CAMERA;\n      case Source.Microphone:\n        return TrackSource.MICROPHONE;\n      case Source.ScreenShare:\n        return TrackSource.SCREEN_SHARE;\n      case Source.ScreenShareAudio:\n        return TrackSource.SCREEN_SHARE_AUDIO;\n      default:\n        return TrackSource.UNKNOWN;\n    }\n  }\n  Track.sourceToProto = sourceToProto;\n  /** @internal */\n  function sourceFromProto(s) {\n    switch (s) {\n      case TrackSource.CAMERA:\n        return Source.Camera;\n      case TrackSource.MICROPHONE:\n        return Source.Microphone;\n      case TrackSource.SCREEN_SHARE:\n        return Source.ScreenShare;\n      case TrackSource.SCREEN_SHARE_AUDIO:\n        return Source.ScreenShareAudio;\n      default:\n        return Source.Unknown;\n    }\n  }\n  Track.sourceFromProto = sourceFromProto;\n  /** @internal */\n  function streamStateFromProto(s) {\n    switch (s) {\n      case StreamState.ACTIVE:\n        return StreamState$1.Active;\n      case StreamState.PAUSED:\n        return StreamState$1.Paused;\n      default:\n        return StreamState$1.Unknown;\n    }\n  }\n  Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\n\nclass VideoPreset {\n  constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {\n    if (typeof widthOrOptions === 'object') {\n      this.width = widthOrOptions.width;\n      this.height = widthOrOptions.height;\n      this.aspectRatio = widthOrOptions.aspectRatio;\n      this.encoding = {\n        maxBitrate: widthOrOptions.maxBitrate,\n        maxFramerate: widthOrOptions.maxFramerate,\n        priority: widthOrOptions.priority\n      };\n    } else if (height !== undefined && maxBitrate !== undefined) {\n      this.width = widthOrOptions;\n      this.height = height;\n      this.aspectRatio = widthOrOptions / height;\n      this.encoding = {\n        maxBitrate,\n        maxFramerate,\n        priority\n      };\n    } else {\n      throw new TypeError('Unsupported options: provide at least width, height and maxBitrate');\n    }\n  }\n  get resolution() {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.encoding.maxFramerate,\n      aspectRatio: this.aspectRatio\n    };\n  }\n}\nconst backupCodecs = ['vp8', 'h264'];\nconst videoCodecs = ['vp8', 'h264', 'vp9', 'av1'];\nfunction isBackupCodec(codec) {\n  return !!backupCodecs.find(backup => backup === codec);\n}\nvar BackupCodecPolicy;\n(function (BackupCodecPolicy) {\n  // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\n  BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\n  // multi-codec simulcast, publish both primary and backup codec at the same time\n  BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\n  // always use backup codec only\n  BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\nvar AudioPresets;\n(function (AudioPresets) {\n  AudioPresets.telephone = {\n    maxBitrate: 12000\n  };\n  AudioPresets.speech = {\n    maxBitrate: 24000\n  };\n  AudioPresets.music = {\n    maxBitrate: 48000\n  };\n  AudioPresets.musicStereo = {\n    maxBitrate: 64000\n  };\n  AudioPresets.musicHighQuality = {\n    maxBitrate: 96000\n  };\n  AudioPresets.musicHighQualityStereo = {\n    maxBitrate: 128000\n  };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */\nconst VideoPresets = {\n  h90: new VideoPreset(160, 90, 90000, 20),\n  h180: new VideoPreset(320, 180, 160000, 20),\n  h216: new VideoPreset(384, 216, 180000, 20),\n  h360: new VideoPreset(640, 360, 450000, 20),\n  h540: new VideoPreset(960, 540, 800000, 25),\n  h720: new VideoPreset(1280, 720, 1700000, 30),\n  h1080: new VideoPreset(1920, 1080, 3000000, 30),\n  h1440: new VideoPreset(2560, 1440, 5000000, 30),\n  h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */\nconst VideoPresets43 = {\n  h120: new VideoPreset(160, 120, 70000, 20),\n  h180: new VideoPreset(240, 180, 125000, 20),\n  h240: new VideoPreset(320, 240, 140000, 20),\n  h360: new VideoPreset(480, 360, 330000, 20),\n  h480: new VideoPreset(640, 480, 500000, 20),\n  h540: new VideoPreset(720, 540, 600000, 25),\n  h720: new VideoPreset(960, 720, 1300000, 30),\n  h1080: new VideoPreset(1440, 1080, 2300000, 30),\n  h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n  h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\n  h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\n  h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\n  h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\n  h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\n  h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\n  h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\n  // original resolution, without resizing\n  original: new VideoPreset(0, 0, 7000000, 30, 'medium')\n};\n\nconst separator = '|';\nconst ddExtensionURI = 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';\nfunction unpackStreamId(packed) {\n  const parts = packed.split(separator);\n  if (parts.length > 1) {\n    return [parts[0], packed.substr(parts[0].length + 1)];\n  }\n  return [packed, ''];\n}\nfunction sleep(duration) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise(resolve => CriticalTimers.setTimeout(resolve, duration));\n  });\n}\n/** @internal */\nfunction supportsTransceiver() {\n  return 'addTransceiver' in RTCPeerConnection.prototype;\n}\n/** @internal */\nfunction supportsAddTrack() {\n  return 'addTrack' in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n  return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n  return supportsTransceiver();\n}\nfunction supportsAV1() {\n  if (!('getCapabilities' in RTCRtpSender)) {\n    return false;\n  }\n  if (isSafari()) {\n    // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n    return false;\n  }\n  const capabilities = RTCRtpSender.getCapabilities('video');\n  let hasAV1 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType === 'video/AV1') {\n        hasAV1 = true;\n        break;\n      }\n    }\n  }\n  return hasAV1;\n}\nfunction supportsVP9() {\n  if (!('getCapabilities' in RTCRtpSender)) {\n    return false;\n  }\n  if (isFireFox()) {\n    // technically speaking FireFox supports VP9, but SVC publishing is broken\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n    return false;\n  }\n  if (isSafari()) {\n    const browser = getBrowser();\n    if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, '16') < 0) {\n      // Safari 16 and below does not support VP9\n      return false;\n    }\n  }\n  const capabilities = RTCRtpSender.getCapabilities('video');\n  let hasVP9 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType === 'video/VP9') {\n        hasVP9 = true;\n        break;\n      }\n    }\n  }\n  return hasVP9;\n}\nfunction isSVCCodec(codec) {\n  return codec === 'av1' || codec === 'vp9';\n}\nfunction supportsSetSinkId(elm) {\n  if (!document) {\n    return false;\n  }\n  if (!elm) {\n    elm = document.createElement('audio');\n  }\n  return 'setSinkId' in elm;\n}\nfunction isBrowserSupported() {\n  if (typeof RTCPeerConnection === 'undefined') {\n    return false;\n  }\n  return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n  var _a;\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\n}\nfunction isSafari() {\n  var _a;\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\n}\nfunction isSafari17() {\n  const b = getBrowser();\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' && b.version.startsWith('17.');\n}\nfunction isMobile() {\n  var _a, _b;\n  if (!isWeb()) return false;\n  return (\n    // @ts-expect-error `userAgentData` is not yet part of typescript\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)\n  );\n}\nfunction isE2EESimulcastSupported() {\n  const browser = getBrowser();\n  const supportedSafariVersion = '17.2'; // see https://bugs.webkit.org/show_bug.cgi?id=257803\n  if (browser) {\n    if (browser.name !== 'Safari' && browser.os !== 'iOS') {\n      return true;\n    } else if (browser.os === 'iOS' && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {\n      return true;\n    } else if (browser.name === 'Safari' && compareVersions(supportedSafariVersion, browser.version) >= 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\nfunction isWeb() {\n  return typeof document !== 'undefined';\n}\nfunction isReactNative() {\n  // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n  return navigator.product == 'ReactNative';\n}\nfunction isCloud(serverUrl) {\n  return serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run');\n}\nfunction getLKReactNativeInfo() {\n  // global defined only for ReactNative.\n  // @ts-ignore\n  if (global && global.LiveKitReactNativeGlobal) {\n    // @ts-ignore\n    return global.LiveKitReactNativeGlobal;\n  }\n  return undefined;\n}\nfunction getReactNativeOs() {\n  if (!isReactNative()) {\n    return undefined;\n  }\n  let info = getLKReactNativeInfo();\n  if (info) {\n    return info.platform;\n  }\n  return undefined;\n}\nfunction getDevicePixelRatio() {\n  if (isWeb()) {\n    return window.devicePixelRatio;\n  }\n  if (isReactNative()) {\n    let info = getLKReactNativeInfo();\n    if (info) {\n      return info.devicePixelRatio;\n    }\n  }\n  return 1;\n}\nfunction compareVersions(v1, v2) {\n  const parts1 = v1.split('.');\n  const parts2 = v2.split('.');\n  const k = Math.min(parts1.length, parts2.length);\n  for (let i = 0; i < k; ++i) {\n    const p1 = parseInt(parts1[i], 10);\n    const p2 = parseInt(parts2[i], 10);\n    if (p1 > p2) return 1;\n    if (p1 < p2) return -1;\n    if (i === k - 1 && p1 === p2) return 0;\n  }\n  if (v1 === '' && v2 !== '') {\n    return -1;\n  } else if (v2 === '') {\n    return 1;\n  }\n  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleResize(entry);\n  }\n}\nfunction ioDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleVisibilityChanged(entry);\n  }\n}\nlet resizeObserver = null;\nconst getResizeObserver = () => {\n  if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n  return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = () => {\n  if (!intersectionObserver) {\n    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n      root: null,\n      rootMargin: '0px'\n    });\n  }\n  return intersectionObserver;\n};\nfunction getClientInfo() {\n  var _a;\n  const info = new ClientInfo({\n    sdk: ClientInfo_SDK.JS,\n    protocol: protocolVersion,\n    version\n  });\n  if (isReactNative()) {\n    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';\n  }\n  return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n  if (!emptyVideoStreamTrack) {\n    emptyVideoStreamTrack = createDummyVideoStreamTrack();\n  }\n  return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n  let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n  let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const canvas = document.createElement('canvas');\n  // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n  if (paintContent && ctx) {\n    ctx.beginPath();\n    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fillStyle = 'grey';\n    ctx.fill();\n  }\n  // @ts-ignore\n  const dummyStream = canvas.captureStream();\n  const [dummyTrack] = dummyStream.getTracks();\n  if (!dummyTrack) {\n    throw Error('Could not get empty media stream video track');\n  }\n  dummyTrack.enabled = enabled;\n  return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n  if (!emptyAudioStreamTrack) {\n    // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n    const ctx = new AudioContext();\n    const oscillator = ctx.createOscillator();\n    const gain = ctx.createGain();\n    gain.gain.setValueAtTime(0, 0);\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(gain);\n    gain.connect(dst);\n    oscillator.start();\n    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n    if (!emptyAudioStreamTrack) {\n      throw Error('Could not get empty media stream audio track');\n    }\n    emptyAudioStreamTrack.enabled = false;\n  }\n  return emptyAudioStreamTrack.clone();\n}\nclass Future {\n  constructor(futureBase, onFinally) {\n    this.onFinally = onFinally;\n    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      this.resolve = resolve;\n      this.reject = reject;\n      if (futureBase) {\n        yield futureBase(resolve, reject);\n      }\n    })).finally(() => {\n      var _a;\n      return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n    });\n  }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */\nfunction createAudioAnalyser(track, options) {\n  const opts = Object.assign({\n    cloneTrack: false,\n    fftSize: 2048,\n    smoothingTimeConstant: 0.8,\n    minDecibels: -100,\n    maxDecibels: -80\n  }, options);\n  const audioContext = getNewAudioContext();\n  if (!audioContext) {\n    throw new Error('Audio Context not supported on this browser');\n  }\n  const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n  const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));\n  const analyser = audioContext.createAnalyser();\n  analyser.minDecibels = opts.minDecibels;\n  analyser.maxDecibels = opts.maxDecibels;\n  analyser.fftSize = opts.fftSize;\n  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n  mediaStreamSource.connect(analyser);\n  const dataArray = new Uint8Array(analyser.frequencyBinCount);\n  /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */\n  const calculateVolume = () => {\n    analyser.getByteFrequencyData(dataArray);\n    let sum = 0;\n    for (const amplitude of dataArray) {\n      sum += Math.pow(amplitude / 255, 2);\n    }\n    const volume = Math.sqrt(sum / dataArray.length);\n    return volume;\n  };\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n    yield audioContext.close();\n    if (opts.cloneTrack) {\n      streamTrack.stop();\n    }\n  });\n  return {\n    calculateVolume,\n    analyser,\n    cleanup\n  };\n}\nfunction isVideoCodec(maybeCodec) {\n  return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n  if (typeof constraint === 'string' || typeof constraint === 'number') {\n    return constraint;\n  }\n  if (Array.isArray(constraint)) {\n    return constraint[0];\n  }\n  if (constraint.exact) {\n    if (Array.isArray(constraint.exact)) {\n      return constraint.exact[0];\n    }\n    return constraint.exact;\n  }\n  if (constraint.ideal) {\n    if (Array.isArray(constraint.ideal)) {\n      return constraint.ideal[0];\n    }\n    return constraint.ideal;\n  }\n  throw Error('could not unwrap constraint');\n}\nfunction toWebsocketUrl(url) {\n  if (url.startsWith('http')) {\n    return url.replace(/^(http)/, 'ws');\n  }\n  return url;\n}\nfunction toHttpUrl(url) {\n  if (url.startsWith('ws')) {\n    return url.replace(/^(ws)/, 'http');\n  }\n  return url;\n}\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\n  return transcription.segments.map(_ref => {\n    let {\n      id,\n      text,\n      language,\n      startTime,\n      endTime,\n      final\n    } = _ref;\n    var _a;\n    const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\n    const lastReceivedTime = Date.now();\n    if (final) {\n      firstReceivedTimesMap.delete(id);\n    } else {\n      firstReceivedTimesMap.set(id, firstReceivedTime);\n    }\n    return {\n      id,\n      text,\n      startTime: Number.parseInt(startTime.toString()),\n      endTime: Number.parseInt(endTime.toString()),\n      final,\n      language,\n      firstReceivedTime,\n      lastReceivedTime\n    };\n  });\n}\nfunction extractChatMessage(msg) {\n  const {\n    id,\n    timestamp,\n    message,\n    editTimestamp\n  } = msg;\n  return {\n    id,\n    timestamp: Number.parseInt(timestamp.toString()),\n    editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\n    message\n  };\n}\nfunction getDisconnectReasonFromConnectionError(e) {\n  switch (e.reason) {\n    case ConnectionErrorReason.LeaveRequest:\n      return e.context;\n    case ConnectionErrorReason.Cancelled:\n      return DisconnectReason.CLIENT_INITIATED;\n    case ConnectionErrorReason.NotAllowed:\n      return DisconnectReason.USER_REJECTED;\n    case ConnectionErrorReason.ServerUnreachable:\n      return DisconnectReason.JOIN_FAILURE;\n    default:\n      return DisconnectReason.UNKNOWN_REASON;\n  }\n}\n/** convert bigints to numbers preserving undefined values */\nfunction bigIntToNumber(value) {\n  return value !== undefined ? Number(value) : undefined;\n}\n/** convert numbers to bigints preserving undefined values */\nfunction numberToBigInt(value) {\n  return value !== undefined ? BigInt(value) : undefined;\n}\nfunction isLocalTrack(track) {\n  return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\n}\nfunction isAudioTrack(track) {\n  return !!track && track.kind == Track.Kind.Audio;\n}\nfunction isVideoTrack(track) {\n  return !!track && track.kind == Track.Kind.Video;\n}\nfunction isLocalVideoTrack(track) {\n  return isLocalTrack(track) && isVideoTrack(track);\n}\nfunction isLocalAudioTrack(track) {\n  return isLocalTrack(track) && isAudioTrack(track);\n}\nfunction isRemoteTrack(track) {\n  return !!track && !track.isLocal;\n}\nfunction isRemotePub(pub) {\n  return !!pub && !pub.isLocal;\n}\nfunction isRemoteVideoTrack(track) {\n  return isRemoteTrack(track) && isVideoTrack(track);\n}\nfunction isLocalParticipant(p) {\n  return p.isLocal;\n}\nfunction isRemoteParticipant(p) {\n  return !p.isLocal;\n}\nfunction splitUtf8(s, n) {\n  // adapted from https://stackoverflow.com/a/6043797\n  const result = [];\n  let encoded = new TextEncoder().encode(s);\n  while (encoded.length > n) {\n    let k = n;\n    while (k > 0) {\n      const byte = encoded[k];\n      if (byte !== undefined && (byte & 0xc0) !== 0x80) {\n        break;\n      }\n      k--;\n    }\n    result.push(encoded.slice(0, k));\n    encoded = encoded.slice(k);\n  }\n  if (encoded.length > 0) {\n    result.push(encoded);\n  }\n  return result;\n}\n\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n  var _a, _b;\n  var _c, _d;\n  const {\n    optionsWithoutProcessor,\n    audioProcessor,\n    videoProcessor\n  } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\n  const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\n  const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\n  const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};\n  if (clonedOptions.audio === true) clonedOptions.audio = {};\n  if (clonedOptions.video === true) clonedOptions.video = {};\n  // use defaults\n  if (clonedOptions.audio) {\n    mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\n    (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n      ideal: 'default'\n    };\n    if (audioProcessor || defaultAudioProcessor) {\n      clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\n    }\n  }\n  if (clonedOptions.video) {\n    mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\n    (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n      ideal: 'default'\n    };\n    if (videoProcessor || defaultVideoProcessor) {\n      clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\n    }\n  }\n  return clonedOptions;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n  Object.keys(objectToMerge).forEach(key => {\n    if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n  });\n  return mainObject;\n}\nfunction constraintsForOptions(options) {\n  var _a, _b;\n  var _c, _d;\n  const constraints = {};\n  if (options.video) {\n    // default video options\n    if (typeof options.video === 'object') {\n      const videoOptions = {};\n      const target = videoOptions;\n      const source = options.video;\n      Object.keys(source).forEach(key => {\n        switch (key) {\n          case 'resolution':\n            // flatten VideoResolution fields\n            mergeObjectWithoutOverwriting(target, source.resolution);\n            break;\n          default:\n            target[key] = source[key];\n        }\n      });\n      constraints.video = videoOptions;\n      (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n        ideal: 'default'\n      };\n    } else {\n      constraints.video = options.video ? {\n        deviceId: {\n          ideal: 'default'\n        }\n      } : false;\n    }\n  } else {\n    constraints.video = false;\n  }\n  if (options.audio) {\n    if (typeof options.audio === 'object') {\n      constraints.audio = options.audio;\n      (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n        ideal: 'default'\n      };\n    } else {\n      constraints.audio = {\n        deviceId: {\n          ideal: 'default'\n        }\n      };\n    }\n  } else {\n    constraints.audio = false;\n  }\n  return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */\nfunction detectSilence(track_1) {\n  return __awaiter(this, arguments, void 0, function (track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return function* () {\n      const ctx = getNewAudioContext();\n      if (ctx) {\n        const analyser = ctx.createAnalyser();\n        analyser.fftSize = 2048;\n        const bufferLength = analyser.frequencyBinCount;\n        const dataArray = new Uint8Array(bufferLength);\n        const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));\n        source.connect(analyser);\n        yield sleep(timeOffset);\n        analyser.getByteTimeDomainData(dataArray);\n        const someNoise = dataArray.some(sample => sample !== 128 && sample !== 0);\n        ctx.close();\n        return !someNoise;\n      }\n      return false;\n    }();\n  });\n}\n/**\n * @internal\n */\nfunction getNewAudioContext() {\n  var _a;\n  const AudioContext =\n  // @ts-ignore\n  typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n  if (AudioContext) {\n    const audioContext = new AudioContext({\n      latencyHint: 'interactive'\n    });\n    // If the audio context is suspended, we need to resume it when the user clicks on the page\n    if (audioContext.state === 'suspended' && typeof window !== 'undefined' && ((_a = window.document) === null || _a === void 0 ? void 0 : _a.body)) {\n      const handleResume = () => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n          if (audioContext.state === 'suspended') {\n            yield audioContext.resume();\n          }\n        } catch (e) {\n          console.warn('Error trying to auto-resume audio context', e);\n        }\n        (_a = window.document.body) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', handleResume);\n      });\n      window.document.body.addEventListener('click', handleResume);\n    }\n    return audioContext;\n  }\n}\n/**\n * @internal\n */\nfunction sourceToKind(source) {\n  if (source === Track.Source.Microphone) {\n    return 'audioinput';\n  } else if (source === Track.Source.Camera) {\n    return 'videoinput';\n  } else {\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nfunction screenCaptureToDisplayMediaStreamOptions(options) {\n  var _a, _b;\n  let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n  // treat 0 as uncapped\n  if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n    videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;\n    if (isSafari()) {\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n        width: {\n          max: options.resolution.width\n        },\n        height: {\n          max: options.resolution.height\n        },\n        frameRate: options.resolution.frameRate\n      });\n    } else {\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n        width: {\n          ideal: options.resolution.width\n        },\n        height: {\n          ideal: options.resolution.height\n        },\n        frameRate: options.resolution.frameRate\n      });\n    }\n  }\n  return {\n    audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n    video: videoConstraints,\n    // @ts-expect-error support for experimental display media features\n    controller: options.controller,\n    selfBrowserSurface: options.selfBrowserSurface,\n    surfaceSwitching: options.surfaceSwitching,\n    systemAudio: options.systemAudio,\n    preferCurrentTab: options.preferCurrentTab\n  };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n  return mimeType.split('/')[1].toLowerCase();\n}\nfunction getTrackPublicationInfo(tracks) {\n  const infos = [];\n  tracks.forEach(track => {\n    if (track.track !== undefined) {\n      infos.push(new TrackPublishedResponse({\n        cid: track.track.mediaStreamID,\n        track: track.trackInfo\n      }));\n    }\n  });\n  return infos;\n}\nfunction getLogContextFromTrack(track) {\n  if ('mediaStreamTrack' in track) {\n    return {\n      trackID: track.sid,\n      source: track.source,\n      muted: track.isMuted,\n      enabled: track.mediaStreamTrack.enabled,\n      kind: track.kind,\n      streamID: track.mediaStreamID,\n      streamTrackID: track.mediaStreamTrack.id\n    };\n  } else {\n    return {\n      trackID: track.trackSid,\n      enabled: track.isEnabled,\n      muted: track.isMuted,\n      trackInfo: Object.assign({\n        mimeType: track.mimeType,\n        name: track.trackName,\n        encrypted: track.isEncrypted,\n        kind: track.kind,\n        source: track.source\n      }, track.track ? getLogContextFromTrack(track.track) : {})\n    };\n  }\n}\nfunction supportsSynchronizationSources() {\n  return typeof RTCRtpReceiver !== 'undefined' && 'getSynchronizationSources' in RTCRtpReceiver;\n}\nfunction diffAttributes(oldValues, newValues) {\n  var _a;\n  if (oldValues === undefined) {\n    oldValues = {};\n  }\n  if (newValues === undefined) {\n    newValues = {};\n  }\n  const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];\n  const diff = {};\n  for (const key of allKeys) {\n    if (oldValues[key] !== newValues[key]) {\n      diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : '';\n    }\n  }\n  return diff;\n}\n/** @internal */\nfunction extractProcessorsFromOptions(options) {\n  const newOptions = Object.assign({}, options);\n  let audioProcessor;\n  let videoProcessor;\n  if (typeof newOptions.audio === 'object' && newOptions.audio.processor) {\n    audioProcessor = newOptions.audio.processor;\n    newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\n      processor: undefined\n    });\n  }\n  if (typeof newOptions.video === 'object' && newOptions.video.processor) {\n    videoProcessor = newOptions.video.processor;\n    newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\n      processor: undefined\n    });\n  }\n  return {\n    audioProcessor,\n    videoProcessor,\n    optionsWithoutProcessor: cloneDeep(newOptions)\n  };\n}\nfunction getTrackSourceFromProto(source) {\n  switch (source) {\n    case TrackSource.CAMERA:\n      return Track.Source.Camera;\n    case TrackSource.MICROPHONE:\n      return Track.Source.Microphone;\n    case TrackSource.SCREEN_SHARE:\n      return Track.Source.ScreenShare;\n    case TrackSource.SCREEN_SHARE_AUDIO:\n      return Track.Source.ScreenShareAudio;\n    default:\n      return Track.Source.Unknown;\n  }\n}\n\n/**\n * @experimental\n */\nclass E2EEManager extends eventsExports.EventEmitter {\n  constructor(options) {\n    super();\n    this.onWorkerMessage = ev => {\n      var _a, _b;\n      const {\n        kind,\n        data\n      } = ev.data;\n      switch (kind) {\n        case 'error':\n          livekitLogger.error(data.error.message);\n          this.emit(EncryptionEvent.EncryptionError, data.error);\n          break;\n        case 'initAck':\n          if (data.enabled) {\n            this.keyProvider.getKeys().forEach(keyInfo => {\n              this.postKey(keyInfo);\n            });\n          }\n          break;\n        case 'enable':\n          if (data.enabled) {\n            this.keyProvider.getKeys().forEach(keyInfo => {\n              this.postKey(keyInfo);\n            });\n          }\n          if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n            this.encryptionEnabled = data.enabled;\n          } else if (data.participantIdentity) {\n            const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n            if (!participant) {\n              throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n            }\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n          }\n          break;\n        case 'ratchetKey':\n          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n          break;\n      }\n    };\n    this.onWorkerError = ev => {\n      livekitLogger.error('e2ee worker encountered an error:', {\n        error: ev.error\n      });\n      this.emit(EncryptionEvent.EncryptionError, ev.error);\n    };\n    this.keyProvider = options.keyProvider;\n    this.worker = options.worker;\n    this.encryptionEnabled = false;\n  }\n  /**\n   * @internal\n   */\n  setup(room) {\n    if (!isE2EESupported()) {\n      throw new DeviceUnsupportedError('tried to setup end-to-end encryption on an unsupported browser');\n    }\n    livekitLogger.info('setting up e2ee');\n    if (room !== this.room) {\n      this.room = room;\n      this.setupEventListeners(room, this.keyProvider);\n      // this.worker = new Worker('');\n      const msg = {\n        kind: 'init',\n        data: {\n          keyProviderOptions: this.keyProvider.getOptions(),\n          loglevel: workerLogger.getLevel()\n        }\n      };\n      if (this.worker) {\n        livekitLogger.info(\"initializing worker\", {\n          worker: this.worker\n        });\n        this.worker.onmessage = this.onWorkerMessage;\n        this.worker.onerror = this.onWorkerError;\n        this.worker.postMessage(msg);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  setParticipantCryptorEnabled(enabled, participantIdentity) {\n    livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n    this.postEnable(enabled, participantIdentity);\n  }\n  /**\n   * @internal\n   */\n  setSifTrailer(trailer) {\n    if (!trailer || trailer.length === 0) {\n      livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n    } else {\n      this.postSifTrailer(trailer);\n    }\n  }\n  setupEngine(engine) {\n    engine.on(EngineEvent.RTPVideoMapUpdate, rtpMap => {\n      this.postRTPMap(rtpMap);\n    });\n  }\n  setupEventListeners(room, keyProvider) {\n    room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n    room.on(RoomEvent.ConnectionStateChanged, state => {\n      if (state === ConnectionState.Connected) {\n        room.remoteParticipants.forEach(participant => {\n          participant.trackPublications.forEach(pub => {\n            this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n          });\n        });\n      }\n    }).on(RoomEvent.TrackUnsubscribed, (track, _, participant) => {\n      var _a;\n      const msg = {\n        kind: 'removeTransform',\n        data: {\n          participantIdentity: participant.identity,\n          trackId: track.mediaStreamID\n        }\n      };\n      (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n    }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {\n      this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n    }).on(RoomEvent.SignalConnected, () => {\n      if (!this.room) {\n        throw new TypeError(\"expected room to be present on signal connect\");\n      }\n      keyProvider.getKeys().forEach(keyInfo => {\n        this.postKey(keyInfo);\n      });\n      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n    });\n    room.localParticipant.on(ParticipantEvent.LocalTrackPublished, publication => __awaiter(this, void 0, void 0, function* () {\n      this.setupE2EESender(publication.track, publication.track.sender);\n    }));\n    keyProvider.on(KeyProviderEvent.SetKey, keyInfo => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex, keyProvider.getOptions().allowKeyExtraction));\n  }\n  postRatchetRequest(participantIdentity, keyIndex, extractable) {\n    if (!this.worker) {\n      throw Error('could not ratchet key, worker is missing');\n    }\n    const msg = {\n      kind: 'ratchetRequest',\n      data: {\n        participantIdentity: participantIdentity,\n        keyIndex,\n        extractable\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  postKey(_ref) {\n    let {\n      key,\n      participantIdentity,\n      keyIndex\n    } = _ref;\n    var _a;\n    if (!this.worker) {\n      throw Error('could not set key, worker is missing');\n    }\n    const msg = {\n      kind: 'setKey',\n      data: {\n        participantIdentity: participantIdentity,\n        isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n        key,\n        keyIndex\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  postEnable(enabled, participantIdentity) {\n    if (this.worker) {\n      const enableMsg = {\n        kind: 'enable',\n        data: {\n          enabled,\n          participantIdentity\n        }\n      };\n      this.worker.postMessage(enableMsg);\n    } else {\n      throw new ReferenceError('failed to enable e2ee, worker is not ready');\n    }\n  }\n  postRTPMap(map) {\n    var _a;\n    if (!this.worker) {\n      throw TypeError('could not post rtp map, worker is missing');\n    }\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n      throw TypeError('could not post rtp map, local participant identity is missing');\n    }\n    const msg = {\n      kind: 'setRTPMap',\n      data: {\n        map,\n        participantIdentity: this.room.localParticipant.identity\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  postSifTrailer(trailer) {\n    if (!this.worker) {\n      throw Error('could not post SIF trailer, worker is missing');\n    }\n    const msg = {\n      kind: 'setSifTrailer',\n      data: {\n        trailer\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  setupE2EEReceiver(track, remoteId, trackInfo) {\n    if (!track.receiver) {\n      return;\n    }\n    if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === '') {\n      throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');\n    }\n    this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n  }\n  setupE2EESender(track, sender) {\n    if (!isLocalTrack(track) || !sender) {\n      if (!sender) livekitLogger.warn('early return because sender is not ready');\n      return;\n    }\n    this.handleSender(sender, track.mediaStreamID, undefined);\n  }\n  /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */\n  handleReceiver(receiver, trackId, participantIdentity, codec) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.worker) {\n        return;\n      }\n      if (isScriptTransformSupported()) {\n        const options = {\n          kind: 'decode',\n          participantIdentity,\n          trackId,\n          codec\n        };\n        // @ts-ignore\n        receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n      } else {\n        if (E2EE_FLAG in receiver && codec) {\n          // only update codec\n          const msg = {\n            kind: 'updateCodec',\n            data: {\n              trackId,\n              codec,\n              participantIdentity: participantIdentity\n            }\n          };\n          this.worker.postMessage(msg);\n          return;\n        }\n        // @ts-ignore\n        let writable = receiver.writableStream;\n        // @ts-ignore\n        let readable = receiver.readableStream;\n        if (!writable || !readable) {\n          // @ts-ignore\n          const receiverStreams = receiver.createEncodedStreams();\n          // @ts-ignore\n          receiver.writableStream = receiverStreams.writable;\n          writable = receiverStreams.writable;\n          // @ts-ignore\n          receiver.readableStream = receiverStreams.readable;\n          readable = receiverStreams.readable;\n        }\n        const msg = {\n          kind: 'decode',\n          data: {\n            readableStream: readable,\n            writableStream: writable,\n            trackId: trackId,\n            codec,\n            participantIdentity: participantIdentity\n          }\n        };\n        this.worker.postMessage(msg, [readable, writable]);\n      }\n      // @ts-ignore\n      receiver[E2EE_FLAG] = true;\n    });\n  }\n  /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */\n  handleSender(sender, trackId, codec) {\n    var _a;\n    if (E2EE_FLAG in sender || !this.worker) {\n      return;\n    }\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === '') {\n      throw TypeError('local identity needs to be known in order to set up encrypted sender');\n    }\n    if (isScriptTransformSupported()) {\n      livekitLogger.info('initialize script transform');\n      const options = {\n        kind: 'encode',\n        participantIdentity: this.room.localParticipant.identity,\n        trackId,\n        codec\n      };\n      // @ts-ignore\n      sender.transform = new RTCRtpScriptTransform(this.worker, options);\n    } else {\n      livekitLogger.info('initialize encoded streams');\n      // @ts-ignore\n      const senderStreams = sender.createEncodedStreams();\n      const msg = {\n        kind: 'encode',\n        data: {\n          readableStream: senderStreams.readable,\n          writableStream: senderStreams.writable,\n          codec,\n          trackId,\n          participantIdentity: this.room.localParticipant.identity\n        }\n      };\n      this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);\n    }\n    // @ts-ignore\n    sender[E2EE_FLAG] = true;\n  }\n}\n\nconst defaultId = 'default';\nclass DeviceManager {\n  constructor() {\n    this._previousDevices = [];\n  }\n  static getInstance() {\n    if (this.instance === undefined) {\n      this.instance = new DeviceManager();\n    }\n    return this.instance;\n  }\n  get previousDevices() {\n    return this._previousDevices;\n  }\n  getDevices(kind_1) {\n    return __awaiter(this, arguments, void 0, function (kind) {\n      var _this = this;\n      let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        var _a;\n        if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n          livekitLogger.debug('awaiting getUserMedia promise');\n          try {\n            if (kind) {\n              yield DeviceManager.userMediaPromiseMap.get(kind);\n            } else {\n              yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n            }\n          } catch (e) {\n            livekitLogger.warn('error waiting for media permissons');\n          }\n        }\n        let devices = yield navigator.mediaDevices.enumerateDevices();\n        if (requestPermissions &&\n        // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n        !(isSafari() && _this.hasDeviceInUse(kind))) {\n          const isDummyDeviceOrEmpty = devices.filter(d => d.kind === kind).length === 0 || devices.some(device => {\n            const noLabel = device.label === '';\n            const isRelevant = kind ? device.kind === kind : true;\n            return noLabel && isRelevant;\n          });\n          if (isDummyDeviceOrEmpty) {\n            const permissionsToAcquire = {\n              video: kind !== 'audioinput' && kind !== 'audiooutput',\n              audio: kind !== 'videoinput' && {\n                deviceId: {\n                  ideal: 'default'\n                }\n              }\n            };\n            const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n            devices = yield navigator.mediaDevices.enumerateDevices();\n            stream.getTracks().forEach(track => {\n              track.stop();\n            });\n          }\n        }\n        _this._previousDevices = devices;\n        if (kind) {\n          devices = devices.filter(device => device.kind === kind);\n        }\n        return devices;\n      }();\n    });\n  }\n  normalizeDeviceId(kind, deviceId, groupId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (deviceId !== defaultId) {\n        return deviceId;\n      }\n      // resolve actual device id if it's 'default': Chrome returns it when no\n      // device has been chosen\n      const devices = yield this.getDevices(kind);\n      const defaultDevice = devices.find(d => d.deviceId === defaultId);\n      if (!defaultDevice) {\n        livekitLogger.warn('could not reliably determine default device');\n        return undefined;\n      }\n      const device = devices.find(d => d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\n      if (!device) {\n        livekitLogger.warn('could not reliably determine default device');\n        return undefined;\n      }\n      return device === null || device === void 0 ? void 0 : device.deviceId;\n    });\n  }\n  hasDeviceInUse(kind) {\n    return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n  }\n}\nDeviceManager.mediaDeviceKinds = ['audioinput', 'audiooutput', 'videoinput'];\nDeviceManager.userMediaPromiseMap = new Map();\n\nvar QueueTaskStatus;\n(function (QueueTaskStatus) {\n  QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n  QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n  QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n  constructor() {\n    this.pendingTasks = new Map();\n    this.taskMutex = new _();\n    this.nextTaskIndex = 0;\n  }\n  run(task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskInfo = {\n        id: this.nextTaskIndex++,\n        enqueuedAt: Date.now(),\n        status: QueueTaskStatus.WAITING\n      };\n      this.pendingTasks.set(taskInfo.id, taskInfo);\n      const unlock = yield this.taskMutex.lock();\n      try {\n        taskInfo.executedAt = Date.now();\n        taskInfo.status = QueueTaskStatus.RUNNING;\n        return yield task();\n      } finally {\n        taskInfo.status = QueueTaskStatus.COMPLETED;\n        this.pendingTasks.delete(taskInfo.id);\n        unlock();\n      }\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {}));\n    });\n  }\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n}\n\nfunction createRtcUrl(url, searchParams) {\n  const urlObj = new URL(toWebsocketUrl(url));\n  searchParams.forEach((value, key) => {\n    urlObj.searchParams.set(key, value);\n  });\n  return appendUrlPath(urlObj, 'rtc');\n}\nfunction createValidateUrl(rtcWsUrl) {\n  const urlObj = new URL(toHttpUrl(rtcWsUrl));\n  return appendUrlPath(urlObj, 'validate');\n}\nfunction ensureTrailingSlash(path) {\n  return path.endsWith('/') ? path : \"\".concat(path, \"/\");\n}\nfunction appendUrlPath(urlObj, path) {\n  urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\n  return urlObj.toString();\n}\n\nconst passThroughQueueSignals = ['syncState', 'trickle', 'offer', 'answer', 'simulate', 'leave'];\nfunction canPassThroughQueue(req) {\n  const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n  livekitLogger.trace('request allowed to bypass queue:', {\n    canPass,\n    req\n  });\n  return canPass;\n}\nvar SignalConnectionState;\n(function (SignalConnectionState) {\n  SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n  SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */\nclass SignalClient {\n  get currentState() {\n    return this.state;\n  }\n  get isDisconnected() {\n    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n  }\n  get isEstablishingConnection() {\n    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n  }\n  getNextRequestId() {\n    this._requestId += 1;\n    return this._requestId;\n  }\n  constructor() {\n    let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    /** signal rtt in milliseconds */\n    this.rtt = 0;\n    this.state = SignalConnectionState.DISCONNECTED;\n    this.log = livekitLogger;\n    this._requestId = 0;\n    /** @internal */\n    this.resetCallbacks = () => {\n      this.onAnswer = undefined;\n      this.onLeave = undefined;\n      this.onLocalTrackPublished = undefined;\n      this.onLocalTrackUnpublished = undefined;\n      this.onNegotiateRequested = undefined;\n      this.onOffer = undefined;\n      this.onRemoteMuteChanged = undefined;\n      this.onSubscribedQualityUpdate = undefined;\n      this.onTokenRefresh = undefined;\n      this.onTrickle = undefined;\n      this.onClose = undefined;\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n    this.loggerContextCb = loggerOptions.loggerContextCb;\n    this.useJSON = useJSON;\n    this.requestQueue = new AsyncQueue();\n    this.queuedRequests = [];\n    this.closingLock = new _();\n    this.connectionLock = new _();\n    this.state = SignalConnectionState.DISCONNECTED;\n  }\n  get logContext() {\n    var _a, _b;\n    return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // during a full reconnect, we'd want to start the sequence even if currently\n      // connected\n      this.state = SignalConnectionState.CONNECTING;\n      this.options = opts;\n      const res = yield this.connect(url, token, opts, abortSignal);\n      return res;\n    });\n  }\n  reconnect(url, token, sid, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.options) {\n        this.log.warn('attempted to reconnect without signal options being set, ignoring', this.logContext);\n        return;\n      }\n      this.state = SignalConnectionState.RECONNECTING;\n      // clear ping interval and restart it once reconnected\n      this.clearPingInterval();\n      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n        reconnect: true,\n        sid,\n        reconnectReason: reason\n      }));\n      return res;\n    });\n  }\n  connect(url, token, opts, abortSignal) {\n    this.connectOptions = opts;\n    const clientInfo = getClientInfo();\n    const params = createConnectionParams(token, clientInfo, opts);\n    const rtcUrl = createRtcUrl(url, params);\n    const validateUrl = createValidateUrl(rtcUrl);\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.connectionLock.lock();\n      try {\n        const abortHandler = () => __awaiter(this, void 0, void 0, function* () {\n          this.close();\n          clearTimeout(wsTimeout);\n          reject(new ConnectionError('room connection has been cancelled (signal)', ConnectionErrorReason.Cancelled));\n        });\n        const wsTimeout = setTimeout(() => {\n          this.close();\n          reject(new ConnectionError('room connection has timed out (signal)', ConnectionErrorReason.ServerUnreachable));\n        }, opts.websocketTimeout);\n        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n          abortHandler();\n        }\n        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener('abort', abortHandler);\n        const redactedUrl = new URL(rtcUrl);\n        if (redactedUrl.searchParams.has('access_token')) {\n          redactedUrl.searchParams.set('access_token', '<redacted>');\n        }\n        this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\n          reconnect: opts.reconnect,\n          reconnectReason: opts.reconnectReason\n        }, this.logContext));\n        if (this.ws) {\n          yield this.close(false);\n        }\n        this.ws = new WebSocket(rtcUrl);\n        this.ws.binaryType = 'arraybuffer';\n        this.ws.onopen = () => {\n          clearTimeout(wsTimeout);\n        };\n        this.ws.onerror = ev => __awaiter(this, void 0, void 0, function* () {\n          if (this.state !== SignalConnectionState.CONNECTED) {\n            this.state = SignalConnectionState.DISCONNECTED;\n            clearTimeout(wsTimeout);\n            try {\n              const resp = yield fetch(validateUrl);\n              if (resp.status.toFixed(0).startsWith('4')) {\n                const msg = yield resp.text();\n                reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));\n              } else {\n                reject(new ConnectionError(\"Encountered unknown websocket error during connection: \".concat(ev.toString()), ConnectionErrorReason.InternalError, resp.status));\n              }\n            } catch (e) {\n              reject(new ConnectionError(e instanceof Error ? e.message : 'server was not reachable', ConnectionErrorReason.ServerUnreachable));\n            }\n            return;\n          }\n          // other errors, handle\n          this.handleWSError(ev);\n        });\n        this.ws.onmessage = ev => __awaiter(this, void 0, void 0, function* () {\n          var _a, _b, _c;\n          // not considered connected until JoinResponse is received\n          let resp;\n          if (typeof ev.data === 'string') {\n            const json = JSON.parse(ev.data);\n            resp = SignalResponse.fromJson(json, {\n              ignoreUnknownFields: true\n            });\n          } else if (ev.data instanceof ArrayBuffer) {\n            resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n          } else {\n            this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\n            return;\n          }\n          if (this.state !== SignalConnectionState.CONNECTED) {\n            let shouldProcessMessage = false;\n            // handle join message only\n            if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === 'join') {\n              this.state = SignalConnectionState.CONNECTED;\n              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n              this.pingTimeoutDuration = resp.message.value.pingTimeout;\n              this.pingIntervalDuration = resp.message.value.pingInterval;\n              if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                this.log.debug('ping config', Object.assign(Object.assign({}, this.logContext), {\n                  timeout: this.pingTimeoutDuration,\n                  interval: this.pingIntervalDuration\n                }));\n                this.startPingInterval();\n              }\n              resolve(resp.message.value);\n            } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== 'leave') {\n              // in reconnecting, any message received means signal reconnected\n              this.state = SignalConnectionState.CONNECTED;\n              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n              this.startPingInterval();\n              if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === 'reconnect') {\n                resolve(resp.message.value);\n              } else {\n                this.log.debug('declaring signal reconnected without reconnect response received', this.logContext);\n                resolve(undefined);\n                shouldProcessMessage = true;\n              }\n            } else if (this.isEstablishingConnection && resp.message.case === 'leave') {\n              reject(new ConnectionError('Received leave request while trying to (re)connect', ConnectionErrorReason.LeaveRequest, undefined, resp.message.value.reason));\n            } else if (!opts.reconnect) {\n              // non-reconnect case, should receive join response first\n              reject(new ConnectionError(\"did not receive join response, got \".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, \" instead\"), ConnectionErrorReason.InternalError));\n            }\n            if (!shouldProcessMessage) {\n              return;\n            }\n          }\n          if (this.signalLatency) {\n            yield sleep(this.signalLatency);\n          }\n          this.handleSignalResponse(resp);\n        });\n        this.ws.onclose = ev => {\n          if (this.isEstablishingConnection) {\n            reject(new ConnectionError('Websocket got closed during a (re)connection attempt', ConnectionErrorReason.InternalError));\n          }\n          this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n            reason: ev.reason,\n            code: ev.code,\n            wasClean: ev.wasClean,\n            state: this.state\n          }));\n          this.handleOnClose(ev.reason);\n        };\n      } finally {\n        unlock();\n      }\n    }));\n  }\n  close() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this = this;\n      let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return function* () {\n        const unlock = yield _this.closingLock.lock();\n        try {\n          _this.clearPingInterval();\n          if (updateState) {\n            _this.state = SignalConnectionState.DISCONNECTING;\n          }\n          if (_this.ws) {\n            _this.ws.onmessage = null;\n            _this.ws.onopen = null;\n            _this.ws.onclose = null;\n            // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n            const closePromise = new Promise(resolve => {\n              if (_this.ws) {\n                _this.ws.onclose = () => {\n                  resolve();\n                };\n              } else {\n                resolve();\n              }\n            });\n            if (_this.ws.readyState < _this.ws.CLOSING) {\n              _this.ws.close();\n              // 250ms grace period for ws to close gracefully\n              yield Promise.race([closePromise, sleep(250)]);\n            }\n            _this.ws = undefined;\n          }\n        } finally {\n          if (updateState) {\n            _this.state = SignalConnectionState.DISCONNECTED;\n          }\n          unlock();\n        }\n      }();\n    });\n  }\n  // initial offer after joining\n  sendOffer(offer) {\n    this.log.debug('sending offer', Object.assign(Object.assign({}, this.logContext), {\n      offerSdp: offer.sdp\n    }));\n    this.sendRequest({\n      case: 'offer',\n      value: toProtoSessionDescription(offer)\n    });\n  }\n  // answer a server-initiated offer\n  sendAnswer(answer) {\n    this.log.debug('sending answer', Object.assign(Object.assign({}, this.logContext), {\n      answerSdp: answer.sdp\n    }));\n    return this.sendRequest({\n      case: 'answer',\n      value: toProtoSessionDescription(answer)\n    });\n  }\n  sendIceCandidate(candidate, target) {\n    this.log.debug('sending ice candidate', Object.assign(Object.assign({}, this.logContext), {\n      candidate\n    }));\n    return this.sendRequest({\n      case: 'trickle',\n      value: new TrickleRequest({\n        candidateInit: JSON.stringify(candidate),\n        target\n      })\n    });\n  }\n  sendMuteTrack(trackSid, muted) {\n    return this.sendRequest({\n      case: 'mute',\n      value: new MuteTrackRequest({\n        sid: trackSid,\n        muted\n      })\n    });\n  }\n  sendAddTrack(req) {\n    return this.sendRequest({\n      case: 'addTrack',\n      value: req\n    });\n  }\n  sendUpdateLocalMetadata(metadata_1, name_1) {\n    return __awaiter(this, arguments, void 0, function (metadata, name) {\n      var _this2 = this;\n      let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return function* () {\n        const requestId = _this2.getNextRequestId();\n        yield _this2.sendRequest({\n          case: 'updateMetadata',\n          value: new UpdateParticipantMetadata({\n            requestId,\n            metadata,\n            name,\n            attributes\n          })\n        });\n        return requestId;\n      }();\n    });\n  }\n  sendUpdateTrackSettings(settings) {\n    this.sendRequest({\n      case: 'trackSetting',\n      value: settings\n    });\n  }\n  sendUpdateSubscription(sub) {\n    return this.sendRequest({\n      case: 'subscription',\n      value: sub\n    });\n  }\n  sendSyncState(sync) {\n    return this.sendRequest({\n      case: 'syncState',\n      value: sync\n    });\n  }\n  sendUpdateVideoLayers(trackSid, layers) {\n    return this.sendRequest({\n      case: 'updateLayers',\n      value: new UpdateVideoLayers({\n        trackSid,\n        layers\n      })\n    });\n  }\n  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n    return this.sendRequest({\n      case: 'subscriptionPermission',\n      value: new SubscriptionPermission({\n        allParticipants,\n        trackPermissions\n      })\n    });\n  }\n  sendSimulateScenario(scenario) {\n    return this.sendRequest({\n      case: 'simulate',\n      value: scenario\n    });\n  }\n  sendPing() {\n    /** send both of ping and pingReq for compatibility to old and new server */\n    return Promise.all([this.sendRequest({\n      case: 'ping',\n      value: protoInt64.parse(Date.now())\n    }), this.sendRequest({\n      case: 'pingReq',\n      value: new Ping({\n        timestamp: protoInt64.parse(Date.now()),\n        rtt: protoInt64.parse(this.rtt)\n      })\n    })]);\n  }\n  sendUpdateLocalAudioTrack(trackSid, features) {\n    return this.sendRequest({\n      case: 'updateAudioTrack',\n      value: new UpdateLocalAudioTrack({\n        trackSid,\n        features\n      })\n    });\n  }\n  sendLeave() {\n    return this.sendRequest({\n      case: 'leave',\n      value: new LeaveRequest({\n        reason: DisconnectReason.CLIENT_INITIATED,\n        // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\n        action: LeaveRequest_Action.DISCONNECT\n      })\n    });\n  }\n  sendRequest(message_1) {\n    return __awaiter(this, arguments, void 0, function (message) {\n      var _this3 = this;\n      let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return function* () {\n        // capture all requests while reconnecting and put them in a queue\n        // unless the request originates from the queue, then don't enqueue again\n        const canQueue = !fromQueue && !canPassThroughQueue(message);\n        if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\n          _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {\n            yield this.sendRequest(message, true);\n          }));\n          return;\n        }\n        // make sure previously queued requests are being sent first\n        if (!fromQueue) {\n          yield _this3.requestQueue.flush();\n        }\n        if (_this3.signalLatency) {\n          yield sleep(_this3.signalLatency);\n        }\n        if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {\n          _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\n          return;\n        }\n        const req = new SignalRequest({\n          message\n        });\n        try {\n          if (_this3.useJSON) {\n            _this3.ws.send(req.toJsonString());\n          } else {\n            _this3.ws.send(req.toBinary());\n          }\n        } catch (e) {\n          _this3.log.error('error sending signal message', Object.assign(Object.assign({}, _this3.logContext), {\n            error: e\n          }));\n        }\n      }();\n    });\n  }\n  handleSignalResponse(res) {\n    var _a, _b;\n    const msg = res.message;\n    if (msg == undefined) {\n      this.log.debug('received unsupported message', this.logContext);\n      return;\n    }\n    let pingHandled = false;\n    if (msg.case === 'answer') {\n      const sd = fromProtoSessionDescription(msg.value);\n      if (this.onAnswer) {\n        this.onAnswer(sd);\n      }\n    } else if (msg.case === 'offer') {\n      const sd = fromProtoSessionDescription(msg.value);\n      if (this.onOffer) {\n        this.onOffer(sd);\n      }\n    } else if (msg.case === 'trickle') {\n      const candidate = JSON.parse(msg.value.candidateInit);\n      if (this.onTrickle) {\n        this.onTrickle(candidate, msg.value.target);\n      }\n    } else if (msg.case === 'update') {\n      if (this.onParticipantUpdate) {\n        this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n      }\n    } else if (msg.case === 'trackPublished') {\n      if (this.onLocalTrackPublished) {\n        this.onLocalTrackPublished(msg.value);\n      }\n    } else if (msg.case === 'speakersChanged') {\n      if (this.onSpeakersChanged) {\n        this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n      }\n    } else if (msg.case === 'leave') {\n      if (this.onLeave) {\n        this.onLeave(msg.value);\n      }\n    } else if (msg.case === 'mute') {\n      if (this.onRemoteMuteChanged) {\n        this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n      }\n    } else if (msg.case === 'roomUpdate') {\n      if (this.onRoomUpdate && msg.value.room) {\n        this.onRoomUpdate(msg.value.room);\n      }\n    } else if (msg.case === 'connectionQuality') {\n      if (this.onConnectionQuality) {\n        this.onConnectionQuality(msg.value);\n      }\n    } else if (msg.case === 'streamStateUpdate') {\n      if (this.onStreamStateUpdate) {\n        this.onStreamStateUpdate(msg.value);\n      }\n    } else if (msg.case === 'subscribedQualityUpdate') {\n      if (this.onSubscribedQualityUpdate) {\n        this.onSubscribedQualityUpdate(msg.value);\n      }\n    } else if (msg.case === 'subscriptionPermissionUpdate') {\n      if (this.onSubscriptionPermissionUpdate) {\n        this.onSubscriptionPermissionUpdate(msg.value);\n      }\n    } else if (msg.case === 'refreshToken') {\n      if (this.onTokenRefresh) {\n        this.onTokenRefresh(msg.value);\n      }\n    } else if (msg.case === 'trackUnpublished') {\n      if (this.onLocalTrackUnpublished) {\n        this.onLocalTrackUnpublished(msg.value);\n      }\n    } else if (msg.case === 'subscriptionResponse') {\n      if (this.onSubscriptionError) {\n        this.onSubscriptionError(msg.value);\n      }\n    } else if (msg.case === 'pong') ; else if (msg.case === 'pongResp') {\n      this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n      this.resetPingTimeout();\n      pingHandled = true;\n    } else if (msg.case === 'requestResponse') {\n      if (this.onRequestResponse) {\n        this.onRequestResponse(msg.value);\n      }\n    } else if (msg.case === 'trackSubscribed') {\n      if (this.onLocalTrackSubscribed) {\n        this.onLocalTrackSubscribed(msg.value.trackSid);\n      }\n    } else {\n      this.log.debug('unsupported message', Object.assign(Object.assign({}, this.logContext), {\n        msgCase: msg.case\n      }));\n    }\n    if (!pingHandled) {\n      this.resetPingTimeout();\n    }\n  }\n  setReconnected() {\n    while (this.queuedRequests.length > 0) {\n      const req = this.queuedRequests.shift();\n      if (req) {\n        this.requestQueue.run(req);\n      }\n    }\n  }\n  handleOnClose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === SignalConnectionState.DISCONNECTED) return;\n      const onCloseCallback = this.onClose;\n      yield this.close();\n      this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n        reason\n      }));\n      if (onCloseCallback) {\n        onCloseCallback(reason);\n      }\n    });\n  }\n  handleWSError(ev) {\n    this.log.error('websocket error', Object.assign(Object.assign({}, this.logContext), {\n      error: ev\n    }));\n  }\n  /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */\n  resetPingTimeout() {\n    this.clearPingTimeout();\n    if (!this.pingTimeoutDuration) {\n      this.log.warn('ping timeout duration not set', this.logContext);\n      return;\n    }\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\n      this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n      this.handleOnClose('ping timeout');\n    }, this.pingTimeoutDuration * 1000);\n  }\n  /**\n   * Clears ping timeout (does not start a new timeout)\n   */\n  clearPingTimeout() {\n    if (this.pingTimeout) {\n      CriticalTimers.clearTimeout(this.pingTimeout);\n    }\n  }\n  startPingInterval() {\n    this.clearPingInterval();\n    this.resetPingTimeout();\n    if (!this.pingIntervalDuration) {\n      this.log.warn('ping interval duration not set', this.logContext);\n      return;\n    }\n    this.log.debug('start ping interval', this.logContext);\n    this.pingInterval = CriticalTimers.setInterval(() => {\n      this.sendPing();\n    }, this.pingIntervalDuration * 1000);\n  }\n  clearPingInterval() {\n    this.log.debug('clearing ping interval', this.logContext);\n    this.clearPingTimeout();\n    if (this.pingInterval) {\n      CriticalTimers.clearInterval(this.pingInterval);\n    }\n  }\n}\nfunction fromProtoSessionDescription(sd) {\n  const rsd = {\n    type: 'offer',\n    sdp: sd.sdp\n  };\n  switch (sd.type) {\n    case 'answer':\n    case 'offer':\n    case 'pranswer':\n    case 'rollback':\n      rsd.type = sd.type;\n      break;\n  }\n  return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n  const sd = new SessionDescription({\n    sdp: rsd.sdp,\n    type: rsd.type\n  });\n  return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n  var _a;\n  const params = new URLSearchParams();\n  params.set('access_token', token);\n  // opts\n  if (opts.reconnect) {\n    params.set('reconnect', '1');\n    if (opts.sid) {\n      params.set('sid', opts.sid);\n    }\n  }\n  params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');\n  // ClientInfo\n  params.set('sdk', isReactNative() ? 'reactnative' : 'js');\n  params.set('version', info.version);\n  params.set('protocol', info.protocol.toString());\n  if (info.deviceModel) {\n    params.set('device_model', info.deviceModel);\n  }\n  if (info.os) {\n    params.set('os', info.os);\n  }\n  if (info.osVersion) {\n    params.set('os_version', info.osVersion);\n  }\n  if (info.browser) {\n    params.set('browser', info.browser);\n  }\n  if (info.browserVersion) {\n    params.set('browser_version', info.browserVersion);\n  }\n  if (opts.adaptiveStream) {\n    params.set('adaptive_stream', '1');\n  }\n  if (opts.reconnectReason) {\n    params.set('reconnect_reason', opts.reconnectReason.toString());\n  }\n  // @ts-ignore\n  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n    // @ts-ignore\n    params.set('network', navigator.connection.type);\n  }\n  return params;\n}\n\nvar lib = {};\n\nvar parser = {};\n\nvar grammar = {exports: {}};\n\nvar hasRequiredGrammar;\nfunction requireGrammar() {\n  if (hasRequiredGrammar) return grammar.exports;\n  hasRequiredGrammar = 1;\n  var grammar$1 = grammar.exports = {\n    v: [{\n      name: 'version',\n      reg: /^(\\d*)$/\n    }],\n    o: [{\n      // o=- 20518 0 IN IP4 203.0.113.1\n      // NB: sessionId will be a String in most cases because it is huge\n      name: 'origin',\n      reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n      names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n      format: '%s %s %d %s IP%d %s'\n    }],\n    // default parsing of these only (though some of these feel outdated)\n    s: [{\n      name: 'name'\n    }],\n    i: [{\n      name: 'description'\n    }],\n    u: [{\n      name: 'uri'\n    }],\n    e: [{\n      name: 'email'\n    }],\n    p: [{\n      name: 'phone'\n    }],\n    z: [{\n      name: 'timezones'\n    }],\n    // TODO: this one can actually be parsed properly...\n    r: [{\n      name: 'repeats'\n    }],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [{\n      // t=0 0\n      name: 'timing',\n      reg: /^(\\d*) (\\d*)/,\n      names: ['start', 'stop'],\n      format: '%d %d'\n    }],\n    c: [{\n      // c=IN IP4 10.47.197.26\n      name: 'connection',\n      reg: /^IN IP(\\d) (\\S*)/,\n      names: ['version', 'ip'],\n      format: 'IN IP%d %s'\n    }],\n    b: [{\n      // b=AS:4000\n      push: 'bandwidth',\n      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n      names: ['type', 'limit'],\n      format: '%s:%s'\n    }],\n    m: [{\n      // m=video 51744 RTP/AVP 126 97 98 34 31\n      // NB: special - pushes to session\n      // TODO: rtp/fmtp should be filtered by the payloads found here?\n      reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n      names: ['type', 'port', 'protocol', 'payloads'],\n      format: '%s %d %s %s'\n    }],\n    a: [{\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\n      }\n    }, {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    }, {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    }, {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\n      }\n    }, {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%s trr-int %d'\n    }, {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\n      }\n    }, {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n      }\n    }, {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    }, {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\n      }\n    }, {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    }, {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    }, {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    }, {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    }, {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    }, {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    }, {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    }, {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    }, {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    }, {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    }, {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    }, {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push: 'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n        str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += o.tcptype != null ? ' tcptype %s' : '%v';\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n        str += o['network-id'] != null ? ' network-id %d' : '%v';\n        str += o['network-cost'] != null ? ' network-cost %d' : '%v';\n        return str;\n      }\n    }, {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    }, {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    }, {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    }, {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    }, {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    }, {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    }, {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    }, {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    }, {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    }, {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\n      }\n    }, {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    }, {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    }, {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n      // a=imageattr:97\n      '^imageattr:(\\\\d+|\\\\*)' +\n      // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n      '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n      // recv [x=330,y=250]\n      '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    }, {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n      // a=simulcast:\n      '^simulcast:' +\n      // send 1,2,3;~4,~5\n      '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n      // space + recv 6;~7,~8\n      '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n      // end\n      '$'),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    }, {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    }, {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    }, {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    }, {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    }, {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    }, {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    }, {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    }, {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push: 'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    }, {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name: 'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += o.id != null ? 'id=%s %s' : '%v%s';\n        str += o.mediaClockValue != null ? '=%s' : '';\n        str += o.rateNumerator != null ? ' rate=%s' : '';\n        str += o.rateDenominator != null ? '/%s' : '';\n        return str;\n      }\n    }, {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    }, {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    }, {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    }, {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    }, {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    }, {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }]\n  };\n\n  // set sensible defaults to avoid polluting the grammar with boring details\n  Object.keys(grammar$1).forEach(function (key) {\n    var objs = grammar$1[key];\n    objs.forEach(function (obj) {\n      if (!obj.reg) {\n        obj.reg = /(.*)/;\n      }\n      if (!obj.format) {\n        obj.format = '%s';\n      }\n    });\n  });\n  return grammar.exports;\n}\n\nvar hasRequiredParser;\nfunction requireParser() {\n  if (hasRequiredParser) return parser;\n  hasRequiredParser = 1;\n  (function (exports) {\n    var toIntIfInt = function (v) {\n      return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function (match, location, names, rawName) {\n      if (rawName && !names) {\n        location[rawName] = toIntIfInt(match[1]);\n      } else {\n        for (var i = 0; i < names.length; i += 1) {\n          if (match[i + 1] != null) {\n            location[names[i]] = toIntIfInt(match[i + 1]);\n          }\n        }\n      }\n    };\n    var parseReg = function (obj, location, content) {\n      var needsBlank = obj.name && obj.names;\n      if (obj.push && !location[obj.push]) {\n        location[obj.push] = [];\n      } else if (needsBlank && !location[obj.name]) {\n        location[obj.name] = {};\n      }\n      var keyLocation = obj.push ? {} :\n      // blank object that will be pushed\n      needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n      if (obj.push) {\n        location[obj.push].push(keyLocation);\n      }\n    };\n    var grammar = requireGrammar();\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports.parse = function (sdp) {\n      var session = {},\n        media = [],\n        location = session; // points at where properties go under (one of the above)\n\n      // parse lines we understand\n      sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n        var type = l[0];\n        var content = l.slice(2);\n        if (type === 'm') {\n          media.push({\n            rtp: [],\n            fmtp: []\n          });\n          location = media[media.length - 1]; // point at latest media line\n        }\n        for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n          var obj = grammar[type][j];\n          if (obj.reg.test(content)) {\n            return parseReg(obj, location, content);\n          }\n        }\n      });\n      session.media = media; // link it up\n      return session;\n    };\n    var paramReducer = function (acc, expr) {\n      var s = expr.split(/=(.+)/, 2);\n      if (s.length === 2) {\n        acc[s[0]] = toIntIfInt(s[1]);\n      } else if (s.length === 1 && expr.length > 1) {\n        acc[s[0]] = undefined;\n      }\n      return acc;\n    };\n    exports.parseParams = function (str) {\n      return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports.parseFmtpConfig = exports.parseParams;\n    exports.parsePayloads = function (str) {\n      return str.toString().split(' ').map(Number);\n    };\n    exports.parseRemoteCandidates = function (str) {\n      var candidates = [];\n      var parts = str.split(' ').map(toIntIfInt);\n      for (var i = 0; i < parts.length; i += 3) {\n        candidates.push({\n          component: parts[i],\n          ip: parts[i + 1],\n          port: parts[i + 2]\n        });\n      }\n      return candidates;\n    };\n    exports.parseImageAttributes = function (str) {\n      return str.split(' ').map(function (item) {\n        return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\n      });\n    };\n    exports.parseSimulcastStreamList = function (str) {\n      return str.split(';').map(function (stream) {\n        return stream.split(',').map(function (format) {\n          var scid,\n            paused = false;\n          if (format[0] !== '~') {\n            scid = toIntIfInt(format);\n          } else {\n            scid = toIntIfInt(format.substring(1, format.length));\n            paused = true;\n          }\n          return {\n            scid: scid,\n            paused: paused\n          };\n        });\n      });\n    };\n  })(parser);\n  return parser;\n}\n\nvar writer;\nvar hasRequiredWriter;\nfunction requireWriter() {\n  if (hasRequiredWriter) return writer;\n  hasRequiredWriter = 1;\n  var grammar = requireGrammar();\n\n  // customized util.format - discards excess arguments and can void middle ones\n  var formatRegExp = /%[sdv%]/g;\n  var format = function (formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function (x) {\n      if (i >= len) {\n        return x; // missing argument\n      }\n      var arg = args[i];\n      i += 1;\n      switch (x) {\n        case '%%':\n          return '%';\n        case '%s':\n          return String(arg);\n        case '%d':\n          return Number(arg);\n        case '%v':\n          return '';\n      }\n    });\n    // NB: we discard excess arguments - they are typically undefined from makeLine\n  };\n  var makeLine = function (type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [type + '=' + str];\n    if (obj.names) {\n      for (var i = 0; i < obj.names.length; i += 1) {\n        var n = obj.names[i];\n        if (obj.name) {\n          args.push(location[obj.name][n]);\n        } else {\n          // for mLine and push attributes\n          args.push(location[obj.names[i]]);\n        }\n      }\n    } else {\n      args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n  };\n\n  // RFC specified order\n  // TODO: extend this with all the rest\n  var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\n  var defaultInnerOrder = ['i', 'c', 'b', 'a'];\n  writer = function (session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n      session.version = 0; // 'v=0' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n      session.name = ' '; // 's= ' must be there if no meaningful name set\n    }\n    session.media.forEach(function (mLine) {\n      if (mLine.payloads == null) {\n        mLine.payloads = '';\n      }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in session && session[obj.name] != null) {\n          sdp.push(makeLine(type, obj, session));\n        } else if (obj.push in session && session[obj.push] != null) {\n          session[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function (mLine) {\n      sdp.push(makeLine('m', grammar.m[0], mLine));\n      innerOrder.forEach(function (type) {\n        grammar[type].forEach(function (obj) {\n          if (obj.name in mLine && mLine[obj.name] != null) {\n            sdp.push(makeLine(type, obj, mLine));\n          } else if (obj.push in mLine && mLine[obj.push] != null) {\n            mLine[obj.push].forEach(function (el) {\n              sdp.push(makeLine(type, obj, el));\n            });\n          }\n        });\n      });\n    });\n    return sdp.join('\\r\\n') + '\\r\\n';\n  };\n  return writer;\n}\n\nvar hasRequiredLib;\nfunction requireLib() {\n  if (hasRequiredLib) return lib;\n  hasRequiredLib = 1;\n  var parser = requireParser();\n  var writer = requireWriter();\n  var grammar = requireGrammar();\n  lib.grammar = grammar;\n  lib.write = writer;\n  lib.parse = parser.parse;\n  lib.parseParams = parser.parseParams;\n  lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\n  lib.parsePayloads = parser.parsePayloads;\n  lib.parseRemoteCandidates = parser.parseRemoteCandidates;\n  lib.parseImageAttributes = parser.parseImageAttributes;\n  lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n  return lib;\n}\n\nvar libExports = requireLib();\n\nfunction r(r, e, n) {\n  var i, t, o;\n  void 0 === e && (e = 50), void 0 === n && (n = {});\n  var a = null != (i = n.isImmediate) && i,\n    u = null != (t = n.callback) && t,\n    c = n.maxWait,\n    v = Date.now(),\n    l = [];\n  function f() {\n    if (void 0 !== c) {\n      var r = Date.now() - v;\n      if (r + e >= c) return c - r;\n    }\n    return e;\n  }\n  var d = function () {\n    var e = [].slice.call(arguments),\n      n = this;\n    return new Promise(function (i, t) {\n      var c = a && void 0 === o;\n      if (void 0 !== o && clearTimeout(o), o = setTimeout(function () {\n        if (o = void 0, v = Date.now(), !a) {\n          var i = r.apply(n, e);\n          u && u(i), l.forEach(function (r) {\n            return (0, r.resolve)(i);\n          }), l = [];\n        }\n      }, f()), c) {\n        var d = r.apply(n, e);\n        return u && u(d), i(d);\n      }\n      l.push({\n        resolve: i,\n        reject: t\n      });\n    });\n  };\n  return d.cancel = function (r) {\n    void 0 !== o && clearTimeout(o), l.forEach(function (e) {\n      return (0, e.reject)(r);\n    }), l = [];\n  }, d;\n}\n\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/\nconst startBitrateForSVC = 0.7;\nconst debounceInterval = 20;\nconst PCEvents = {\n  NegotiationStarted: 'negotiationStarted',\n  NegotiationComplete: 'negotiationComplete',\n  RTPVideoPayloadTypes: 'rtpVideoPayloadTypes'\n};\n/** @internal */\nclass PCTransport extends eventsExports.EventEmitter {\n  get pc() {\n    if (!this._pc) {\n      this._pc = this.createPC();\n    }\n    return this._pc;\n  }\n  constructor(config) {\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    super();\n    this.log = livekitLogger;\n    this.ddExtID = 0;\n    this.pendingCandidates = [];\n    this.restartingIce = false;\n    this.renegotiate = false;\n    this.trackBitrates = [];\n    this.remoteStereoMids = [];\n    this.remoteNackMids = [];\n    // debounced negotiate interface\n    this.negotiate = r(onError => __awaiter(this, void 0, void 0, function* () {\n      this.emit(PCEvents.NegotiationStarted);\n      try {\n        yield this.createAndSendOffer();\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          throw e;\n        }\n      }\n    }), debounceInterval);\n    this.close = () => {\n      if (!this._pc) {\n        return;\n      }\n      this._pc.close();\n      this._pc.onconnectionstatechange = null;\n      this._pc.oniceconnectionstatechange = null;\n      this._pc.onicegatheringstatechange = null;\n      this._pc.ondatachannel = null;\n      this._pc.onnegotiationneeded = null;\n      this._pc.onsignalingstatechange = null;\n      this._pc.onicecandidate = null;\n      this._pc.ondatachannel = null;\n      this._pc.ontrack = null;\n      this._pc.onconnectionstatechange = null;\n      this._pc.oniceconnectionstatechange = null;\n      this._pc = null;\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n    this.loggerOptions = loggerOptions;\n    this.config = config;\n    this._pc = this.createPC();\n  }\n  createPC() {\n    const pc = new RTCPeerConnection(this.config);\n    pc.onicecandidate = ev => {\n      var _a;\n      if (!ev.candidate) return;\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n    };\n    pc.onicecandidateerror = ev => {\n      var _a;\n      (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    pc.oniceconnectionstatechange = () => {\n      var _a;\n      (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n    };\n    pc.onsignalingstatechange = () => {\n      var _a;\n      (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n    };\n    pc.onconnectionstatechange = () => {\n      var _a;\n      (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n    };\n    pc.ondatachannel = ev => {\n      var _a;\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    pc.ontrack = ev => {\n      var _a;\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    return pc;\n  }\n  get logContext() {\n    var _a, _b;\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n  get isICEConnected() {\n    return this._pc !== null && (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed');\n  }\n  addIceCandidate(candidate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pc.remoteDescription && !this.restartingIce) {\n        return this.pc.addIceCandidate(candidate);\n      }\n      this.pendingCandidates.push(candidate);\n    });\n  }\n  setRemoteDescription(sd) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      let mungedSDP = undefined;\n      if (sd.type === 'offer') {\n        let {\n          stereoMids,\n          nackMids\n        } = extractStereoAndNackAudioFromOffer(sd);\n        this.remoteStereoMids = stereoMids;\n        this.remoteNackMids = nackMids;\n      } else if (sd.type === 'answer') {\n        const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');\n        sdpParsed.media.forEach(media => {\n          if (media.type === 'audio') {\n            // mung sdp for opus bitrate settings\n            this.trackBitrates.some(trackbr => {\n              if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                return false;\n              }\n              let codecPayload = 0;\n              media.rtp.some(rtp => {\n                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                  codecPayload = rtp.payload;\n                  return true;\n                }\n                return false;\n              });\n              if (codecPayload === 0) {\n                return true;\n              }\n              let fmtpFound = false;\n              for (const fmtp of media.fmtp) {\n                if (fmtp.payload === codecPayload) {\n                  fmtp.config = fmtp.config.split(';').filter(attr => !attr.includes('maxaveragebitrate')).join(';');\n                  if (trackbr.maxbr > 0) {\n                    fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                  }\n                  fmtpFound = true;\n                  break;\n                }\n              }\n              if (!fmtpFound) {\n                if (trackbr.maxbr > 0) {\n                  media.fmtp.push({\n                    payload: codecPayload,\n                    config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                  });\n                }\n              }\n              return true;\n            });\n          }\n        });\n        mungedSDP = libExports.write(sdpParsed);\n      }\n      yield this.setMungedSDP(sd, mungedSDP, true);\n      this.pendingCandidates.forEach(candidate => {\n        this.pc.addIceCandidate(candidate);\n      });\n      this.pendingCandidates = [];\n      this.restartingIce = false;\n      if (this.renegotiate) {\n        this.renegotiate = false;\n        yield this.createAndSendOffer();\n      } else if (sd.type === 'answer') {\n        this.emit(PCEvents.NegotiationComplete);\n        if (sd.sdp) {\n          const sdpParsed = libExports.parse(sd.sdp);\n          sdpParsed.media.forEach(media => {\n            if (media.type === 'video') {\n              this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n            }\n          });\n        }\n      }\n    });\n  }\n  createAndSendOffer(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (this.onOffer === undefined) {\n        return;\n      }\n      if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n        this.log.debug('restarting ICE', this.logContext);\n        this.restartingIce = true;\n      }\n      if (this._pc && this._pc.signalingState === 'have-local-offer') {\n        // we're waiting for the peer to accept our offer, so we'll just wait\n        // the only exception to this is when ICE restart is needed\n        const currentSD = this._pc.remoteDescription;\n        if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n          // TODO: handle when ICE restart is needed but we don't have a remote description\n          // the best thing to do is to recreate the peerconnection\n          yield this._pc.setRemoteDescription(currentSD);\n        } else {\n          this.renegotiate = true;\n          return;\n        }\n      } else if (!this._pc || this._pc.signalingState === 'closed') {\n        this.log.warn('could not createOffer with closed peer connection', this.logContext);\n        return;\n      }\n      // actually negotiate\n      this.log.debug('starting to negotiate', this.logContext);\n      const offer = yield this.pc.createOffer(options);\n      this.log.debug('original offer', Object.assign({\n        sdp: offer.sdp\n      }, this.logContext));\n      const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n      sdpParsed.media.forEach(media => {\n        ensureIPAddrMatchVersion(media);\n        if (media.type === 'audio') {\n          ensureAudioNackAndStereo(media, [], []);\n        } else if (media.type === 'video') {\n          this.trackBitrates.some(trackbr => {\n            if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n              return false;\n            }\n            let codecPayload = 0;\n            media.rtp.some(rtp => {\n              if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                codecPayload = rtp.payload;\n                return true;\n              }\n              return false;\n            });\n            if (codecPayload === 0) {\n              return true;\n            }\n            if (isSVCCodec(trackbr.codec)) {\n              this.ensureVideoDDExtensionForSVC(media, sdpParsed);\n            }\n            // TODO: av1 slow starting issue already fixed in chrome 124, clean this after some versions\n            // mung sdp for av1 bitrate setting that can't apply by sendEncoding\n            if (trackbr.codec !== 'av1') {\n              return true;\n            }\n            const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\n            for (const fmtp of media.fmtp) {\n              if (fmtp.payload === codecPayload) {\n                // if another track's fmtp already is set, we cannot override the bitrate\n                // this has the unfortunate consequence of being forced to use the\n                // initial track's bitrate for all tracks\n                if (!fmtp.config.includes('x-google-start-bitrate')) {\n                  fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\n                }\n                break;\n              }\n            }\n            return true;\n          });\n        }\n      });\n      yield this.setMungedSDP(offer, libExports.write(sdpParsed));\n      this.onOffer(offer);\n    });\n  }\n  createAndSetAnswer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const answer = yield this.pc.createAnswer();\n      const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');\n      sdpParsed.media.forEach(media => {\n        ensureIPAddrMatchVersion(media);\n        if (media.type === 'audio') {\n          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n        }\n      });\n      yield this.setMungedSDP(answer, libExports.write(sdpParsed));\n      return answer;\n    });\n  }\n  createDataChannel(label, dataChannelDict) {\n    return this.pc.createDataChannel(label, dataChannelDict);\n  }\n  addTransceiver(mediaStreamTrack, transceiverInit) {\n    return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n  }\n  addTrack(track) {\n    if (!this._pc) {\n      throw new UnexpectedConnectionState('PC closed, cannot add track');\n    }\n    return this._pc.addTrack(track);\n  }\n  setTrackCodecBitrate(info) {\n    this.trackBitrates.push(info);\n  }\n  setConfiguration(rtcConfig) {\n    var _a;\n    if (!this._pc) {\n      throw new UnexpectedConnectionState('PC closed, cannot configure');\n    }\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n  }\n  canRemoveTrack() {\n    var _a;\n    return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n  }\n  removeTrack(sender) {\n    var _a;\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n  }\n  getConnectionState() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';\n  }\n  getICEConnectionState() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : 'closed';\n  }\n  getSignallingState() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : 'closed';\n  }\n  getTransceivers() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n  }\n  getSenders() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n  }\n  getLocalDescription() {\n    var _a;\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n  }\n  getRemoteDescription() {\n    var _a;\n    return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n  }\n  getStats() {\n    return this.pc.getStats();\n  }\n  getConnectedAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!this._pc) {\n        return;\n      }\n      let selectedCandidatePairId = '';\n      const candidatePairs = new Map();\n      // id -> candidate ip\n      const candidates = new Map();\n      const stats = yield this._pc.getStats();\n      stats.forEach(v => {\n        switch (v.type) {\n          case 'transport':\n            selectedCandidatePairId = v.selectedCandidatePairId;\n            break;\n          case 'candidate-pair':\n            if (selectedCandidatePairId === '' && v.selected) {\n              selectedCandidatePairId = v.id;\n            }\n            candidatePairs.set(v.id, v);\n            break;\n          case 'remote-candidate':\n            candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n            break;\n        }\n      });\n      if (selectedCandidatePairId === '') {\n        return undefined;\n      }\n      const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n      if (selectedID === undefined) {\n        return undefined;\n      }\n      return candidates.get(selectedID);\n    });\n  }\n  setMungedSDP(sd, munged, remote) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (munged) {\n        const originalSdp = sd.sdp;\n        sd.sdp = munged;\n        try {\n          this.log.debug(\"setting munged \".concat(remote ? 'remote' : 'local', \" description\"), this.logContext);\n          if (remote) {\n            yield this.pc.setRemoteDescription(sd);\n          } else {\n            yield this.pc.setLocalDescription(sd);\n          }\n          return;\n        } catch (e) {\n          this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n            error: e,\n            sdp: munged\n          }));\n          sd.sdp = originalSdp;\n        }\n      }\n      try {\n        if (remote) {\n          yield this.pc.setRemoteDescription(sd);\n        } else {\n          yield this.pc.setLocalDescription(sd);\n        }\n      } catch (e) {\n        let msg = 'unknown error';\n        if (e instanceof Error) {\n          msg = e.message;\n        } else if (typeof e === 'string') {\n          msg = e;\n        }\n        const fields = {\n          error: msg,\n          sdp: sd.sdp\n        };\n        if (!remote && this.pc.remoteDescription) {\n          fields.remoteSdp = this.pc.remoteDescription;\n        }\n        this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n          fields\n        }));\n        throw new NegotiationError(msg);\n      }\n    });\n  }\n  ensureVideoDDExtensionForSVC(media, sdp) {\n    var _a, _b;\n    const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some(ext => {\n      if (ext.uri === ddExtensionURI) {\n        return true;\n      }\n      return false;\n    });\n    if (!ddFound) {\n      if (this.ddExtID === 0) {\n        let maxID = 0;\n        sdp.media.forEach(m => {\n          var _a;\n          if (m.type !== 'video') {\n            return;\n          }\n          (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach(ext => {\n            if (ext.value > maxID) {\n              maxID = ext.value;\n            }\n          });\n        });\n        this.ddExtID = maxID + 1;\n      }\n      (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\n        value: this.ddExtID,\n        uri: ddExtensionURI\n      });\n    }\n  }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n  // found opus codec to add nack fb\n  let opusPayload = 0;\n  media.rtp.some(rtp => {\n    if (rtp.codec === 'opus') {\n      opusPayload = rtp.payload;\n      return true;\n    }\n    return false;\n  });\n  // add nack rtcpfb if not exist\n  if (opusPayload > 0) {\n    if (!media.rtcpFb) {\n      media.rtcpFb = [];\n    }\n    if (nackMids.includes(media.mid) && !media.rtcpFb.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\n      media.rtcpFb.push({\n        payload: opusPayload,\n        type: 'nack'\n      });\n    }\n    if (stereoMids.includes(media.mid)) {\n      media.fmtp.some(fmtp => {\n        if (fmtp.payload === opusPayload) {\n          if (!fmtp.config.includes('stereo=1')) {\n            fmtp.config += ';stereo=1';\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n  var _a;\n  const stereoMids = [];\n  const nackMids = [];\n  const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n  let opusPayload = 0;\n  sdpParsed.media.forEach(media => {\n    var _a;\n    if (media.type === 'audio') {\n      media.rtp.some(rtp => {\n        if (rtp.codec === 'opus') {\n          opusPayload = rtp.payload;\n          return true;\n        }\n        return false;\n      });\n      if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\n        nackMids.push(media.mid);\n      }\n      media.fmtp.some(fmtp => {\n        if (fmtp.payload === opusPayload) {\n          if (fmtp.config.includes('sprop-stereo=1')) {\n            stereoMids.push(media.mid);\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  });\n  return {\n    stereoMids,\n    nackMids\n  };\n}\nfunction ensureIPAddrMatchVersion(media) {\n  // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\n  // in edge case and return error when set sdp.This is not a\n  // sdk error but correct it if the issue detected.\n  if (media.connection) {\n    const isV6 = media.connection.ip.indexOf(':') >= 0;\n    if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\n      // fallback to dummy address\n      media.connection.ip = '0.0.0.0';\n      media.connection.version = 4;\n    }\n  }\n}\n\nconst defaultVideoCodec = 'vp8';\nconst publishDefaults = {\n  audioPreset: AudioPresets.music,\n  dtx: true,\n  red: true,\n  forceStereo: false,\n  simulcast: true,\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n  stopMicTrackOnMute: false,\n  videoCodec: defaultVideoCodec,\n  backupCodec: true\n};\nconst audioDefaults = {\n  deviceId: {\n    ideal: 'default'\n  },\n  autoGainControl: true,\n  echoCancellation: true,\n  noiseSuppression: true,\n  voiceIsolation: true\n};\nconst videoDefaults = {\n  deviceId: {\n    ideal: 'default'\n  },\n  resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n  adaptiveStream: false,\n  dynacast: false,\n  stopLocalTrackOnUnpublish: true,\n  reconnectPolicy: new DefaultReconnectPolicy(),\n  disconnectOnPageLeave: true,\n  webAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n  autoSubscribe: true,\n  maxRetries: 1,\n  peerConnectionTimeout: 15000,\n  websocketTimeout: 15000\n};\n\nvar PCTransportState;\n(function (PCTransportState) {\n  PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n  PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n  PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n  PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n  PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n  get needsPublisher() {\n    return this.isPublisherConnectionRequired;\n  }\n  get needsSubscriber() {\n    return this.isSubscriberConnectionRequired;\n  }\n  get currentState() {\n    return this.state;\n  }\n  constructor(rtcConfig, subscriberPrimary, loggerOptions) {\n    var _a;\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n    this.log = livekitLogger;\n    this.updateState = () => {\n      var _a;\n      const previousState = this.state;\n      const connectionStates = this.requiredTransports.map(tr => tr.getConnectionState());\n      if (connectionStates.every(st => st === 'connected')) {\n        this.state = PCTransportState.CONNECTED;\n      } else if (connectionStates.some(st => st === 'failed')) {\n        this.state = PCTransportState.FAILED;\n      } else if (connectionStates.some(st => st === 'connecting')) {\n        this.state = PCTransportState.CONNECTING;\n      } else if (connectionStates.every(st => st === 'closed')) {\n        this.state = PCTransportState.CLOSED;\n      } else if (connectionStates.some(st => st === 'closed')) {\n        this.state = PCTransportState.CLOSING;\n      } else if (connectionStates.every(st => st === 'new')) {\n        this.state = PCTransportState.NEW;\n      }\n      if (previousState !== this.state) {\n        this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n        (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n      }\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n    this.loggerOptions = loggerOptions;\n    this.isPublisherConnectionRequired = !subscriberPrimary;\n    this.isSubscriberConnectionRequired = subscriberPrimary;\n    this.publisher = new PCTransport(rtcConfig, loggerOptions);\n    this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n    this.publisher.onConnectionStateChange = this.updateState;\n    this.subscriber.onConnectionStateChange = this.updateState;\n    this.publisher.onIceConnectionStateChange = this.updateState;\n    this.subscriber.onIceConnectionStateChange = this.updateState;\n    this.publisher.onSignalingStatechange = this.updateState;\n    this.subscriber.onSignalingStatechange = this.updateState;\n    this.publisher.onIceCandidate = candidate => {\n      var _a;\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n    };\n    this.subscriber.onIceCandidate = candidate => {\n      var _a;\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n    };\n    // in subscriber primary mode, server side opens sub data channels.\n    this.subscriber.onDataChannel = ev => {\n      var _a;\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    this.subscriber.onTrack = ev => {\n      var _a;\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    this.publisher.onOffer = offer => {\n      var _a;\n      (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n    };\n    this.state = PCTransportState.NEW;\n    this.connectionLock = new _();\n    this.remoteOfferLock = new _();\n  }\n  get logContext() {\n    var _a, _b;\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n  requirePublisher() {\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.isPublisherConnectionRequired = require;\n    this.updateState();\n  }\n  requireSubscriber() {\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.isSubscriberConnectionRequired = require;\n    this.updateState();\n  }\n  createAndSendPublisherOffer(options) {\n    return this.publisher.createAndSendOffer(options);\n  }\n  setPublisherAnswer(sd) {\n    return this.publisher.setRemoteDescription(sd);\n  }\n  removeTrack(sender) {\n    return this.publisher.removeTrack(sender);\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.publisher && this.publisher.getSignallingState() !== 'closed') {\n        const publisher = this.publisher;\n        for (const sender of publisher.getSenders()) {\n          try {\n            // TODO: react-native-webrtc doesn't have removeTrack yet.\n            if (publisher.canRemoveTrack()) {\n              publisher.removeTrack(sender);\n            }\n          } catch (e) {\n            this.log.warn('could not removeTrack', Object.assign(Object.assign({}, this.logContext), {\n              error: e\n            }));\n          }\n        }\n      }\n      yield Promise.all([this.publisher.close(), this.subscriber.close()]);\n      this.updateState();\n    });\n  }\n  triggerIceRestart() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.subscriber.restartingIce = true;\n      // only restart publisher if it's needed\n      if (this.needsPublisher) {\n        yield this.createAndSendPublisherOffer({\n          iceRestart: true\n        });\n      }\n    });\n  }\n  addIceCandidate(candidate, target) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (target === SignalTarget.PUBLISHER) {\n        yield this.publisher.addIceCandidate(candidate);\n      } else {\n        yield this.subscriber.addIceCandidate(candidate);\n      }\n    });\n  }\n  createSubscriberAnswerFromOffer(sd) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.log.debug('received server offer', Object.assign(Object.assign({}, this.logContext), {\n        RTCSdpType: sd.type,\n        sdp: sd.sdp,\n        signalingState: this.subscriber.getSignallingState().toString()\n      }));\n      const unlock = yield this.remoteOfferLock.lock();\n      try {\n        yield this.subscriber.setRemoteDescription(sd);\n        // answer the offer\n        const answer = yield this.subscriber.createAndSetAnswer();\n        return answer;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  updateConfiguration(config, iceRestart) {\n    this.publisher.setConfiguration(config);\n    this.subscriber.setConfiguration(config);\n    if (iceRestart) {\n      this.triggerIceRestart();\n    }\n  }\n  ensurePCTransportConnection(abortController, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.connectionLock.lock();\n      try {\n        if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== 'connected' && this.publisher.getConnectionState() !== 'connecting') {\n          this.log.debug('negotiation required, start negotiating', this.logContext);\n          this.publisher.negotiate();\n        }\n        yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map(transport => this.ensureTransportConnected(transport, abortController, timeout)));\n      } finally {\n        unlock();\n      }\n    });\n  }\n  negotiate(abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        const negotiationTimeout = setTimeout(() => {\n          reject('negotiation timed out');\n        }, this.peerConnectionTimeout);\n        const abortHandler = () => {\n          clearTimeout(negotiationTimeout);\n          reject('negotiation aborted');\n        };\n        abortController.signal.addEventListener('abort', abortHandler);\n        this.publisher.once(PCEvents.NegotiationStarted, () => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          this.publisher.once(PCEvents.NegotiationComplete, () => {\n            clearTimeout(negotiationTimeout);\n            resolve();\n          });\n        });\n        yield this.publisher.negotiate(e => {\n          clearTimeout(negotiationTimeout);\n          reject(e);\n        });\n      }));\n    });\n  }\n  addPublisherTransceiver(track, transceiverInit) {\n    return this.publisher.addTransceiver(track, transceiverInit);\n  }\n  addPublisherTrack(track) {\n    return this.publisher.addTrack(track);\n  }\n  createPublisherDataChannel(label, dataChannelDict) {\n    return this.publisher.createDataChannel(label, dataChannelDict);\n  }\n  /**\n   * Returns the first required transport's address if no explicit target is specified\n   */\n  getConnectedAddress(target) {\n    if (target === SignalTarget.PUBLISHER) {\n      return this.publisher.getConnectedAddress();\n    } else if (target === SignalTarget.SUBSCRIBER) {\n      return this.publisher.getConnectedAddress();\n    }\n    return this.requiredTransports[0].getConnectedAddress();\n  }\n  get requiredTransports() {\n    const transports = [];\n    if (this.isPublisherConnectionRequired) {\n      transports.push(this.publisher);\n    }\n    if (this.isSubscriberConnectionRequired) {\n      transports.push(this.subscriber);\n    }\n    return transports;\n  }\n  ensureTransportConnected(pcTransport_1, abortController_1) {\n    return __awaiter(this, arguments, void 0, function (pcTransport, abortController) {\n      var _this = this;\n      let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n      return function* () {\n        const connectionState = pcTransport.getConnectionState();\n        if (connectionState === 'connected') {\n          return;\n        }\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\n          const abortHandler = () => {\n            this.log.warn('abort transport connection', this.logContext);\n            CriticalTimers.clearTimeout(connectTimeout);\n            reject(new ConnectionError('room connection has been cancelled', ConnectionErrorReason.Cancelled));\n          };\n          if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n            abortHandler();\n          }\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', abortHandler);\n          const connectTimeout = CriticalTimers.setTimeout(() => {\n            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n            reject(new ConnectionError('could not establish pc connection', ConnectionErrorReason.InternalError));\n          }, timeout);\n          while (this.state !== PCTransportState.CONNECTED) {\n            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n              reject(new ConnectionError('room connection has been cancelled', ConnectionErrorReason.Cancelled));\n              return;\n            }\n          }\n          CriticalTimers.clearTimeout(connectTimeout);\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n          resolve();\n        }));\n      }();\n    });\n  }\n}\n\n// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Specialized error handling for RPC methods.\n *\n * Instances of this type, when thrown in a method handler, will have their `message`\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\n *\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\n */\nclass RpcError extends Error {\n  /**\n   * Creates an error object with the given code and message, plus an optional data payload.\n   *\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\n   *\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\n   */\n  constructor(code, message, data) {\n    super(message);\n    this.code = code;\n    this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\n    this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\n  }\n  /**\n   * @internal\n   */\n  static fromProto(proto) {\n    return new RpcError(proto.code, proto.message, proto.data);\n  }\n  /**\n   * @internal\n   */\n  toProto() {\n    return new RpcError$1({\n      code: this.code,\n      message: this.message,\n      data: this.data\n    });\n  }\n  /**\n   * Creates an error object from the code, with an auto-populated message.\n   *\n   * @internal\n   */\n  static builtIn(key, data) {\n    return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\n  }\n}\nRpcError.MAX_MESSAGE_BYTES = 256;\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\nRpcError.ErrorCode = {\n  APPLICATION_ERROR: 1500,\n  CONNECTION_TIMEOUT: 1501,\n  RESPONSE_TIMEOUT: 1502,\n  RECIPIENT_DISCONNECTED: 1503,\n  RESPONSE_PAYLOAD_TOO_LARGE: 1504,\n  SEND_FAILED: 1505,\n  UNSUPPORTED_METHOD: 1400,\n  RECIPIENT_NOT_FOUND: 1401,\n  REQUEST_PAYLOAD_TOO_LARGE: 1402,\n  UNSUPPORTED_SERVER: 1403,\n  UNSUPPORTED_VERSION: 1404\n};\n/**\n * @internal\n */\nRpcError.ErrorMessage = {\n  APPLICATION_ERROR: 'Application error in method handler',\n  CONNECTION_TIMEOUT: 'Connection timeout',\n  RESPONSE_TIMEOUT: 'Response timeout',\n  RECIPIENT_DISCONNECTED: 'Recipient disconnected',\n  RESPONSE_PAYLOAD_TOO_LARGE: 'Response payload too large',\n  SEND_FAILED: 'Failed to send',\n  UNSUPPORTED_METHOD: 'Method not supported at destination',\n  RECIPIENT_NOT_FOUND: 'Recipient not found',\n  REQUEST_PAYLOAD_TOO_LARGE: 'Request payload too large',\n  UNSUPPORTED_SERVER: 'RPC not supported by server',\n  UNSUPPORTED_VERSION: 'Unsupported RPC version'\n};\n/*\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\n */\nconst MAX_PAYLOAD_BYTES = 15360; // 15 KB\n/**\n * @internal\n */\nfunction byteLength(str) {\n  const encoder = new TextEncoder();\n  return encoder.encode(str).length;\n}\n/**\n * @internal\n */\nfunction truncateBytes(str, maxBytes) {\n  if (byteLength(str) <= maxBytes) {\n    return str;\n  }\n  let low = 0;\n  let high = str.length;\n  const encoder = new TextEncoder();\n  while (low < high) {\n    const mid = Math.floor((low + high + 1) / 2);\n    if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return str.slice(0, low);\n}\n\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n  if (!prevStats) {\n    return 0;\n  }\n  let bytesNow;\n  let bytesPrev;\n  if ('bytesReceived' in currentStats) {\n    bytesNow = currentStats.bytesReceived;\n    bytesPrev = prevStats.bytesReceived;\n  } else if ('bytesSent' in currentStats) {\n    bytesNow = currentStats.bytesSent;\n    bytesPrev = prevStats.bytesSent;\n  }\n  if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n    return 0;\n  }\n  return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\n\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n  /** @internal */\n  get sender() {\n    return this._sender;\n  }\n  /** @internal */\n  set sender(sender) {\n    this._sender = sender;\n  }\n  get constraints() {\n    return this._constraints;\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, kind, constraints) {\n    let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n    super(mediaTrack, kind, loggerOptions);\n    this.manuallyStopped = false;\n    this._isUpstreamPaused = false;\n    this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext));\n    this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {\n      yield this.pauseUpstream();\n    }), 5000);\n    this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {\n      this.debouncedTrackMuteHandler.cancel('unmute');\n      yield this.resumeUpstream();\n    });\n    this.handleEnded = () => {\n      if (this.isInBackground) {\n        this.reacquireTrack = true;\n      }\n      this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n      this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n      this.emit(TrackEvent.Ended, this);\n    };\n    this.reacquireTrack = false;\n    this.providedByUser = userProvidedTrack;\n    this.muteLock = new _();\n    this.pauseUpstreamLock = new _();\n    this.processorLock = new _();\n    this.restartLock = new _();\n    this.setMediaStreamTrack(mediaTrack, true);\n    // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n    this._constraints = mediaTrack.getConstraints();\n    if (constraints) {\n      this._constraints = constraints;\n    }\n  }\n  get id() {\n    return this._mediaStreamTrack.id;\n  }\n  get dimensions() {\n    if (this.kind !== Track.Kind.Video) {\n      return undefined;\n    }\n    const {\n      width,\n      height\n    } = this._mediaStreamTrack.getSettings();\n    if (width && height) {\n      return {\n        width,\n        height\n      };\n    }\n    return undefined;\n  }\n  get isUpstreamPaused() {\n    return this._isUpstreamPaused;\n  }\n  get isUserProvided() {\n    return this.providedByUser;\n  }\n  get mediaStreamTrack() {\n    var _a, _b;\n    return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n  }\n  get isLocal() {\n    return true;\n  }\n  /**\n   * @internal\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\n   */\n  getSourceTrackSettings() {\n    return this._mediaStreamTrack.getSettings();\n  }\n  setMediaStreamTrack(newTrack, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (newTrack === this._mediaStreamTrack && !force) {\n        return;\n      }\n      if (this._mediaStreamTrack) {\n        // detach\n        this.attachedElements.forEach(el => {\n          detachTrack(this._mediaStreamTrack, el);\n        });\n        this.debouncedTrackMuteHandler.cancel('new-track');\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n      }\n      this.mediaStream = new MediaStream([newTrack]);\n      if (newTrack) {\n        newTrack.addEventListener('ended', this.handleEnded);\n        // when underlying track emits mute, it indicates that the device is unable\n        // to produce media. In this case we'll need to signal with remote that\n        // the track is \"muted\"\n        // note this is different from LocalTrack.mute because we do not want to\n        // touch MediaStreamTrack.enabled\n        newTrack.addEventListener('mute', this.handleTrackMuteEvent);\n        newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);\n        this._constraints = newTrack.getConstraints();\n      }\n      let processedTrack;\n      if (this.processor && newTrack) {\n        const unlock = yield this.processorLock.lock();\n        try {\n          this.log.debug('restarting processor', this.logContext);\n          if (this.kind === 'unknown') {\n            throw TypeError('cannot set processor on track of unknown kind');\n          }\n          if (this.processorElement) {\n            attachToElement(newTrack, this.processorElement);\n            // ensure the processorElement itself stays muted\n            this.processorElement.muted = true;\n          }\n          yield this.processor.restart({\n            track: newTrack,\n            kind: this.kind,\n            element: this.processorElement\n          });\n          processedTrack = this.processor.processedTrack;\n        } finally {\n          unlock();\n        }\n      }\n      if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\n        yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n      }\n      // if `newTrack` is different from the existing track, stop the\n      // older track just before replacing it\n      if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n        this._mediaStreamTrack.stop();\n      }\n      this._mediaStreamTrack = newTrack;\n      if (newTrack) {\n        // sync muted state with the enabled state of the newly provided track\n        this._mediaStreamTrack.enabled = !this.isMuted;\n        // when a valid track is replace, we'd want to start producing\n        yield this.resumeUpstream();\n        this.attachedElements.forEach(el => {\n          attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n        });\n      }\n    });\n  }\n  waitForDimensions() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this = this;\n      let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n      return function* () {\n        var _a;\n        if (_this.kind === Track.Kind.Audio) {\n          throw new Error('cannot get dimensions for audio tracks');\n        }\n        if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {\n          // browsers report wrong initial resolution on iOS.\n          // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n          yield sleep(10);\n        }\n        const started = Date.now();\n        while (Date.now() - started < timeout) {\n          const dims = _this.dimensions;\n          if (dims) {\n            return dims;\n          }\n          yield sleep(50);\n        }\n        throw new TrackInvalidError('unable to get track dimensions after timeout');\n      }();\n    });\n  }\n  setDeviceId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n        return true;\n      }\n      this._constraints.deviceId = deviceId;\n      // when track is muted, underlying media stream track is stopped and\n      // will be restarted later\n      if (this.isMuted) {\n        return true;\n      }\n      yield this.restartTrack();\n      return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n    });\n  }\n  /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */\n  getDeviceId() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this2 = this;\n      let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return function* () {\n        // screen share doesn't have a usable device id\n        if (_this2.source === Track.Source.ScreenShare) {\n          return;\n        }\n        const {\n          deviceId,\n          groupId\n        } = _this2._mediaStreamTrack.getSettings();\n        const kind = _this2.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';\n        return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\n      }();\n    });\n  }\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(true);\n      return this;\n    });\n  }\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(false);\n      return this;\n    });\n  }\n  replaceTrack(track, userProvidedOrOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        throw new TrackInvalidError('unable to replace an unpublished track');\n      }\n      let userProvidedTrack;\n      let stopProcessor;\n      if (typeof userProvidedOrOptions === 'boolean') {\n        userProvidedTrack = userProvidedOrOptions;\n      } else if (userProvidedOrOptions !== undefined) {\n        userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\n        stopProcessor = userProvidedOrOptions.stopProcessor;\n      }\n      this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\n      this.log.debug('replace MediaStreamTrack', this.logContext);\n      yield this.setMediaStreamTrack(track);\n      // this must be synced *after* setting mediaStreamTrack above, since it relies\n      // on the previous state in order to cleanup\n      if (stopProcessor && this.processor) {\n        yield this.stopProcessor();\n      }\n      return this;\n    });\n  }\n  restart(constraints) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.manuallyStopped = false;\n      const unlock = yield this.restartLock.lock();\n      try {\n        if (!constraints) {\n          constraints = this._constraints;\n        }\n        const {\n            deviceId,\n            facingMode\n          } = constraints,\n          otherConstraints = __rest(constraints, [\"deviceId\", \"facingMode\"]);\n        this.log.debug('restarting track with constraints', Object.assign(Object.assign({}, this.logContext), {\n          constraints\n        }));\n        const streamConstraints = {\n          audio: false,\n          video: false\n        };\n        if (this.kind === Track.Kind.Video) {\n          streamConstraints.video = deviceId || facingMode ? {\n            deviceId,\n            facingMode\n          } : true;\n        } else {\n          streamConstraints.audio = deviceId ? {\n            deviceId\n          } : true;\n        }\n        // these steps are duplicated from setMediaStreamTrack because we must stop\n        // the previous tracks before new tracks can be acquired\n        this.attachedElements.forEach(el => {\n          detachTrack(this.mediaStreamTrack, el);\n        });\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n        // on Safari, the old audio track must be stopped before attempting to acquire\n        // the new track, otherwise the new track will stop with\n        // 'A MediaStreamTrack ended due to a capture failure`\n        this._mediaStreamTrack.stop();\n        // create new track and attach\n        const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n        const newTrack = mediaStream.getTracks()[0];\n        yield newTrack.applyConstraints(otherConstraints);\n        newTrack.addEventListener('ended', this.handleEnded);\n        this.log.debug('re-acquired MediaStreamTrack', this.logContext);\n        yield this.setMediaStreamTrack(newTrack);\n        this._constraints = constraints;\n        this.emit(TrackEvent.Restarted, this);\n        if (this.manuallyStopped) {\n          this.log.warn('track was stopped during a restart, stopping restarted track', this.logContext);\n          this.stop();\n        }\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  setTrackMuted(muted) {\n    this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? 'muted' : 'unmuted'), this.logContext);\n    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n      return;\n    }\n    this.isMuted = muted;\n    this._mediaStreamTrack.enabled = !muted;\n    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n  }\n  get needsReAcquisition() {\n    return this._mediaStreamTrack.readyState !== 'live' || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile()) return;\n      this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n        this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n        yield this.restart();\n        this.reacquireTrack = false;\n      }\n    });\n  }\n  stop() {\n    var _a;\n    this.manuallyStopped = true;\n    super.stop();\n    this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n    this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n    this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n    (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.processor = undefined;\n  }\n  /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === true) {\n          return;\n        }\n        if (!this.sender) {\n          this.log.warn('unable to pause upstream for an unpublished track', this.logContext);\n          return;\n        }\n        this._isUpstreamPaused = true;\n        this.emit(TrackEvent.UpstreamPaused, this);\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '12.0') < 0) {\n          // https://bugs.webkit.org/show_bug.cgi?id=184911\n          throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');\n        }\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\n          yield this.sender.replaceTrack(null);\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === false) {\n          return;\n        }\n        if (!this.sender) {\n          this.log.warn('unable to resume upstream for an unpublished track', this.logContext);\n          return;\n        }\n        this._isUpstreamPaused = false;\n        this.emit(TrackEvent.UpstreamResumed, this);\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\n          // this operation is noop if mediastreamtrack is already being sent\n          yield this.sender.replaceTrack(this.mediaStreamTrack);\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */\n  getRTCStatsReport() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return;\n      }\n      const statsReport = yield this.sender.getStats();\n      return statsReport;\n    });\n  }\n  /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */\n  setProcessor(processor_1) {\n    return __awaiter(this, arguments, void 0, function (processor) {\n      var _this3 = this;\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        var _a;\n        const unlock = yield _this3.processorLock.lock();\n        try {\n          _this3.log.debug('setting up processor', _this3.logContext);\n          const processorElement = document.createElement(_this3.kind);\n          const processorOptions = {\n            kind: _this3.kind,\n            track: _this3._mediaStreamTrack,\n            element: processorElement,\n            audioContext: _this3.audioContext\n          };\n          yield processor.init(processorOptions);\n          _this3.log.debug('processor initialized', _this3.logContext);\n          if (_this3.processor) {\n            yield _this3.stopProcessor();\n          }\n          if (_this3.kind === 'unknown') {\n            throw TypeError('cannot set processor on track of unknown kind');\n          }\n          attachToElement(_this3._mediaStreamTrack, processorElement);\n          processorElement.muted = true;\n          processorElement.play().catch(error => _this3.log.error('failed to play processor element', Object.assign(Object.assign({}, _this3.logContext), {\n            error\n          })));\n          _this3.processor = processor;\n          _this3.processorElement = processorElement;\n          if (_this3.processor.processedTrack) {\n            for (const el of _this3.attachedElements) {\n              if (el !== _this3.processorElement && showProcessedStreamLocally) {\n                detachTrack(_this3._mediaStreamTrack, el);\n                attachToElement(_this3.processor.processedTrack, el);\n              }\n            }\n            yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\n          }\n          _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\n        } finally {\n          unlock();\n        }\n      }();\n    });\n  }\n  getProcessor() {\n    return this.processor;\n  }\n  /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */\n  stopProcessor() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this4 = this;\n      let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return function* () {\n        var _a, _b;\n        if (!_this4.processor) return;\n        _this4.log.debug('stopping processor', _this4.logContext);\n        (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n        yield _this4.processor.destroy();\n        _this4.processor = undefined;\n        if (!keepElement) {\n          (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n          _this4.processorElement = undefined;\n        }\n        // apply original track constraints in case the processor changed them\n        yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);\n        // force re-setting of the mediaStreamTrack on the sender\n        yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);\n        _this4.emit(TrackEvent.TrackProcessorUpdate);\n      }();\n    });\n  }\n}\n\nclass LocalAudioTrack extends LocalTrack {\n  /**\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\n   */\n  get enhancedNoiseCancellation() {\n    return this.isKrispNoiseFilterEnabled;\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n    /** @internal */\n    this.stopOnMute = false;\n    this.isKrispNoiseFilterEnabled = false;\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n        return;\n      }\n      if (stats && this.prevStats) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.handleKrispNoiseFilterEnable = () => {\n      this.isKrispNoiseFilterEnabled = true;\n      this.log.debug(\"Krisp noise filter enabled\", this.logContext);\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\n    };\n    this.handleKrispNoiseFilterDisable = () => {\n      this.isKrispNoiseFilterEnabled = false;\n      this.log.debug(\"Krisp noise filter disabled\", this.logContext);\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\n    };\n    this.audioContext = audioContext;\n    this.checkForSilence();\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.isMuted) {\n          this.log.debug('Track already muted', this.logContext);\n          return this;\n        }\n        // disabled special handling as it will cause BT headsets to switch communication modes\n        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n          this.log.debug('stopping mic track', this.logContext);\n          // also stop the track, so that microphone indicator is turned off\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (!this.isMuted) {\n          this.log.debug('Track already unmuted', this.logContext);\n          return this;\n        }\n        const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === 'ended' || deviceHasChanged) && !this.isUserProvided) {\n          this.log.debug('reacquiring mic track', this.logContext);\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          audio: options\n        });\n        if (typeof streamConstraints.audio !== 'boolean') {\n          constraints = streamConstraints.audio;\n        }\n      }\n      yield this.restart(constraints);\n    });\n  }\n  restart(constraints) {\n    const _super = Object.create(null, {\n      restart: {\n        get: () => super.restart\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const track = yield _super.restart.call(this, constraints);\n      this.checkForSilence();\n      return track;\n    });\n  }\n  /* @internal */\n  startMonitor() {\n    if (!isWeb()) {\n      return;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  setProcessor(processor) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.processorLock.lock();\n      try {\n        if (!isReactNative() && !this.audioContext) {\n          throw Error('Audio context needs to be set on LocalAudioTrack in order to enable processors');\n        }\n        if (this.processor) {\n          yield this.stopProcessor();\n        }\n        const processorOptions = {\n          kind: this.kind,\n          track: this._mediaStreamTrack,\n          // RN won't have or use AudioContext\n          audioContext: this.audioContext\n        };\n        this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n        yield processor.init(processorOptions);\n        this.processor = processor;\n        if (this.processor.processedTrack) {\n          yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n          this.processor.processedTrack.addEventListener('enable-lk-krisp-noise-filter', this.handleKrispNoiseFilterEnable);\n          this.processor.processedTrack.addEventListener('disable-lk-krisp-noise-filter', this.handleKrispNoiseFilterDisable);\n        }\n        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\n      } finally {\n        unlock();\n      }\n    });\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(audioContext) {\n    this.audioContext = audioContext;\n  }\n  getSenderStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return undefined;\n      }\n      const stats = yield this.sender.getStats();\n      let audioStats;\n      stats.forEach(v => {\n        if (v.type === 'outbound-rtp') {\n          audioStats = {\n            type: 'audio',\n            streamId: v.id,\n            packetsSent: v.packetsSent,\n            packetsLost: v.packetsLost,\n            bytesSent: v.bytesSent,\n            timestamp: v.timestamp,\n            roundTripTime: v.roundTripTime,\n            jitter: v.jitter\n          };\n        }\n      });\n      return audioStats;\n    });\n  }\n  checkForSilence() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const trackIsSilent = yield detectSilence(this);\n      if (trackIsSilent) {\n        if (!this.isMuted) {\n          this.log.warn('silence detected on local audio track', this.logContext);\n        }\n        this.emit(TrackEvent.AudioSilenceDetected);\n      }\n      return trackIsSilent;\n    });\n  }\n}\n\n/** @internal */\nfunction mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n  switch (mediaStreamTrack.kind) {\n    case 'audio':\n      return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n    case 'video':\n      return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n    default:\n      throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n  }\n}\n/* @internal */\nconst presets169 = Object.values(VideoPresets);\n/* @internal */\nconst presets43 = Object.values(VideoPresets43);\n/* @internal */\nconst presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */\nconst defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];\n/* @internal */\nconst defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];\n/* @internal */\nconst computeDefaultScreenShareSimulcastPresets = fromPreset => {\n  const layers = [{\n    scaleResolutionDownBy: 2,\n    fps: fromPreset.encoding.maxFramerate\n  }];\n  return layers.map(t => {\n    var _a, _b;\n    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n  });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = ['q', 'h', 'f'];\n/* @internal */\nfunction computeVideoEncodings(isScreenShare, width, height, options) {\n  var _a, _b;\n  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n  if (isScreenShare) {\n    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n  }\n  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n    // when we aren't simulcasting or svc, will need to return a single encoding without\n    // capping bandwidth. we always require a encoding for dynacast\n    return [{}];\n  }\n  if (!videoEncoding) {\n    // find the right encoding based on width/height\n    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n    livekitLogger.debug('using video encoding', videoEncoding);\n  }\n  const sourceFramerate = videoEncoding.maxFramerate;\n  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n  if (scalabilityMode && isSVCCodec(videoCodec)) {\n    const sm = new ScalabilityMode(scalabilityMode);\n    const encodings = [];\n    if (sm.spatial > 3) {\n      throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n    }\n    // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\n    // that SVC mode should be used. Safari still works this way.\n    // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\n    // before M113.\n    // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\n    const browser = getBrowser();\n    if (isSafari() ||\n    // Even tho RN runs M114, it does not produce SVC layers when a single encoding\n    // is provided. So we'll use the legacy SVC specification for now.\n    // TODO: when we upstream libwebrtc, this will need additional verification\n    isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '113') < 0) {\n      const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\n      for (let i = 0; i < sm.spatial; i += 1) {\n        // in legacy SVC, scaleResolutionDownBy cannot be set\n        encodings.push({\n          rid: videoRids[2 - i],\n          maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\n          maxFramerate: original.encoding.maxFramerate\n        });\n      }\n      // legacy SVC, scalabilityMode is set only on the first encoding\n      /* @ts-ignore */\n      encodings[0].scalabilityMode = scalabilityMode;\n    } else {\n      encodings.push({\n        maxBitrate: videoEncoding.maxBitrate,\n        maxFramerate: original.encoding.maxFramerate,\n        /* @ts-ignore */\n        scalabilityMode: scalabilityMode\n      });\n    }\n    if (original.encoding.priority) {\n      encodings[0].priority = original.encoding.priority;\n      encodings[0].networkPriority = original.encoding.priority;\n    }\n    livekitLogger.debug(\"using svc encoding\", {\n      encodings\n    });\n    return encodings;\n  }\n  if (!useSimulcast) {\n    return [videoEncoding];\n  }\n  let presets = [];\n  if (isScreenShare) {\n    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n  } else {\n    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n  }\n  let midPreset;\n  if (presets.length > 0) {\n    const lowPreset = presets[0];\n    if (presets.length > 1) {\n      [, midPreset] = presets;\n    }\n    // NOTE:\n    //   1. Ordering of these encodings is important. Chrome seems\n    //      to use the index into encodings to decide which layer\n    //      to disable when CPU constrained.\n    //      So encodings should be ordered in increasing spatial\n    //      resolution order.\n    //   2. livekit-server translates rids into layers. So, all encodings\n    //      should have the base layer `q` and then more added\n    //      based on other conditions.\n    const size = Math.max(width, height);\n    if (size >= 960 && midPreset) {\n      return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);\n    }\n    if (size >= 480) {\n      return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);\n    }\n  }\n  return encodingsFromPresets(width, height, [original]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n  var _a, _b, _c, _d;\n  // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n  if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n    // backup codec publishing is disabled\n    return;\n  }\n  if (videoCodec !== opts.backupCodec.codec) {\n    livekitLogger.warn('requested a different codec than specified as backup', {\n      serverRequested: videoCodec,\n      backup: opts.backupCodec.codec\n    });\n  }\n  opts.videoCodec = videoCodec;\n  // use backup encoding setting as videoEncoding for backup codec publishing\n  opts.videoEncoding = opts.backupCodec.encoding;\n  const settings = track.mediaStreamTrack.getSettings();\n  const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n  // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\n  if (track.source === Track.Source.ScreenShare && opts.simulcast) {\n    opts.simulcast = false;\n  }\n  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n  return encodings;\n}\n/* @internal */\nfunction determineAppropriateEncoding(isScreenShare, width, height, codec) {\n  const presets = presetsForResolution(isScreenShare, width, height);\n  let {\n    encoding\n  } = presets[0];\n  // handle portrait by swapping dimensions\n  const size = Math.max(width, height);\n  for (let i = 0; i < presets.length; i += 1) {\n    const preset = presets[i];\n    encoding = preset.encoding;\n    if (preset.width >= size) {\n      break;\n    }\n  }\n  // presets are based on the assumption of vp8 as a codec\n  // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n  // users should override these with ones that are optimized for their use case\n  // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n  // bitrate for non-SVC codecs does not include other simulcast layers.\n  if (codec) {\n    switch (codec) {\n      case 'av1':\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.7;\n        break;\n      case 'vp9':\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.85;\n        break;\n    }\n  }\n  return encoding;\n}\n/* @internal */\nfunction presetsForResolution(isScreenShare, width, height) {\n  if (isScreenShare) {\n    return presetsScreenShare;\n  }\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n    return presets169;\n  }\n  return presets43;\n}\n/* @internal */\nfunction defaultSimulcastLayers(isScreenShare, original) {\n  if (isScreenShare) {\n    return computeDefaultScreenShareSimulcastPresets(original);\n  }\n  const {\n    width,\n    height\n  } = original;\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n    return defaultSimulcastPresets169;\n  }\n  return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\n  const encodings = [];\n  presets.forEach((preset, idx) => {\n    if (idx >= videoRids.length) {\n      return;\n    }\n    const size = Math.min(width, height);\n    const rid = videoRids[idx];\n    const encoding = {\n      rid,\n      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n      maxBitrate: preset.encoding.maxBitrate\n    };\n    // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\n    // original encoding doesn't get bumped unintentionally by any of the other layers\n    const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\n    if (maxFramerate) {\n      encoding.maxFramerate = maxFramerate;\n    }\n    const canSetPriority = isFireFox() || idx === 0;\n    if (preset.encoding.priority && canSetPriority) {\n      encoding.priority = preset.encoding.priority;\n      encoding.networkPriority = preset.encoding.priority;\n    }\n    encodings.push(encoding);\n  });\n  // RN ios simulcast requires all same framerates.\n  if (isReactNative() && getReactNativeOs() === 'ios') {\n    let topFramerate = undefined;\n    encodings.forEach(encoding => {\n      if (!topFramerate) {\n        topFramerate = encoding.maxFramerate;\n      } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n        topFramerate = encoding.maxFramerate;\n      }\n    });\n    let notifyOnce = true;\n    encodings.forEach(encoding => {\n      var _a;\n      if (encoding.maxFramerate != topFramerate) {\n        if (notifyOnce) {\n          notifyOnce = false;\n          livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n        }\n        livekitLogger.info(\"Setting framerate of encoding \\\"\".concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', \"\\\" to \").concat(topFramerate));\n        encoding.maxFramerate = topFramerate;\n      }\n    });\n  }\n  return encodings;\n}\n/** @internal */\nfunction sortPresets(presets) {\n  if (!presets) return;\n  return presets.sort((a, b) => {\n    const {\n      encoding: aEnc\n    } = a;\n    const {\n      encoding: bEnc\n    } = b;\n    if (aEnc.maxBitrate > bEnc.maxBitrate) {\n      return 1;\n    }\n    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n    }\n    return 0;\n  });\n}\n/** @internal */\nclass ScalabilityMode {\n  constructor(scalabilityMode) {\n    const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n    if (!results) {\n      throw new Error('invalid scalability mode');\n    }\n    this.spatial = parseInt(results[1]);\n    this.temporal = parseInt(results[2]);\n    if (results.length > 3) {\n      switch (results[3]) {\n        case 'h':\n        case '_KEY':\n        case '_KEY_SHIFT':\n          this.suffix = results[3];\n      }\n    }\n  }\n  toString() {\n    var _a;\n    return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');\n  }\n}\nfunction getDefaultDegradationPreference(track) {\n  // a few of reasons we have different default paths:\n  // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\n  // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\n  if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\n    return 'maintain-resolution';\n  } else {\n    return 'balanced';\n  }\n}\n\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n  get sender() {\n    return this._sender;\n  }\n  set sender(sender) {\n    this._sender = sender;\n    if (this.degradationPreference) {\n      this.setDegradationPreference(this.degradationPreference);\n    }\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n    /* @internal */\n    this.simulcastCodecs = new Map();\n    this.degradationPreference = 'balanced';\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n        return;\n      }\n      const statsMap = new Map(stats.map(s => [s.rid, s]));\n      if (this.prevStats) {\n        let totalBitrate = 0;\n        statsMap.forEach((s, key) => {\n          var _a;\n          const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n          totalBitrate += computeBitrate(s, prev);\n        });\n        this._currentBitrate = totalBitrate;\n      }\n      this.prevStats = statsMap;\n    });\n    this.senderLock = new _();\n  }\n  get isSimulcast() {\n    if (this.sender && this.sender.getParameters().encodings.length > 1) {\n      return true;\n    }\n    return false;\n  }\n  /* @internal */\n  startMonitor(signalClient) {\n    var _a;\n    this.signalClient = signalClient;\n    if (!isWeb()) {\n      return;\n    }\n    // save original encodings\n    // TODO : merge simulcast tracks stats\n    const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n    if (params) {\n      this.encodings = params.encodings;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  stop() {\n    this._mediaStreamTrack.getConstraints();\n    this.simulcastCodecs.forEach(trackInfo => {\n      trackInfo.mediaStreamTrack.stop();\n    });\n    super.stop();\n  }\n  pauseUpstream() {\n    const _super = Object.create(null, {\n      pauseUpstream: {\n        get: () => super.pauseUpstream\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      var _d;\n      yield _super.pauseUpstream.call(this);\n      try {\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\n          _c = _g.value;\n          _e = false;\n          const sc = _c;\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  resumeUpstream() {\n    const _super = Object.create(null, {\n      resumeUpstream: {\n        get: () => super.resumeUpstream\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_2, _b, _c;\n      var _d;\n      yield _super.resumeUpstream.call(this);\n      try {\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\n          _c = _g.value;\n          _e = false;\n          const sc = _c;\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.isMuted) {\n          this.log.debug('Track already muted', this.logContext);\n          return this;\n        }\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          this.log.debug('stopping camera track', this.logContext);\n          // also stop the track, so that camera indicator is turned off\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (!this.isMuted) {\n          this.log.debug('Track already unmuted', this.logContext);\n          return this;\n        }\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          this.log.debug('reacquiring camera track', this.logContext);\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  setTrackMuted(muted) {\n    super.setTrackMuted(muted);\n    for (const sc of this.simulcastCodecs.values()) {\n      sc.mediaStreamTrack.enabled = !muted;\n    }\n  }\n  getSenderStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return [];\n      }\n      const items = [];\n      const stats = yield this.sender.getStats();\n      stats.forEach(v => {\n        var _a;\n        if (v.type === 'outbound-rtp') {\n          const vs = {\n            type: 'video',\n            streamId: v.id,\n            frameHeight: v.frameHeight,\n            frameWidth: v.frameWidth,\n            framesPerSecond: v.framesPerSecond,\n            framesSent: v.framesSent,\n            firCount: v.firCount,\n            pliCount: v.pliCount,\n            nackCount: v.nackCount,\n            packetsSent: v.packetsSent,\n            bytesSent: v.bytesSent,\n            qualityLimitationReason: v.qualityLimitationReason,\n            qualityLimitationDurations: v.qualityLimitationDurations,\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\n            rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\n            targetBitrate: v.targetBitrate,\n            timestamp: v.timestamp\n          };\n          //locate the appropriate remote-inbound-rtp item\n          const r = stats.get(v.remoteId);\n          if (r) {\n            vs.jitter = r.jitter;\n            vs.packetsLost = r.packetsLost;\n            vs.roundTripTime = r.roundTripTime;\n          }\n          items.push(vs);\n        }\n      });\n      // make sure highest res layer is always first\n      items.sort((a, b) => {\n        var _a, _b;\n        return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\n      });\n      return items;\n    });\n  }\n  setPublishingQuality(maxQuality) {\n    const qualities = [];\n    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {\n      qualities.push(new SubscribedQuality({\n        quality: q,\n        enabled: q <= maxQuality\n      }));\n    }\n    this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n    this.setPublishingLayers(qualities);\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_3, _b, _c;\n      var _d;\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          video: options\n        });\n        if (typeof streamConstraints.video !== 'boolean') {\n          constraints = streamConstraints.video;\n        }\n      }\n      yield this.restart(constraints);\n      try {\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\n          _c = _g.value;\n          _e = false;\n          const sc = _c;\n          if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== 'closed') {\n            sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n            yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n  }\n  setProcessor(processor_1) {\n    const _super = Object.create(null, {\n      setProcessor: {\n        get: () => super.setProcessor\n      }\n    });\n    return __awaiter(this, arguments, void 0, function (processor) {\n      var _this = this;\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\n        if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n          try {\n            for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {\n              _c = _h.value;\n              _f = false;\n              const sc = _c;\n              yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n      }();\n    });\n  }\n  setDegradationPreference(preference) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.degradationPreference = preference;\n      if (this.sender) {\n        try {\n          this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\n          const params = this.sender.getParameters();\n          params.degradationPreference = preference;\n          this.sender.setParameters(params);\n        } catch (e) {\n          this.log.warn(\"failed to set degradationPreference\", Object.assign({\n            error: e\n          }, this.logContext));\n        }\n      }\n    });\n  }\n  addSimulcastTrack(codec, encodings) {\n    if (this.simulcastCodecs.has(codec)) {\n      this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\n      return;\n    }\n    const simulcastCodecInfo = {\n      codec,\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\n      sender: undefined,\n      encodings\n    };\n    this.simulcastCodecs.set(codec, simulcastCodecInfo);\n    return simulcastCodecInfo;\n  }\n  setSimulcastTrackSender(codec, sender) {\n    const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n    if (!simulcastCodecInfo) {\n      return;\n    }\n    simulcastCodecInfo.sender = sender;\n    // browser will reenable disabled codec/layers after new codec has been published,\n    // so refresh subscribedCodecs after publish a new codec\n    setTimeout(() => {\n      if (this.subscribedCodecs) {\n        this.setPublishingCodecs(this.subscribedCodecs);\n      }\n    }, refreshSubscribedCodecAfterNewCodec);\n  }\n  /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */\n  setPublishingCodecs(codecs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, codecs_1, codecs_1_1;\n      var _b, e_5, _c, _d;\n      this.log.debug('setting publishing codecs', Object.assign(Object.assign({}, this.logContext), {\n        codecs,\n        currentCodec: this.codec\n      }));\n      // only enable simulcast codec for preference codec setted\n      if (!this.codec && codecs.length > 0) {\n        yield this.setPublishingLayers(codecs[0].qualities);\n        return [];\n      }\n      this.subscribedCodecs = codecs;\n      const newCodecs = [];\n      try {\n        for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {\n          _d = codecs_1_1.value;\n          _a = false;\n          const codec = _d;\n          if (!this.codec || this.codec === codec.codec) {\n            yield this.setPublishingLayers(codec.qualities);\n          } else {\n            const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n            this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n              simulcastCodecInfo\n            }));\n            if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n              for (const q of codec.qualities) {\n                if (q.enabled) {\n                  newCodecs.push(codec.codec);\n                  break;\n                }\n              }\n            } else if (simulcastCodecInfo.encodings) {\n              this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n              yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n            }\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      return newCodecs;\n    });\n  }\n  /**\n   * @internal\n   * Sets layers that should be publishing\n   */\n  setPublishingLayers(qualities) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.log.debug('setting publishing layers', Object.assign(Object.assign({}, this.logContext), {\n        qualities\n      }));\n      if (!this.sender || !this.encodings) {\n        return;\n      }\n      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n    });\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile()) return;\n      if (this.isInBackground && this.source === Track.Source.Camera) {\n        this._mediaStreamTrack.enabled = false;\n      }\n    });\n  }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const unlock = yield senderLock.lock();\n    log.debug('setPublishingLayersForSender', Object.assign(Object.assign({}, logContext), {\n      sender,\n      qualities,\n      senderEncodings\n    }));\n    try {\n      const params = sender.getParameters();\n      const {\n        encodings\n      } = params;\n      if (!encodings) {\n        return;\n      }\n      if (encodings.length !== senderEncodings.length) {\n        log.warn('cannot set publishing layers, encodings mismatch', Object.assign(Object.assign({}, logContext), {\n          encodings,\n          senderEncodings\n        }));\n        return;\n      }\n      let hasChanged = false;\n      const browser = getBrowser();\n      const closableSpatial = (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '133') > 0;\n      /* @ts-ignore */\n      if (closableSpatial && encodings[0].scalabilityMode) {\n        // svc dynacast encodings\n        const encoding = encodings[0];\n        /* @ts-ignore */\n        const mode = new ScalabilityMode(encoding.scalabilityMode);\n        let maxQuality = VideoQuality$1.OFF;\n        qualities.forEach(q => {\n          if (q.enabled && (maxQuality === VideoQuality$1.OFF || q.quality > maxQuality)) {\n            maxQuality = q.quality;\n          }\n        });\n        if (maxQuality === VideoQuality$1.OFF) {\n          if (encoding.active) {\n            encoding.active = false;\n            hasChanged = true;\n          }\n        } else if (!encoding.active || mode.spatial !== maxQuality + 1) {\n          hasChanged = true;\n          encoding.active = true;\n          /* @ts-ignore */\n          const originalMode = new ScalabilityMode(senderEncodings[0].scalabilityMode);\n          mode.spatial = maxQuality + 1;\n          mode.suffix = originalMode.suffix;\n          if (mode.spatial === 1) {\n            // no suffix for L1Tx\n            mode.suffix = undefined;\n          }\n          /* @ts-ignore */\n          encoding.scalabilityMode = mode.toString();\n          encoding.scaleResolutionDownBy = Math.pow(2, 2 - maxQuality);\n          if (senderEncodings[0].maxBitrate) {\n            encoding.maxBitrate = senderEncodings[0].maxBitrate / (encoding.scaleResolutionDownBy * encoding.scaleResolutionDownBy);\n          }\n        }\n      } else {\n        // simulcast dynacast encodings\n        encodings.forEach((encoding, idx) => {\n          var _a;\n          let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';\n          if (rid === '') {\n            rid = 'q';\n          }\n          const quality = videoQualityForRid(rid);\n          const subscribedQuality = qualities.find(q => q.quality === quality);\n          if (!subscribedQuality) {\n            return;\n          }\n          if (encoding.active !== subscribedQuality.enabled) {\n            hasChanged = true;\n            encoding.active = subscribedQuality.enabled;\n            log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? 'enabled' : 'disabled'), logContext);\n            // FireFox does not support setting encoding.active to false, so we\n            // have a workaround of lowering its bitrate and resolution to the min.\n            if (isFireFox()) {\n              if (subscribedQuality.enabled) {\n                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                /* @ts-ignore */\n                encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n              } else {\n                encoding.scaleResolutionDownBy = 4;\n                encoding.maxBitrate = 10;\n                /* @ts-ignore */\n                encoding.maxFrameRate = 2;\n              }\n            }\n          }\n        });\n      }\n      if (hasChanged) {\n        params.encodings = encodings;\n        log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n          encodings: params.encodings\n        }));\n        yield sender.setParameters(params);\n      }\n    } finally {\n      unlock();\n    }\n  });\n}\nfunction videoQualityForRid(rid) {\n  switch (rid) {\n    case 'f':\n      return VideoQuality.HIGH;\n    case 'h':\n      return VideoQuality.MEDIUM;\n    case 'q':\n      return VideoQuality.LOW;\n    default:\n      return VideoQuality.HIGH;\n  }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n  // default to a single layer, HQ\n  if (!encodings) {\n    return [new VideoLayer({\n      quality: VideoQuality.HIGH,\n      width,\n      height,\n      bitrate: 0,\n      ssrc: 0\n    })];\n  }\n  if (svc) {\n    // svc layers\n    /* @ts-ignore */\n    const encodingSM = encodings[0].scalabilityMode;\n    const sm = new ScalabilityMode(encodingSM);\n    const layers = [];\n    const resRatio = sm.suffix == 'h' ? 1.5 : 2;\n    const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\n    for (let i = 0; i < sm.spatial; i += 1) {\n      layers.push(new VideoLayer({\n        quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\n        width: Math.ceil(width / Math.pow(resRatio, i)),\n        height: Math.ceil(height / Math.pow(resRatio, i)),\n        bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\n        ssrc: 0\n      }));\n    }\n    return layers;\n  }\n  return encodings.map(encoding => {\n    var _a, _b, _c;\n    const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');\n    return new VideoLayer({\n      quality,\n      width: Math.ceil(width / scale),\n      height: Math.ceil(height / scale),\n      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n      ssrc: 0\n    });\n  });\n}\n\nconst lossyDataChannel = '_lossy';\nconst reliableDataChannel = '_reliable';\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = 'leave-reconnect';\nvar PCState;\n(function (PCState) {\n  PCState[PCState[\"New\"] = 0] = \"New\";\n  PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n  PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n  PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n  PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */\nclass RTCEngine extends eventsExports.EventEmitter {\n  get isClosed() {\n    return this._isClosed;\n  }\n  get pendingReconnect() {\n    return !!this.reconnectTimeout;\n  }\n  constructor(options) {\n    var _a;\n    super();\n    this.options = options;\n    this.rtcConfig = {};\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n    this.fullReconnectOnNext = false;\n    this.subscriberPrimary = false;\n    this.pcState = PCState.New;\n    this._isClosed = true;\n    this.pendingTrackResolvers = {};\n    this.reconnectAttempts = 0;\n    this.reconnectStart = 0;\n    this.attemptingReconnect = false;\n    /** keeps track of how often an initial join connection has been tried */\n    this.joinAttempts = 0;\n    /** specifies how often an initial join connection is allowed to retry */\n    this.maxJoinAttempts = 1;\n    this.shouldFailNext = false;\n    this.log = livekitLogger;\n    this.handleDataChannel = _a => __awaiter(this, [_a], void 0, function (_ref) {\n      var _this = this;\n      let {\n        channel\n      } = _ref;\n      return function* () {\n        if (!channel) {\n          return;\n        }\n        if (channel.label === reliableDataChannel) {\n          _this.reliableDCSub = channel;\n        } else if (channel.label === lossyDataChannel) {\n          _this.lossyDCSub = channel;\n        } else {\n          return;\n        }\n        _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\n        channel.onmessage = _this.handleDataMessage;\n      }();\n    });\n    this.handleDataMessage = message => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      // make sure to respect incoming data message order by processing message events one after the other\n      const unlock = yield this.dataProcessLock.lock();\n      try {\n        // decode\n        let buffer;\n        if (message.data instanceof ArrayBuffer) {\n          buffer = message.data;\n        } else if (message.data instanceof Blob) {\n          buffer = yield message.data.arrayBuffer();\n        } else {\n          this.log.error('unsupported data type', Object.assign(Object.assign({}, this.logContext), {\n            data: message.data\n          }));\n          return;\n        }\n        const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n        if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === 'speaker') {\n          // dispatch speaker updates\n          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n        } else {\n          if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'user') {\n            // compatibility\n            applyUserDataCompat(dp, dp.value.value);\n          }\n          this.emit(EngineEvent.DataPacketReceived, dp);\n        }\n      } finally {\n        unlock();\n      }\n    });\n    this.handleDataError = event => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';\n      if (event instanceof ErrorEvent && event.error) {\n        const {\n          error\n        } = event.error;\n        this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n          error\n        }));\n      } else {\n        this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n          event\n        }));\n      }\n    };\n    this.handleBufferedAmountLow = event => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n      this.updateAndEmitDCBufferStatus(channelKind);\n    };\n    // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n    // continues to work, we can reconnect to websocket to continue the session\n    // after a number of retries, we'll close and give up permanently\n    this.handleDisconnect = (connection, disconnectReason) => {\n      if (this._isClosed) {\n        return;\n      }\n      this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n      if (this.reconnectAttempts === 0) {\n        // only reset start time on the first try\n        this.reconnectStart = Date.now();\n      }\n      const disconnect = duration => {\n        this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n        this.emit(EngineEvent.Disconnected);\n        this.close();\n      };\n      const duration = Date.now() - this.reconnectStart;\n      let delay = this.getNextRetryDelay({\n        elapsedMs: duration,\n        retryCount: this.reconnectAttempts\n      });\n      if (delay === null) {\n        disconnect(duration);\n        return;\n      }\n      if (connection === leaveReconnect) {\n        delay = 0;\n      }\n      this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n      this.clearReconnectTimeout();\n      if (this.token && this.regionUrlProvider) {\n        // token may have been refreshed, we do not want to recreate the regionUrlProvider\n        // since the current engine may have inherited a regional url\n        this.regionUrlProvider.updateToken(this.token);\n      }\n      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = undefined), delay);\n    };\n    this.waitForRestarted = () => {\n      return new Promise((resolve, reject) => {\n        if (this.pcState === PCState.Connected) {\n          resolve();\n        }\n        const onRestarted = () => {\n          this.off(EngineEvent.Disconnected, onDisconnected);\n          resolve();\n        };\n        const onDisconnected = () => {\n          this.off(EngineEvent.Restarted, onRestarted);\n          reject();\n        };\n        this.once(EngineEvent.Restarted, onRestarted);\n        this.once(EngineEvent.Disconnected, onDisconnected);\n      });\n    };\n    this.updateAndEmitDCBufferStatus = kind => {\n      const status = this.isBufferStatusLow(kind);\n      if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {\n        this.dcBufferStatus.set(kind, status);\n        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n      }\n    };\n    this.isBufferStatusLow = kind => {\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n      }\n    };\n    this.handleBrowserOnLine = () => {\n      // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n      if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n        this.clearReconnectTimeout();\n        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n      }\n    };\n    this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n    this.loggerOptions = {\n      loggerName: options.loggerName,\n      loggerContextCb: () => this.logContext\n    };\n    this.client = new SignalClient(undefined, this.loggerOptions);\n    this.client.signalLatency = this.options.expSignalLatency;\n    this.reconnectPolicy = this.options.reconnectPolicy;\n    this.registerOnLineListener();\n    this.closingLock = new _();\n    this.dataProcessLock = new _();\n    this.dcBufferStatus = new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);\n    this.client.onParticipantUpdate = updates => this.emit(EngineEvent.ParticipantUpdate, updates);\n    this.client.onConnectionQuality = update => this.emit(EngineEvent.ConnectionQualityUpdate, update);\n    this.client.onRoomUpdate = update => this.emit(EngineEvent.RoomUpdate, update);\n    this.client.onSubscriptionError = resp => this.emit(EngineEvent.SubscriptionError, resp);\n    this.client.onSubscriptionPermissionUpdate = update => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n    this.client.onSpeakersChanged = update => this.emit(EngineEvent.SpeakersChanged, update);\n    this.client.onStreamStateUpdate = update => this.emit(EngineEvent.StreamStateChanged, update);\n    this.client.onRequestResponse = response => this.emit(EngineEvent.SignalRequestResponse, response);\n  }\n  /** @internal */\n  get logContext() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return {\n      room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n      roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n      participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\n      pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid\n    };\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.url = url;\n      this.token = token;\n      this.signalOpts = opts;\n      this.maxJoinAttempts = opts.maxRetries;\n      try {\n        this.joinAttempts += 1;\n        this.setupSignalClientCallbacks();\n        const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n        this._isClosed = false;\n        this.latestJoinResponse = joinResponse;\n        this.subscriberPrimary = joinResponse.subscriberPrimary;\n        if (!this.pcManager) {\n          yield this.configure(joinResponse);\n        }\n        // create offer\n        if (!this.subscriberPrimary || joinResponse.fastPublish) {\n          this.negotiate();\n        }\n        this.clientConfiguration = joinResponse.clientConfiguration;\n        // emit signal connected event after a short delay to allow for join response to be processed on room\n        setTimeout(() => {\n          this.emit(EngineEvent.SignalConnected);\n        }, 10);\n        return joinResponse;\n      } catch (e) {\n        if (e instanceof ConnectionError) {\n          if (e.reason === ConnectionErrorReason.ServerUnreachable) {\n            this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n            if (this.joinAttempts < this.maxJoinAttempts) {\n              return this.join(url, token, opts, abortSignal);\n            }\n          }\n        }\n        throw e;\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.closingLock.lock();\n      if (this.isClosed) {\n        unlock();\n        return;\n      }\n      try {\n        this._isClosed = true;\n        this.joinAttempts = 0;\n        this.emit(EngineEvent.Closing);\n        this.removeAllListeners();\n        this.deregisterOnLineListener();\n        this.clearPendingReconnect();\n        yield this.cleanupPeerConnections();\n        yield this.cleanupClient();\n      } finally {\n        unlock();\n      }\n    });\n  }\n  cleanupPeerConnections() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n      this.pcManager = undefined;\n      const dcCleanup = dc => {\n        if (!dc) return;\n        dc.close();\n        dc.onbufferedamountlow = null;\n        dc.onclose = null;\n        dc.onclosing = null;\n        dc.onerror = null;\n        dc.onmessage = null;\n        dc.onopen = null;\n      };\n      dcCleanup(this.lossyDC);\n      dcCleanup(this.lossyDCSub);\n      dcCleanup(this.reliableDC);\n      dcCleanup(this.reliableDCSub);\n      this.lossyDC = undefined;\n      this.lossyDCSub = undefined;\n      this.reliableDC = undefined;\n      this.reliableDCSub = undefined;\n    });\n  }\n  cleanupClient() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.close();\n      this.client.resetCallbacks();\n    });\n  }\n  addTrack(req) {\n    if (this.pendingTrackResolvers[req.cid]) {\n      throw new TrackInvalidError('a track with the same ID has already been published');\n    }\n    return new Promise((resolve, reject) => {\n      const publicationTimeout = setTimeout(() => {\n        delete this.pendingTrackResolvers[req.cid];\n        reject(new ConnectionError('publication of local track timed out, no response from server', ConnectionErrorReason.InternalError));\n      }, 10000);\n      this.pendingTrackResolvers[req.cid] = {\n        resolve: info => {\n          clearTimeout(publicationTimeout);\n          resolve(info);\n        },\n        reject: () => {\n          clearTimeout(publicationTimeout);\n          reject(new Error('Cancelled publication by calling unpublish'));\n        }\n      };\n      this.client.sendAddTrack(req);\n    });\n  }\n  /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */\n  removeTrack(sender) {\n    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n      const {\n        reject\n      } = this.pendingTrackResolvers[sender.track.id];\n      if (reject) {\n        reject();\n      }\n      delete this.pendingTrackResolvers[sender.track.id];\n    }\n    try {\n      this.pcManager.removeTrack(sender);\n      return true;\n    } catch (e) {\n      this.log.warn('failed to remove track', Object.assign(Object.assign({}, this.logContext), {\n        error: e\n      }));\n    }\n    return false;\n  }\n  updateMuteStatus(trackSid, muted) {\n    this.client.sendMuteTrack(trackSid, muted);\n  }\n  get dataSubscriberReadyState() {\n    var _a;\n    return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n  }\n  getConnectedServerAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n    });\n  }\n  /* @internal */\n  setRegionUrlProvider(provider) {\n    this.regionUrlProvider = provider;\n  }\n  configure(joinResponse) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      // already configured\n      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n        return;\n      }\n      this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n      const rtcConfig = this.makeRTCConfiguration(joinResponse);\n      this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n      this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n      this.pcManager.onIceCandidate = (candidate, target) => {\n        this.client.sendIceCandidate(candidate, target);\n      };\n      this.pcManager.onPublisherOffer = offer => {\n        this.client.sendOffer(offer);\n      };\n      this.pcManager.onDataChannel = this.handleDataChannel;\n      this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {\n        this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n        if (['closed', 'disconnected', 'failed'].includes(publisherState)) {\n          // reset publisher connection promise\n          this.publisherConnectionPromise = undefined;\n        }\n        if (connectionState === PCTransportState.CONNECTED) {\n          const shouldEmit = this.pcState === PCState.New;\n          this.pcState = PCState.Connected;\n          if (shouldEmit) {\n            this.emit(EngineEvent.Connected, joinResponse);\n          }\n        } else if (connectionState === PCTransportState.FAILED) {\n          // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n          if (this.pcState === PCState.Connected) {\n            this.pcState = PCState.Disconnected;\n            this.handleDisconnect('peerconnection failed', subscriberState === 'failed' ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n          }\n        }\n        // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\n        const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\n        const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);\n        if (isSignalSevered && isPCSevered && !this._isClosed) {\n          this.emit(EngineEvent.Offline);\n        }\n      });\n      this.pcManager.onTrack = ev => {\n        this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n      };\n      if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\n        this.createDataChannels();\n      }\n    });\n  }\n  setupSignalClientCallbacks() {\n    // configure signaling client\n    this.client.onAnswer = sd => __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        return;\n      }\n      this.log.debug('received server answer', Object.assign(Object.assign({}, this.logContext), {\n        RTCSdpType: sd.type\n      }));\n      yield this.pcManager.setPublisherAnswer(sd);\n    });\n    // add candidate on trickle\n    this.client.onTrickle = (candidate, target) => {\n      if (!this.pcManager) {\n        return;\n      }\n      this.log.debug('got ICE candidate from peer', Object.assign(Object.assign({}, this.logContext), {\n        candidate,\n        target\n      }));\n      this.pcManager.addIceCandidate(candidate, target);\n    };\n    // when server creates an offer for the client\n    this.client.onOffer = sd => __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        return;\n      }\n      const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n      this.client.sendAnswer(answer);\n    });\n    this.client.onLocalTrackPublished = res => {\n      var _a;\n      this.log.debug('received trackPublishedResponse', Object.assign(Object.assign({}, this.logContext), {\n        cid: res.cid,\n        track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n      }));\n      if (!this.pendingTrackResolvers[res.cid]) {\n        this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n          cid: res.cid\n        }));\n        return;\n      }\n      const {\n        resolve\n      } = this.pendingTrackResolvers[res.cid];\n      delete this.pendingTrackResolvers[res.cid];\n      resolve(res.track);\n    };\n    this.client.onLocalTrackUnpublished = response => {\n      this.emit(EngineEvent.LocalTrackUnpublished, response);\n    };\n    this.client.onLocalTrackSubscribed = trackSid => {\n      this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\n    };\n    this.client.onTokenRefresh = token => {\n      this.token = token;\n    };\n    this.client.onRemoteMuteChanged = (trackSid, muted) => {\n      this.emit(EngineEvent.RemoteMute, trackSid, muted);\n    };\n    this.client.onSubscribedQualityUpdate = update => {\n      this.emit(EngineEvent.SubscribedQualityUpdate, update);\n    };\n    this.client.onClose = () => {\n      this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);\n    };\n    this.client.onLeave = leave => {\n      this.log.debug('client leave request', Object.assign(Object.assign({}, this.logContext), {\n        reason: leave === null || leave === void 0 ? void 0 : leave.reason\n      }));\n      if (leave.regions && this.regionUrlProvider) {\n        this.log.debug('updating regions', this.logContext);\n        this.regionUrlProvider.setServerReportedRegions(leave.regions);\n      }\n      switch (leave.action) {\n        case LeaveRequest_Action.DISCONNECT:\n          this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n          this.close();\n          break;\n        case LeaveRequest_Action.RECONNECT:\n          this.fullReconnectOnNext = true;\n          // reconnect immediately instead of waiting for next attempt\n          this.handleDisconnect(leaveReconnect);\n          break;\n        case LeaveRequest_Action.RESUME:\n          // reconnect immediately instead of waiting for next attempt\n          this.handleDisconnect(leaveReconnect);\n      }\n    };\n  }\n  makeRTCConfiguration(serverResponse) {\n    var _a;\n    const rtcConfig = Object.assign({}, this.rtcConfig);\n    if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n      this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);\n      //  this makes sure that no data is sent before the transforms are ready\n      // @ts-ignore\n      rtcConfig.encodedInsertableStreams = true;\n    }\n    // update ICE servers before creating PeerConnection\n    if (serverResponse.iceServers && !rtcConfig.iceServers) {\n      const rtcIceServers = [];\n      serverResponse.iceServers.forEach(iceServer => {\n        const rtcIceServer = {\n          urls: iceServer.urls\n        };\n        if (iceServer.username) rtcIceServer.username = iceServer.username;\n        if (iceServer.credential) {\n          rtcIceServer.credential = iceServer.credential;\n        }\n        rtcIceServers.push(rtcIceServer);\n      });\n      rtcConfig.iceServers = rtcIceServers;\n    }\n    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n      rtcConfig.iceTransportPolicy = 'relay';\n    }\n    // @ts-ignore\n    rtcConfig.sdpSemantics = 'unified-plan';\n    // @ts-ignore\n    rtcConfig.continualGatheringPolicy = 'gather_continually';\n    return rtcConfig;\n  }\n  createDataChannels() {\n    if (!this.pcManager) {\n      return;\n    }\n    // clear old data channel callbacks if recreate\n    if (this.lossyDC) {\n      this.lossyDC.onmessage = null;\n      this.lossyDC.onerror = null;\n    }\n    if (this.reliableDC) {\n      this.reliableDC.onmessage = null;\n      this.reliableDC.onerror = null;\n    }\n    // create data channels\n    this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n      // will drop older packets that arrive\n      ordered: true,\n      maxRetransmits: 0\n    });\n    this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n      ordered: true\n    });\n    // also handle messages over the pub channel, for backwards compatibility\n    this.lossyDC.onmessage = this.handleDataMessage;\n    this.reliableDC.onmessage = this.handleDataMessage;\n    // handle datachannel errors\n    this.lossyDC.onerror = this.handleDataError;\n    this.reliableDC.onerror = this.handleDataError;\n    // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n    this.lossyDC.bufferedAmountLowThreshold = 65535;\n    this.reliableDC.bufferedAmountLowThreshold = 65535;\n    // handle buffer amount low events\n    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n  }\n  createSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver()) {\n        const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n        return sender;\n      }\n      if (supportsAddTrack()) {\n        this.log.warn('using add-track fallback', this.logContext);\n        const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n        return sender;\n      }\n      throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');\n    });\n  }\n  createSimulcastSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // store RTCRtpSender\n      if (supportsTransceiver()) {\n        return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n      }\n      if (supportsAddTrack()) {\n        this.log.debug('using add-track fallback', this.logContext);\n        return this.createRTCRtpSender(track.mediaStreamTrack);\n      }\n      throw new UnexpectedConnectionState('Cannot stream on this device');\n    });\n  }\n  createTransceiverRTCRtpSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher is closed');\n      }\n      const streams = [];\n      if (track.mediaStream) {\n        streams.push(track.mediaStream);\n      }\n      if (isVideoTrack(track)) {\n        track.codec = opts.videoCodec;\n      }\n      const transceiverInit = {\n        direction: 'sendonly',\n        streams\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n      const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n      return transceiver.sender;\n    });\n  }\n  createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher is closed');\n      }\n      const transceiverInit = {\n        direction: 'sendonly'\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n      const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n      if (!opts.videoCodec) {\n        return;\n      }\n      track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n      return transceiver.sender;\n    });\n  }\n  createRTCRtpSender(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher is closed');\n      }\n      return this.pcManager.addPublisherTrack(track);\n    });\n  }\n  attemptReconnect(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (this._isClosed) {\n        return;\n      }\n      // guard for attempting reconnection multiple times while one attempt is still not finished\n      if (this.attemptingReconnect) {\n        livekitLogger.warn('already attempting reconnect, returning early', this.logContext);\n        return;\n      }\n      if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED ||\n      // signaling state could change to closed due to hardware sleep\n      // those connections cannot be resumed\n      ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n        this.fullReconnectOnNext = true;\n      }\n      try {\n        this.attemptingReconnect = true;\n        if (this.fullReconnectOnNext) {\n          yield this.restartConnection();\n        } else {\n          yield this.resumeConnection(reason);\n        }\n        this.clearPendingReconnect();\n        this.fullReconnectOnNext = false;\n      } catch (e) {\n        this.reconnectAttempts += 1;\n        let recoverable = true;\n        if (e instanceof UnexpectedConnectionState) {\n          this.log.debug('received unrecoverable error', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n          // unrecoverable\n          recoverable = false;\n        } else if (!(e instanceof SignalReconnectError)) {\n          // cannot resume\n          this.fullReconnectOnNext = true;\n        }\n        if (recoverable) {\n          this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);\n        } else {\n          this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n          this.emit(EngineEvent.Disconnected);\n          yield this.close();\n        }\n      } finally {\n        this.attemptingReconnect = false;\n      }\n    });\n  }\n  getNextRetryDelay(context) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMs(context);\n    } catch (e) {\n      this.log.warn('encountered error in reconnect policy', Object.assign(Object.assign({}, this.logContext), {\n        error: e\n      }));\n    }\n    // error in user code with provided reconnect policy, stop reconnecting\n    return null;\n  }\n  restartConnection(regionUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      try {\n        if (!this.url || !this.token) {\n          // permanent failure, don't attempt reconnection\n          throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n        }\n        this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n        this.emit(EngineEvent.Restarting);\n        if (!this.client.isDisconnected) {\n          yield this.client.sendLeave();\n        }\n        yield this.cleanupPeerConnections();\n        yield this.cleanupClient();\n        let joinResponse;\n        try {\n          if (!this.signalOpts) {\n            this.log.warn('attempted connection restart, without signal options present', this.logContext);\n            throw new SignalReconnectError();\n          }\n          // in case a regionUrl is passed, the region URL takes precedence\n          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n        } catch (e) {\n          if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\n            throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n          }\n          throw new SignalReconnectError();\n        }\n        if (this.shouldFailNext) {\n          this.shouldFailNext = false;\n          throw new Error('simulated failure');\n        }\n        this.client.setReconnected();\n        this.emit(EngineEvent.SignalRestarted, joinResponse);\n        yield this.waitForPCReconnected();\n        // re-check signal connection state before setting engine as resumed\n        if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n          throw new SignalReconnectError('Signal connection got severed during reconnect');\n        }\n        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n        // reconnect success\n        this.emit(EngineEvent.Restarted);\n      } catch (error) {\n        const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n        if (nextRegionUrl) {\n          yield this.restartConnection(nextRegionUrl);\n          return;\n        } else {\n          // no more regions to try (or we're not on cloud)\n          (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n          throw error;\n        }\n      }\n    });\n  }\n  resumeConnection(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!this.url || !this.token) {\n        // permanent failure, don't attempt reconnection\n        throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n      }\n      // trigger publisher reconnect\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher and subscriber connections unset');\n      }\n      this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n      this.emit(EngineEvent.Resuming);\n      let res;\n      try {\n        this.setupSignalClientCallbacks();\n        res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n      } catch (error) {\n        let message = '';\n        if (error instanceof Error) {\n          message = error.message;\n          this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n            error\n          }));\n        }\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n          throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n        }\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\n          throw error;\n        }\n        throw new SignalReconnectError(message);\n      }\n      this.emit(EngineEvent.SignalResumed);\n      if (res) {\n        const rtcConfig = this.makeRTCConfiguration(res);\n        this.pcManager.updateConfiguration(rtcConfig);\n      } else {\n        this.log.warn('Did not receive reconnect response', this.logContext);\n      }\n      if (this.shouldFailNext) {\n        this.shouldFailNext = false;\n        throw new Error('simulated failure');\n      }\n      yield this.pcManager.triggerIceRestart();\n      yield this.waitForPCReconnected();\n      // re-check signal connection state before setting engine as resumed\n      if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n        throw new SignalReconnectError('Signal connection got severed during reconnect');\n      }\n      this.client.setReconnected();\n      // recreate publish datachannel if it's id is null\n      // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n      if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' && this.reliableDC.id === null) {\n        this.createDataChannels();\n      }\n      // resume success\n      this.emit(EngineEvent.Resumed);\n    });\n  }\n  waitForPCInitialConnection(timeout, abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('PC manager is closed');\n      }\n      yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n    });\n  }\n  waitForPCReconnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.pcState = PCState.Reconnecting;\n      this.log.debug('waiting for peer connection to reconnect', this.logContext);\n      try {\n        yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n        if (!this.pcManager) {\n          throw new UnexpectedConnectionState('PC manager is closed');\n        }\n        yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n        this.pcState = PCState.Connected;\n      } catch (e) {\n        // TODO do we need a `failed` state here for the PC?\n        this.pcState = PCState.Disconnected;\n        throw new ConnectionError(\"could not establish PC connection, \".concat(e.message), ConnectionErrorReason.InternalError);\n      }\n    });\n  }\n  /** @internal */\n  publishRpcResponse(destinationIdentity, requestId, payload, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        destinationIdentities: [destinationIdentity],\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'rpcResponse',\n          value: new RpcResponse({\n            requestId,\n            value: error ? {\n              case: 'error',\n              value: error.toProto()\n            } : {\n              case: 'payload',\n              value: payload !== null && payload !== void 0 ? payload : ''\n            }\n          })\n        }\n      });\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /** @internal */\n  publishRpcAck(destinationIdentity, requestId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        destinationIdentities: [destinationIdentity],\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'rpcAck',\n          value: new RpcAck({\n            requestId\n          })\n        }\n      });\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /* @internal */\n  sendDataPacket(packet, kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = packet.toBinary();\n      // make sure we do have a data connection\n      yield this.ensurePublisherConnected(kind);\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        dc.send(msg);\n      }\n      this.updateAndEmitDCBufferStatus(kind);\n    });\n  }\n  waitForBufferStatusLow(kind) {\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      if (this.isBufferStatusLow(kind)) {\n        resolve();\n      } else {\n        const onClosing = () => reject('Engine closed');\n        this.once(EngineEvent.Closing, onClosing);\n        while (!this.dcBufferStatus.get(kind)) {\n          yield sleep(10);\n        }\n        this.off(EngineEvent.Closing, onClosing);\n        resolve();\n      }\n    }));\n  }\n  /**\n   * @internal\n   */\n  ensureDataTransportConnected(kind_1) {\n    return __awaiter(this, arguments, void 0, function (kind) {\n      var _this2 = this;\n      let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n      return function* () {\n        var _a;\n        if (!_this2.pcManager) {\n          throw new UnexpectedConnectionState('PC manager is closed');\n        }\n        const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\n        const transportName = subscriber ? 'Subscriber' : 'Publisher';\n        if (!transport) {\n          throw new ConnectionError(\"\".concat(transportName, \" connection not set\"), ConnectionErrorReason.InternalError);\n        }\n        let needNegotiation = false;\n        if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\n          _this2.createDataChannels();\n          needNegotiation = true;\n        }\n        if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== 'checking') {\n          needNegotiation = true;\n        }\n        if (needNegotiation) {\n          // start negotiation\n          _this2.negotiate();\n        }\n        const targetChannel = _this2.dataChannelForKind(kind, subscriber);\n        if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {\n          return;\n        }\n        // wait until ICE connected\n        const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\n        while (new Date().getTime() < endTime) {\n          if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {\n            return;\n          }\n          yield sleep(50);\n        }\n        throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);\n      }();\n    });\n  }\n  ensurePublisherConnected(kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisherConnectionPromise) {\n        this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\n      }\n      yield this.publisherConnectionPromise;\n    });\n  }\n  /* @internal */\n  verifyTransport() {\n    if (!this.pcManager) {\n      return false;\n    }\n    // primary connection\n    if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n      return false;\n    }\n    // ensure signal is connected\n    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n      return false;\n    }\n    return true;\n  }\n  /** @internal */\n  negotiate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // observe signal state\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (!this.pcManager) {\n          reject(new NegotiationError('PC manager is closed'));\n          return;\n        }\n        this.pcManager.requirePublisher();\n        // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\n        if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\n          this.createDataChannels();\n        }\n        const abortController = new AbortController();\n        const handleClosed = () => {\n          abortController.abort();\n          this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);\n          resolve();\n          return;\n        };\n        if (this.isClosed) {\n          reject('cannot negotiate on closed engine');\n        }\n        this.on(EngineEvent.Closing, handleClosed);\n        this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, rtpTypes => {\n          const rtpMap = new Map();\n          rtpTypes.forEach(rtp => {\n            const codec = rtp.codec.toLowerCase();\n            if (isVideoCodec(codec)) {\n              rtpMap.set(rtp.payload, codec);\n            }\n          });\n          this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n        });\n        try {\n          yield this.pcManager.negotiate(abortController);\n          resolve();\n        } catch (e) {\n          if (e instanceof NegotiationError) {\n            this.fullReconnectOnNext = true;\n          }\n          this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);\n          reject(e);\n        } finally {\n          this.off(EngineEvent.Closing, handleClosed);\n        }\n      }));\n    });\n  }\n  dataChannelForKind(kind, sub) {\n    if (!sub) {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDC;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDC;\n      }\n    } else {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDCSub;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDCSub;\n      }\n    }\n  }\n  /** @internal */\n  sendSyncState(remoteTracks, localTracks) {\n    var _a, _b;\n    if (!this.pcManager) {\n      this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);\n      return;\n    }\n    const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n    const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n    /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */\n    const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n    const trackSids = new Array();\n    const trackSidsDisabled = new Array();\n    remoteTracks.forEach(track => {\n      if (track.isDesired !== autoSubscribe) {\n        trackSids.push(track.trackSid);\n      }\n      if (!track.isEnabled) {\n        trackSidsDisabled.push(track.trackSid);\n      }\n    });\n    this.client.sendSyncState(new SyncState({\n      answer: previousAnswer ? toProtoSessionDescription({\n        sdp: previousAnswer.sdp,\n        type: previousAnswer.type\n      }) : undefined,\n      offer: previousOffer ? toProtoSessionDescription({\n        sdp: previousOffer.sdp,\n        type: previousOffer.type\n      }) : undefined,\n      subscription: new UpdateSubscription({\n        trackSids,\n        subscribe: !autoSubscribe,\n        participantTracks: []\n      }),\n      publishTracks: getTrackPublicationInfo(localTracks),\n      dataChannels: this.dataChannelsInfo(),\n      trackSidsDisabled\n    }));\n  }\n  /* @internal */\n  failNext() {\n    // debugging method to fail the next reconnect/resume attempt\n    this.shouldFailNext = true;\n  }\n  dataChannelsInfo() {\n    const infos = [];\n    const getInfo = (dc, target) => {\n      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n        infos.push(new DataChannelInfo({\n          label: dc.label,\n          id: dc.id,\n          target\n        }));\n      }\n    };\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n    return infos;\n  }\n  clearReconnectTimeout() {\n    if (this.reconnectTimeout) {\n      CriticalTimers.clearTimeout(this.reconnectTimeout);\n    }\n  }\n  clearPendingReconnect() {\n    this.clearReconnectTimeout();\n    this.reconnectAttempts = 0;\n  }\n  registerOnLineListener() {\n    if (isWeb()) {\n      window.addEventListener('online', this.handleBrowserOnLine);\n    }\n  }\n  deregisterOnLineListener() {\n    if (isWeb()) {\n      window.removeEventListener('online', this.handleBrowserOnLine);\n    }\n  }\n}\nclass SignalReconnectError extends Error {}\nfunction supportOptionalDatachannel(protocol) {\n  return protocol !== undefined && protocol > 13;\n}\nfunction applyUserDataCompat(newObj, oldObj) {\n  const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\n  newObj.participantIdentity = participantIdentity;\n  oldObj.participantIdentity = participantIdentity;\n  const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\n  newObj.destinationIdentities = destinationIdentities;\n  oldObj.destinationIdentities = destinationIdentities;\n}\n\nclass RegionUrlProvider {\n  constructor(url, token) {\n    this.lastUpdateAt = 0;\n    this.settingsCacheTime = 3000;\n    this.attemptedRegions = [];\n    this.serverUrl = new URL(url);\n    this.token = token;\n  }\n  updateToken(token) {\n    this.token = token;\n  }\n  isCloud() {\n    return isCloud(this.serverUrl);\n  }\n  getServerUrl() {\n    return this.serverUrl;\n  }\n  getNextBestRegionUrl(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isCloud()) {\n        throw Error('region availability is only supported for LiveKit Cloud domains');\n      }\n      if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n        this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n      }\n      const regionsLeft = this.regionSettings.regions.filter(region => !this.attemptedRegions.find(attempted => attempted.url === region.url));\n      if (regionsLeft.length > 0) {\n        const nextRegion = regionsLeft[0];\n        this.attemptedRegions.push(nextRegion);\n        livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n        return nextRegion.url;\n      } else {\n        return null;\n      }\n    });\n  }\n  resetAttempts() {\n    this.attemptedRegions = [];\n  }\n  /* @internal */\n  fetchRegionSettings(signal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n        headers: {\n          authorization: \"Bearer \".concat(this.token)\n        },\n        signal\n      });\n      if (regionSettingsResponse.ok) {\n        const regionSettings = yield regionSettingsResponse.json();\n        this.lastUpdateAt = Date.now();\n        return regionSettings;\n      } else {\n        throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);\n      }\n    });\n  }\n  setServerReportedRegions(regions) {\n    this.regionSettings = regions;\n    this.lastUpdateAt = Date.now();\n  }\n}\nfunction getCloudConfigUrl(serverUrl) {\n  return \"\".concat(serverUrl.protocol.replace('ws', 'http'), \"//\").concat(serverUrl.host, \"/settings\");\n}\n\nclass BaseStreamReader {\n  get info() {\n    return this._info;\n  }\n  constructor(info, stream, totalByteSize) {\n    this.reader = stream;\n    this.totalByteSize = totalByteSize;\n    this._info = info;\n    this.bytesReceived = 0;\n  }\n}\nclass ByteStreamReader extends BaseStreamReader {\n  handleChunkReceived(chunk) {\n    var _a;\n    this.bytesReceived += chunk.content.byteLength;\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n  }\n  [Symbol.asyncIterator]() {\n    const reader = this.reader.getReader();\n    return {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const {\n            done,\n            value\n          } = yield reader.read();\n          if (done) {\n            return {\n              done: true,\n              value: undefined\n            };\n          } else {\n            this.handleChunkReceived(value);\n            return {\n              done: false,\n              value: value.content\n            };\n          }\n        } catch (error) {\n          // TODO handle errors\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n      }),\n      return() {\n        return __awaiter(this, void 0, void 0, function* () {\n          reader.releaseLock();\n          return {\n            done: true,\n            value: undefined\n          };\n        });\n      }\n    };\n  }\n  readAll() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      let chunks = new Set();\n      try {\n        for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const chunk = _c;\n          chunks.add(chunk);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return Array.from(chunks);\n    });\n  }\n}\n/**\n * A class to read chunks from a ReadableStream and provide them in a structured format.\n */\nclass TextStreamReader extends BaseStreamReader {\n  /**\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\n   * that has been received up to the current point in time.\n   */\n  constructor(info, stream, totalChunkCount) {\n    super(info, stream, totalChunkCount);\n    this.receivedChunks = new Map();\n  }\n  handleChunkReceived(chunk) {\n    var _a;\n    const index = bigIntToNumber(chunk.chunkIndex);\n    const previousChunkAtIndex = this.receivedChunks.get(index);\n    if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\n      // we have a newer version already, dropping the old one\n      return;\n    }\n    this.receivedChunks.set(index, chunk);\n    this.bytesReceived += chunk.content.byteLength;\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n  }\n  /**\n   * Async iterator implementation to allow usage of `for await...of` syntax.\n   * Yields structured chunks from the stream.\n   *\n   */\n  [Symbol.asyncIterator]() {\n    const reader = this.reader.getReader();\n    const decoder = new TextDecoder();\n    return {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const {\n            done,\n            value\n          } = yield reader.read();\n          if (done) {\n            return {\n              done: true,\n              value: undefined\n            };\n          } else {\n            this.handleChunkReceived(value);\n            return {\n              done: false,\n              value: decoder.decode(value.content)\n            };\n          }\n        } catch (error) {\n          // TODO handle errors\n          return {\n            done: true,\n            value: undefined\n          };\n        }\n      }),\n      return() {\n        return __awaiter(this, void 0, void 0, function* () {\n          reader.releaseLock();\n          return {\n            done: true,\n            value: undefined\n          };\n        });\n      }\n    };\n  }\n  readAll() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_2, _b, _c;\n      let finalString = '';\n      try {\n        for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const chunk = _c;\n          finalString += chunk;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n      return finalString;\n    });\n  }\n}\n\nclass BaseStreamWriter {\n  constructor(writableStream, info, onClose) {\n    this.writableStream = writableStream;\n    this.defaultWriter = writableStream.getWriter();\n    this.onClose = onClose;\n    this.info = info;\n  }\n  write(chunk) {\n    return this.defaultWriter.write(chunk);\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield this.defaultWriter.close();\n      this.defaultWriter.releaseLock();\n      (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\n    });\n  }\n}\nclass TextStreamWriter extends BaseStreamWriter {}\nclass ByteStreamWriter extends BaseStreamWriter {}\n\nclass RemoteTrack extends Track {\n  constructor(mediaTrack, sid, kind, receiver, loggerOptions) {\n    super(mediaTrack, kind, loggerOptions);\n    this.sid = sid;\n    this.receiver = receiver;\n  }\n  get isLocal() {\n    return false;\n  }\n  /** @internal */\n  setMuted(muted) {\n    if (this.isMuted !== muted) {\n      this.isMuted = muted;\n      this._mediaStreamTrack.enabled = !muted;\n      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n  }\n  /** @internal */\n  setMediaStream(stream) {\n    // this is needed to determine when the track is finished\n    this.mediaStream = stream;\n    const onRemoveTrack = event => {\n      if (event.track === this._mediaStreamTrack) {\n        stream.removeEventListener('removetrack', onRemoveTrack);\n        if (this.receiver && 'playoutDelayHint' in this.receiver) {\n          this.receiver.playoutDelayHint = undefined;\n        }\n        this.receiver = undefined;\n        this._currentBitrate = 0;\n        this.emit(TrackEvent.Ended, this);\n      }\n    };\n    stream.addEventListener('removetrack', onRemoveTrack);\n  }\n  start() {\n    this.startMonitor();\n    // use `enabled` of track to enable re-use of transceiver\n    super.enable();\n  }\n  stop() {\n    this.stopMonitor();\n    // use `enabled` of track to enable re-use of transceiver\n    super.disable();\n  }\n  /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */\n  getRTCStatsReport() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return;\n      }\n      const statsReport = yield this.receiver.getStats();\n      return statsReport;\n    });\n  }\n  /**\n   * Allows to set a playout delay (in seconds) for this track.\n   * A higher value allows for more buffering of the track in the browser\n   * and will result in a delay of media being played back of `delayInSeconds`\n   */\n  setPlayoutDelay(delayInSeconds) {\n    if (this.receiver) {\n      if ('playoutDelayHint' in this.receiver) {\n        this.receiver.playoutDelayHint = delayInSeconds;\n      } else {\n        this.log.warn('Playout delay not supported in this browser');\n      }\n    } else {\n      this.log.warn('Cannot set playout delay, track already ended');\n    }\n  }\n  /**\n   * Returns the current playout delay (in seconds) of this track.\n   */\n  getPlayoutDelay() {\n    if (this.receiver) {\n      if ('playoutDelayHint' in this.receiver) {\n        return this.receiver.playoutDelayHint;\n      } else {\n        this.log.warn('Playout delay not supported in this browser');\n      }\n    } else {\n      this.log.warn('Cannot get playout delay, track already ended');\n    }\n    return 0;\n  }\n  /* @internal */\n  startMonitor() {\n    if (!this.monitorInterval) {\n      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);\n    }\n    if (supportsSynchronizationSources()) {\n      this.registerTimeSyncUpdate();\n    }\n  }\n  registerTimeSyncUpdate() {\n    const loop = () => {\n      var _a;\n      this.timeSyncHandle = requestAnimationFrame(() => loop());\n      const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\n      if (sources) {\n        const {\n          timestamp,\n          rtpTimestamp\n        } = sources;\n        if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\n          this.emit(TrackEvent.TimeSyncUpdate, {\n            timestamp,\n            rtpTimestamp\n          });\n          this.rtpTimestamp = rtpTimestamp;\n        }\n      }\n    };\n    loop();\n  }\n}\n\nclass RemoteAudioTrack extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {\n    super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.audioContext = audioContext;\n    this.webAudioPluginNodes = [];\n    if (audioOutput) {\n      this.sinkId = audioOutput.deviceId;\n    }\n  }\n  /**\n   * sets the volume for all attached audio elements\n   */\n  setVolume(volume) {\n    var _a;\n    for (const el of this.attachedElements) {\n      if (this.audioContext) {\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n      } else {\n        el.volume = volume;\n      }\n    }\n    if (isReactNative()) {\n      // @ts-ignore\n      this._mediaStreamTrack._setVolume(volume);\n    }\n    this.elementVolume = volume;\n  }\n  /**\n   * gets the volume of attached audio elements (loudest)\n   */\n  getVolume() {\n    if (this.elementVolume) {\n      return this.elementVolume;\n    }\n    if (isReactNative()) {\n      // RN volume value defaults to 1.0 if hasn't been changed.\n      return 1.0;\n    }\n    let highestVolume = 0;\n    this.attachedElements.forEach(element => {\n      if (element.volume > highestVolume) {\n        highestVolume = element.volume;\n      }\n    });\n    return highestVolume;\n  }\n  /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */\n  setSinkId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.sinkId = deviceId;\n      yield Promise.all(this.attachedElements.map(elm => {\n        if (!supportsSetSinkId(elm)) {\n          return;\n        }\n        /* @ts-ignore */\n        return elm.setSinkId(deviceId);\n      }));\n    });\n  }\n  attach(element) {\n    const needsNewWebAudioConnection = this.attachedElements.length === 0;\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    if (this.sinkId && supportsSetSinkId(element)) {\n      /* @ts-ignore */\n      element.setSinkId(this.sinkId);\n    }\n    if (this.audioContext && needsNewWebAudioConnection) {\n      this.log.debug('using audio context mapping', this.logContext);\n      this.connectWebAudio(this.audioContext, element);\n      element.volume = 0;\n      element.muted = true;\n    }\n    if (this.elementVolume) {\n      // make sure volume setting is being applied to the newly attached element\n      this.setVolume(this.elementVolume);\n    }\n    return element;\n  }\n  detach(element) {\n    let detached;\n    if (!element) {\n      detached = super.detach();\n      this.disconnectWebAudio();\n    } else {\n      detached = super.detach(element);\n      // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n      // disconnect webaudio otherwise\n      if (this.audioContext) {\n        if (this.attachedElements.length > 0) {\n          this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        } else {\n          this.disconnectWebAudio();\n        }\n      }\n    }\n    return detached;\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(audioContext) {\n    this.audioContext = audioContext;\n    if (audioContext && this.attachedElements.length > 0) {\n      this.connectWebAudio(audioContext, this.attachedElements[0]);\n    } else if (!audioContext) {\n      this.disconnectWebAudio();\n    }\n  }\n  /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */\n  setWebAudioPlugins(nodes) {\n    this.webAudioPluginNodes = nodes;\n    if (this.attachedElements.length > 0 && this.audioContext) {\n      this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n    }\n  }\n  connectWebAudio(context, element) {\n    this.disconnectWebAudio();\n    // @ts-ignore attached elements always have a srcObject set\n    this.sourceNode = context.createMediaStreamSource(element.srcObject);\n    let lastNode = this.sourceNode;\n    this.webAudioPluginNodes.forEach(node => {\n      lastNode.connect(node);\n      lastNode = node;\n    });\n    this.gainNode = context.createGain();\n    lastNode.connect(this.gainNode);\n    this.gainNode.connect(context.destination);\n    if (this.elementVolume) {\n      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n    }\n    // try to resume the context if it isn't running already\n    if (context.state !== 'running') {\n      context.resume().then(() => {\n        if (context.state !== 'running') {\n          this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n        }\n      }).catch(e => {\n        this.emit(TrackEvent.AudioPlaybackFailed, e);\n      });\n    }\n  }\n  disconnectWebAudio() {\n    var _a, _b;\n    (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n    this.gainNode = undefined;\n    this.sourceNode = undefined;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      stats.forEach(v => {\n        if (v.type === 'inbound-rtp') {\n          receiverStats = {\n            type: 'audio',\n            streamId: v.id,\n            timestamp: v.timestamp,\n            jitter: v.jitter,\n            bytesReceived: v.bytesReceived,\n            concealedSamples: v.concealedSamples,\n            concealmentEvents: v.concealmentEvents,\n            silentConcealedSamples: v.silentConcealedSamples,\n            silentConcealmentEvents: v.silentConcealmentEvents,\n            totalAudioEnergy: v.totalAudioEnergy,\n            totalSamplesDuration: v.totalSamplesDuration\n          };\n        }\n      });\n      return receiverStats;\n    });\n  }\n}\n\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {\n    super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n    this.elementInfos = [];\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.debouncedHandleResize = r(() => {\n      this.updateDimensions();\n    }, REACTION_DELAY);\n    this.adaptiveStreamSettings = adaptiveStreamSettings;\n  }\n  get isAdaptiveStream() {\n    return this.adaptiveStreamSettings !== undefined;\n  }\n  /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /** @internal */\n  setMuted(muted) {\n    super.setMuted(muted);\n    this.attachedElements.forEach(element => {\n      // detach or attach\n      if (muted) {\n        detachTrack(this._mediaStreamTrack, element);\n      } else {\n        attachToElement(this._mediaStreamTrack, element);\n      }\n    });\n  }\n  attach(element) {\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    // It's possible attach is called multiple times on an element. When that's\n    // the case, we'd want to avoid adding duplicate elementInfos\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info.element === element) === undefined) {\n      const elementInfo = new HTMLElementInfo(element);\n      this.observeElementInfo(elementInfo);\n    }\n    return element;\n  }\n  /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */\n  observeElementInfo(elementInfo) {\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info === elementInfo) === undefined) {\n      elementInfo.handleResize = () => {\n        this.debouncedHandleResize();\n      };\n      elementInfo.handleVisibilityChanged = () => {\n        this.updateVisibility();\n      };\n      this.elementInfos.push(elementInfo);\n      elementInfo.observe();\n      // trigger the first resize update cycle\n      // if the tab is backgrounded, the initial resize event does not fire until\n      // the tab comes into focus for the first time.\n      this.debouncedHandleResize();\n      this.updateVisibility();\n    } else {\n      this.log.warn('visibility resize observer not triggered', this.logContext);\n    }\n  }\n  /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */\n  stopObservingElementInfo(elementInfo) {\n    if (!this.isAdaptiveStream) {\n      this.log.warn('stopObservingElementInfo ignored', this.logContext);\n      return;\n    }\n    const stopElementInfos = this.elementInfos.filter(info => info === elementInfo);\n    for (const info of stopElementInfos) {\n      info.stopObserving();\n    }\n    this.elementInfos = this.elementInfos.filter(info => info !== elementInfo);\n    this.updateVisibility();\n    this.debouncedHandleResize();\n  }\n  detach(element) {\n    let detachedElements = [];\n    if (element) {\n      this.stopObservingElement(element);\n      return super.detach(element);\n    }\n    detachedElements = super.detach();\n    for (const e of detachedElements) {\n      this.stopObservingElement(e);\n    }\n    return detachedElements;\n  }\n  /** @internal */\n  getDecoderImplementation() {\n    var _a;\n    return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      let codecID = '';\n      let codecs = new Map();\n      stats.forEach(v => {\n        if (v.type === 'inbound-rtp') {\n          codecID = v.codecId;\n          receiverStats = {\n            type: 'video',\n            streamId: v.id,\n            framesDecoded: v.framesDecoded,\n            framesDropped: v.framesDropped,\n            framesReceived: v.framesReceived,\n            packetsReceived: v.packetsReceived,\n            packetsLost: v.packetsLost,\n            frameWidth: v.frameWidth,\n            frameHeight: v.frameHeight,\n            pliCount: v.pliCount,\n            firCount: v.firCount,\n            nackCount: v.nackCount,\n            jitter: v.jitter,\n            timestamp: v.timestamp,\n            bytesReceived: v.bytesReceived,\n            decoderImplementation: v.decoderImplementation\n          };\n        } else if (v.type === 'codec') {\n          codecs.set(v.id, v);\n        }\n      });\n      if (receiverStats && codecID !== '' && codecs.get(codecID)) {\n        receiverStats.mimeType = codecs.get(codecID).mimeType;\n      }\n      return receiverStats;\n    });\n  }\n  stopObservingElement(element) {\n    const stopElementInfos = this.elementInfos.filter(info => info.element === element);\n    for (const info of stopElementInfos) {\n      this.stopObservingElementInfo(info);\n    }\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!this.isAdaptiveStream) return;\n      this.updateVisibility();\n    });\n  }\n  updateVisibility() {\n    var _a, _b;\n    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);\n    const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n    ) ? this.isInBackground : false;\n    const isPiPMode = this.elementInfos.some(info => info.pictureInPicture);\n    const isVisible = this.elementInfos.some(info => info.visible) && !backgroundPause || isPiPMode;\n    if (this.lastVisible === isVisible) {\n      return;\n    }\n    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n      // delay hidden events\n      CriticalTimers.setTimeout(() => {\n        this.updateVisibility();\n      }, REACTION_DELAY);\n      return;\n    }\n    this.lastVisible = isVisible;\n    this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n  }\n  updateDimensions() {\n    var _a, _b;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    const pixelDensity = this.getPixelDensity();\n    for (const info of this.elementInfos) {\n      const currentElementWidth = info.width() * pixelDensity;\n      const currentElementHeight = info.height() * pixelDensity;\n      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n        maxWidth = currentElementWidth;\n        maxHeight = currentElementHeight;\n      }\n    }\n    if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n      return;\n    }\n    this.lastDimensions = {\n      width: maxWidth,\n      height: maxHeight\n    };\n    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n  }\n  getPixelDensity() {\n    var _a;\n    const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n    if (pixelDensity === 'screen') {\n      return getDevicePixelRatio();\n    } else if (!pixelDensity) {\n      // when unset, we'll pick a sane default here.\n      // for higher pixel density devices (mobile phones, etc), we'll use 2\n      // otherwise it defaults to 1\n      const devicePixelRatio = getDevicePixelRatio();\n      if (devicePixelRatio > 2) {\n        return 2;\n      } else {\n        return 1;\n      }\n    }\n    return pixelDensity;\n  }\n}\nclass HTMLElementInfo {\n  get visible() {\n    return this.isPiP || this.isIntersecting;\n  }\n  get pictureInPicture() {\n    return this.isPiP;\n  }\n  constructor(element, visible) {\n    this.onVisibilityChanged = entry => {\n      var _a;\n      const {\n        target,\n        isIntersecting\n      } = entry;\n      if (target === this.element) {\n        this.isIntersecting = isIntersecting;\n        this.isPiP = isElementInPiP(this.element);\n        this.visibilityChangedAt = Date.now();\n        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n      }\n    };\n    this.onEnterPiP = () => {\n      var _a, _b, _c;\n      (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener('pagehide', this.onLeavePiP);\n      this.isPiP = isElementInPiP(this.element);\n      (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\n    };\n    this.onLeavePiP = () => {\n      var _a;\n      this.isPiP = isElementInPiP(this.element);\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element = element;\n    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n    this.isPiP = isWeb() && isElementInPiP(element);\n    this.visibilityChangedAt = 0;\n  }\n  width() {\n    return this.element.clientWidth;\n  }\n  height() {\n    return this.element.clientHeight;\n  }\n  observe() {\n    var _a, _b, _c;\n    // make sure we update the current visible state once we start to observe\n    this.isIntersecting = isElementInViewport(this.element);\n    this.isPiP = isElementInPiP(this.element);\n    this.element.handleResize = () => {\n      var _a;\n      (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element.handleVisibilityChanged = this.onVisibilityChanged;\n    getIntersectionObserver().observe(this.element);\n    getResizeObserver().observe(this.element);\n    this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);\n    this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);\n    (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener('enter', this.onEnterPiP);\n    (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener('pagehide', this.onLeavePiP);\n  }\n  stopObserving() {\n    var _a, _b, _c, _d, _e;\n    (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n    this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);\n    this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);\n    (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener('enter', this.onEnterPiP);\n    (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener('pagehide', this.onLeavePiP);\n  }\n}\nfunction isElementInPiP(el) {\n  var _a, _b;\n  // Simple video PiP\n  if (document.pictureInPictureElement === el) return true;\n  // Document PiP\n  if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\n  return false;\n}\n// does not account for occlusion by other elements or opacity property\nfunction isElementInViewport(el, win) {\n  const viewportWindow = win || window;\n  let top = el.offsetTop;\n  let left = el.offsetLeft;\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n  const {\n    hidden\n  } = el;\n  const {\n    display\n  } = getComputedStyle(el);\n  while (el.offsetParent) {\n    el = el.offsetParent;\n    top += el.offsetTop;\n    left += el.offsetLeft;\n  }\n  return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== 'none';\n}\n\nclass TrackPublication extends eventsExports.EventEmitter {\n  constructor(kind, id, name, loggerOptions) {\n    var _a;\n    super();\n    this.metadataMuted = false;\n    this.encryption = Encryption_Type.NONE;\n    this.log = livekitLogger;\n    this.handleMuted = () => {\n      this.emit(TrackEvent.Muted);\n    };\n    this.handleUnmuted = () => {\n      this.emit(TrackEvent.Unmuted);\n    };\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n    this.loggerContextCb = this.loggerContextCb;\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this.trackSid = id;\n    this.trackName = name;\n    this.source = Track.Source.Unknown;\n  }\n  /** @internal */\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Muted, this.handleMuted);\n      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n    this.track = track;\n    if (track) {\n      // forward events\n      track.on(TrackEvent.Muted, this.handleMuted);\n      track.on(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n  }\n  get logContext() {\n    var _a;\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n  }\n  get isMuted() {\n    return this.metadataMuted;\n  }\n  get isEnabled() {\n    return true;\n  }\n  get isSubscribed() {\n    return this.track !== undefined;\n  }\n  get isEncrypted() {\n    return this.encryption !== Encryption_Type.NONE;\n  }\n  /**\n   * an [AudioTrack] if this publication holds an audio track\n   */\n  get audioTrack() {\n    if (isAudioTrack(this.track)) {\n      return this.track;\n    }\n  }\n  /**\n   * an [VideoTrack] if this publication holds a video track\n   */\n  get videoTrack() {\n    if (isVideoTrack(this.track)) {\n      return this.track;\n    }\n  }\n  /** @internal */\n  updateInfo(info) {\n    this.trackSid = info.sid;\n    this.trackName = info.name;\n    this.source = Track.sourceFromProto(info.source);\n    this.mimeType = info.mimeType;\n    if (this.kind === Track.Kind.Video && info.width > 0) {\n      this.dimensions = {\n        width: info.width,\n        height: info.height\n      };\n      this.simulcasted = info.simulcast;\n    }\n    this.encryption = info.encryption;\n    this.trackInfo = info;\n    this.log.debug('update publication info', Object.assign(Object.assign({}, this.logContext), {\n      info\n    }));\n  }\n}\n(function (TrackPublication) {\n  (function (SubscriptionStatus) {\n    SubscriptionStatus[\"Desired\"] = \"desired\";\n    SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n    SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n  })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n  (function (PermissionStatus) {\n    PermissionStatus[\"Allowed\"] = \"allowed\";\n    PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n  })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\n\nclass LocalTrackPublication extends TrackPublication {\n  get isUpstreamPaused() {\n    var _a;\n    return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n  }\n  constructor(kind, ti, track, loggerOptions) {\n    super(kind, ti.sid, ti.name, loggerOptions);\n    this.track = undefined;\n    this.handleTrackEnded = () => {\n      this.emit(TrackEvent.Ended);\n    };\n    this.updateInfo(ti);\n    this.setTrack(track);\n  }\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n    }\n  }\n  get isMuted() {\n    if (this.track) {\n      return this.track.isMuted;\n    }\n    return super.isMuted;\n  }\n  get audioTrack() {\n    return super.audioTrack;\n  }\n  get videoTrack() {\n    return super.videoTrack;\n  }\n  get isLocal() {\n    return true;\n  }\n  /**\n   * Mute the track associated with this publication\n   */\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n    });\n  }\n  /**\n   * Unmute track associated with this publication\n   */\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n    });\n  }\n  /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n    });\n  }\n  /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n    });\n  }\n  getTrackFeatures() {\n    var _a;\n    if (isAudioTrack(this.track)) {\n      const settings = this.track.getSourceTrackSettings();\n      const features = new Set();\n      if (settings.autoGainControl) {\n        features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n      }\n      if (settings.echoCancellation) {\n        features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\n      }\n      if (settings.noiseSuppression) {\n        features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n      }\n      if (settings.channelCount && settings.channelCount > 1) {\n        features.add(AudioTrackFeature.TF_STEREO);\n      }\n      if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\n        features.add(AudioTrackFeature.TF_NO_DTX);\n      }\n      if (this.track.enhancedNoiseCancellation) {\n        features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\n      }\n      return Array.from(features.values());\n    } else return [];\n  }\n}\n\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */\nfunction createLocalTracks(options, loggerOptions) {\n  return __awaiter(this, void 0, void 0, function* () {\n    options !== null && options !== void 0 ? options : options = {};\n    let attemptExactMatch = false;\n    const {\n      audioProcessor,\n      videoProcessor,\n      optionsWithoutProcessor: internalOptions\n    } = extractProcessorsFromOptions(options);\n    let retryAudioOptions = internalOptions.audio;\n    let retryVideoOptions = internalOptions.video;\n    if (audioProcessor && typeof internalOptions.audio === 'object') {\n      internalOptions.audio.processor = audioProcessor;\n    }\n    if (videoProcessor && typeof internalOptions.video === 'object') {\n      internalOptions.video.processor = videoProcessor;\n    }\n    // if the user passes a device id as a string, we default to exact match\n    if (options.audio && typeof internalOptions.audio === 'object' && typeof internalOptions.audio.deviceId === 'string') {\n      const deviceId = internalOptions.audio.deviceId;\n      internalOptions.audio.deviceId = {\n        exact: deviceId\n      };\n      attemptExactMatch = true;\n      retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\n        deviceId: {\n          ideal: deviceId\n        }\n      });\n    }\n    if (internalOptions.video && typeof internalOptions.video === 'object' && typeof internalOptions.video.deviceId === 'string') {\n      const deviceId = internalOptions.video.deviceId;\n      internalOptions.video.deviceId = {\n        exact: deviceId\n      };\n      attemptExactMatch = true;\n      retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\n        deviceId: {\n          ideal: deviceId\n        }\n      });\n    }\n    // TODO if internal options don't have device Id specified, set it to 'default'\n    if (internalOptions.audio === true || typeof internalOptions.audio === 'object' && !internalOptions.audio.deviceId) {\n      internalOptions.audio = {\n        deviceId: 'default'\n      };\n    }\n    if (internalOptions.video === true || typeof internalOptions.video === 'object' && !internalOptions.video.deviceId) {\n      internalOptions.video = {\n        deviceId: 'default'\n      };\n    }\n    const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\n    const constraints = constraintsForOptions(opts);\n    // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n    // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n    if (internalOptions.audio) {\n      DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('audioinput'));\n    }\n    if (internalOptions.video) {\n      DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('videoinput'));\n    }\n    try {\n      const stream = yield mediaPromise;\n      return yield Promise.all(stream.getTracks().map(mediaStreamTrack => __awaiter(this, void 0, void 0, function* () {\n        const isAudio = mediaStreamTrack.kind === 'audio';\n        let trackOptions = isAudio ? opts.audio : opts.video;\n        if (typeof trackOptions === 'boolean' || !trackOptions) {\n          trackOptions = {};\n        }\n        let trackConstraints;\n        const conOrBool = isAudio ? constraints.audio : constraints.video;\n        if (typeof conOrBool !== 'boolean') {\n          trackConstraints = conOrBool;\n        }\n        // update the constraints with the device id the user gave permissions to in the permission prompt\n        // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n        const newDeviceId = mediaStreamTrack.getSettings().deviceId;\n        if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\n          trackConstraints.deviceId = newDeviceId;\n        } else if (!trackConstraints) {\n          trackConstraints = {\n            deviceId: newDeviceId\n          };\n        }\n        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\n        if (track.kind === Track.Kind.Video) {\n          track.source = Track.Source.Camera;\n        } else if (track.kind === Track.Kind.Audio) {\n          track.source = Track.Source.Microphone;\n        }\n        track.mediaStream = stream;\n        if (isAudioTrack(track) && audioProcessor) {\n          yield track.setProcessor(audioProcessor);\n        } else if (isVideoTrack(track) && videoProcessor) {\n          yield track.setProcessor(videoProcessor);\n        }\n        return track;\n      })));\n    } catch (e) {\n      if (!attemptExactMatch) {\n        throw e;\n      }\n      return createLocalTracks(Object.assign(Object.assign({}, options), {\n        audio: retryAudioOptions,\n        video: retryVideoOptions\n      }), loggerOptions);\n    }\n  });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */\nfunction createLocalVideoTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: false,\n      video: options !== null && options !== void 0 ? options : true\n    });\n    return tracks[0];\n  });\n}\nfunction createLocalAudioTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: options !== null && options !== void 0 ? options : true,\n      video: false\n    });\n    return tracks[0];\n  });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */\nfunction createLocalScreenTracks(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.resolution === undefined && !isSafari17()) {\n      options.resolution = ScreenSharePresets.h1080fps30.resolution;\n    }\n    if (navigator.mediaDevices.getDisplayMedia === undefined) {\n      throw new DeviceUnsupportedError('getDisplayMedia not supported');\n    }\n    const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n    const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n    const tracks = stream.getVideoTracks();\n    if (tracks.length === 0) {\n      throw new TrackInvalidError('no video track found');\n    }\n    const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n    screenVideo.source = Track.Source.ScreenShare;\n    const localTracks = [screenVideo];\n    if (stream.getAudioTracks().length > 0) {\n      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n      screenAudio.source = Track.Source.ScreenShareAudio;\n      localTracks.push(screenAudio);\n    }\n    return localTracks;\n  });\n}\n\nvar ConnectionQuality;\n(function (ConnectionQuality) {\n  ConnectionQuality[\"Excellent\"] = \"excellent\";\n  ConnectionQuality[\"Good\"] = \"good\";\n  ConnectionQuality[\"Poor\"] = \"poor\";\n  /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */\n  ConnectionQuality[\"Lost\"] = \"lost\";\n  ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n  switch (q) {\n    case ConnectionQuality$1.EXCELLENT:\n      return ConnectionQuality.Excellent;\n    case ConnectionQuality$1.GOOD:\n      return ConnectionQuality.Good;\n    case ConnectionQuality$1.POOR:\n      return ConnectionQuality.Poor;\n    case ConnectionQuality$1.LOST:\n      return ConnectionQuality.Lost;\n    default:\n      return ConnectionQuality.Unknown;\n  }\n}\nclass Participant extends eventsExports.EventEmitter {\n  get logContext() {\n    var _a, _b;\n    return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n  get isEncrypted() {\n    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every(tr => tr.isEncrypted);\n  }\n  get isAgent() {\n    var _a;\n    return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\n  }\n  get kind() {\n    return this._kind;\n  }\n  /** participant attributes, similar to metadata, but as a key/value map */\n  get attributes() {\n    return Object.freeze(Object.assign({}, this._attributes));\n  }\n  /** @internal */\n  constructor(sid, identity, name, metadata, attributes, loggerOptions) {\n    let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\n    var _a;\n    super();\n    /** audio level between 0-1.0, 1 being loudest, 0 being softest */\n    this.audioLevel = 0;\n    /** if participant is currently speaking */\n    this.isSpeaking = false;\n    this._connectionQuality = ConnectionQuality.Unknown;\n    this.log = livekitLogger;\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n    this.loggerOptions = loggerOptions;\n    this.setMaxListeners(100);\n    this.sid = sid;\n    this.identity = identity;\n    this.name = name;\n    this.metadata = metadata;\n    this.audioTrackPublications = new Map();\n    this.videoTrackPublications = new Map();\n    this.trackPublications = new Map();\n    this._kind = kind;\n    this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\n  }\n  getTrackPublications() {\n    return Array.from(this.trackPublications.values());\n  }\n  /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   */\n  getTrackPublication(source) {\n    for (const [, pub] of this.trackPublications) {\n      if (pub.source === source) {\n        return pub;\n      }\n    }\n  }\n  /**\n   * Finds the first track that matches the track's name.\n   */\n  getTrackPublicationByName(name) {\n    for (const [, pub] of this.trackPublications) {\n      if (pub.trackName === name) {\n        return pub;\n      }\n    }\n  }\n  get connectionQuality() {\n    return this._connectionQuality;\n  }\n  get isCameraEnabled() {\n    var _a;\n    const track = this.getTrackPublication(Track.Source.Camera);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isMicrophoneEnabled() {\n    var _a;\n    const track = this.getTrackPublication(Track.Source.Microphone);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isScreenShareEnabled() {\n    const track = this.getTrackPublication(Track.Source.ScreenShare);\n    return !!track;\n  }\n  get isLocal() {\n    return false;\n  }\n  /** when participant joined the room */\n  get joinedAt() {\n    if (this.participantInfo) {\n      return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n    }\n    return new Date();\n  }\n  /** @internal */\n  updateInfo(info) {\n    // it's possible the update could be applied out of order due to await\n    // during reconnect sequences. when that happens, it's possible for server\n    // to have sent more recent version of participant info while JS is waiting\n    // to process the existing payload.\n    // when the participant sid remains the same, and we already have a later version\n    // of the payload, they can be safely skipped\n    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n      return false;\n    }\n    this.identity = info.identity;\n    this.sid = info.sid;\n    this._setName(info.name);\n    this._setMetadata(info.metadata);\n    this._setAttributes(info.attributes);\n    if (info.permission) {\n      this.setPermissions(info.permission);\n    }\n    // set this last so setMetadata can detect changes\n    this.participantInfo = info;\n    this.log.trace('update participant info', Object.assign(Object.assign({}, this.logContext), {\n      info\n    }));\n    return true;\n  }\n  /**\n   * Updates metadata from server\n   **/\n  _setMetadata(md) {\n    const changed = this.metadata !== md;\n    const prevMetadata = this.metadata;\n    this.metadata = md;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n    }\n  }\n  _setName(name) {\n    const changed = this.name !== name;\n    this.name = name;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantNameChanged, name);\n    }\n  }\n  /**\n   * Updates metadata from server\n   **/\n  _setAttributes(attributes) {\n    const diff = diffAttributes(this.attributes, attributes);\n    this._attributes = attributes;\n    if (Object.keys(diff).length > 0) {\n      this.emit(ParticipantEvent.AttributesChanged, diff);\n    }\n  }\n  /** @internal */\n  setPermissions(permissions) {\n    var _a, _b, _c, _d, _e, _f;\n    const prevPermissions = this.permissions;\n    const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {\n      var _a;\n      return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n    }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\n    this.permissions = permissions;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n    }\n    return changed;\n  }\n  /** @internal */\n  setIsSpeaking(speaking) {\n    if (speaking === this.isSpeaking) {\n      return;\n    }\n    this.isSpeaking = speaking;\n    if (speaking) {\n      this.lastSpokeAt = new Date();\n    }\n    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n  }\n  /** @internal */\n  setConnectionQuality(q) {\n    const prevQuality = this._connectionQuality;\n    this._connectionQuality = qualityFromProto(q);\n    if (prevQuality !== this._connectionQuality) {\n      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n    }\n  }\n  /**\n   * @internal\n   */\n  setAudioContext(ctx) {\n    this.audioContext = ctx;\n    this.audioTrackPublications.forEach(track => isAudioTrack(track.track) && track.track.setAudioContext(ctx));\n  }\n  addTrackPublication(publication) {\n    // forward publication driven events\n    publication.on(TrackEvent.Muted, () => {\n      this.emit(ParticipantEvent.TrackMuted, publication);\n    });\n    publication.on(TrackEvent.Unmuted, () => {\n      this.emit(ParticipantEvent.TrackUnmuted, publication);\n    });\n    const pub = publication;\n    if (pub.track) {\n      pub.track.sid = publication.trackSid;\n    }\n    this.trackPublications.set(publication.trackSid, publication);\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTrackPublications.set(publication.trackSid, publication);\n        break;\n      case Track.Kind.Video:\n        this.videoTrackPublications.set(publication.trackSid, publication);\n        break;\n    }\n  }\n}\n\nfunction trackPermissionToProto(perms) {\n  var _a, _b, _c;\n  if (!perms.participantSid && !perms.participantIdentity) {\n    throw new Error('Invalid track permission, must provide at least one of participantIdentity and participantSid');\n  }\n  return new TrackPermission({\n    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',\n    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',\n    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n    trackSids: perms.allowedTrackSids || []\n  });\n}\n\nconst STREAM_CHUNK_SIZE = 15000;\nclass LocalParticipant extends Participant {\n  /** @internal */\n  constructor(sid, identity, engine, options, roomRpcHandlers) {\n    super(sid, identity, undefined, undefined, undefined, {\n      loggerName: options.loggerName,\n      loggerContextCb: () => this.engine.logContext\n    });\n    this.pendingPublishing = new Set();\n    this.pendingPublishPromises = new Map();\n    this.participantTrackPermissions = [];\n    this.allParticipantsAllowedToSubscribe = true;\n    this.encryptionType = Encryption_Type.NONE;\n    this.enabledPublishVideoCodecs = [];\n    this.pendingAcks = new Map();\n    this.pendingResponses = new Map();\n    this.handleReconnecting = () => {\n      if (!this.reconnectFuture) {\n        this.reconnectFuture = new Future();\n      }\n    };\n    this.handleReconnected = () => {\n      var _a, _b;\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n      this.reconnectFuture = undefined;\n      this.updateTrackSubscriptionPermissions();\n    };\n    this.handleDisconnected = () => {\n      var _a, _b;\n      if (this.reconnectFuture) {\n        this.reconnectFuture.promise.catch(e => this.log.warn(e.message, this.logContext));\n        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, 'Got disconnected during reconnection attempt');\n        this.reconnectFuture = undefined;\n      }\n    };\n    this.handleSignalRequestResponse = response => {\n      const {\n        requestId,\n        reason,\n        message\n      } = response;\n      const targetRequest = this.pendingSignalRequests.get(requestId);\n      if (targetRequest) {\n        if (reason !== RequestResponse_Reason.OK) {\n          targetRequest.reject(new SignalRequestError(message, reason));\n        }\n        this.pendingSignalRequests.delete(requestId);\n      }\n    };\n    this.handleDataPacket = packet => {\n      switch (packet.value.case) {\n        case 'rpcResponse':\n          let rpcResponse = packet.value.value;\n          let payload = null;\n          let error = null;\n          if (rpcResponse.value.case === 'payload') {\n            payload = rpcResponse.value.value;\n          } else if (rpcResponse.value.case === 'error') {\n            error = RpcError.fromProto(rpcResponse.value.value);\n          }\n          this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\n          break;\n        case 'rpcAck':\n          let rpcAck = packet.value.value;\n          this.handleIncomingRpcAck(rpcAck.requestId);\n          break;\n      }\n    };\n    this.updateTrackSubscriptionPermissions = () => {\n      this.log.debug('updating track subscription permissions', Object.assign(Object.assign({}, this.logContext), {\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n        participantTrackPermissions: this.participantTrackPermissions\n      }));\n      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map(p => trackPermissionToProto(p)));\n    };\n    /** @internal */\n    this.onTrackUnmuted = track => {\n      this.onTrackMuted(track, track.isUpstreamPaused);\n    };\n    // when the local track changes in mute status, we'll notify server as such\n    /** @internal */\n    this.onTrackMuted = (track, muted) => {\n      if (muted === undefined) {\n        muted = true;\n      }\n      if (!track.sid) {\n        this.log.error('could not update mute status for unpublished track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return;\n      }\n      this.engine.updateMuteStatus(track.sid, muted);\n    };\n    this.onTrackUpstreamPaused = track => {\n      this.log.debug('upstream paused', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      this.onTrackMuted(track, true);\n    };\n    this.onTrackUpstreamResumed = track => {\n      this.log.debug('upstream resumed', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      this.onTrackMuted(track, track.isMuted);\n    };\n    this.onTrackFeatureUpdate = track => {\n      const pub = this.audioTrackPublications.get(track.sid);\n      if (!pub) {\n        this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\n        return;\n      }\n      this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\n    };\n    this.handleSubscribedQualityUpdate = update => __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      var _d, _e;\n      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n        return;\n      }\n      const pub = this.videoTrackPublications.get(update.trackSid);\n      if (!pub) {\n        this.log.warn('received subscribed quality update for unknown track', Object.assign(Object.assign({}, this.logContext), {\n          trackSid: update.trackSid\n        }));\n        return;\n      }\n      if (update.subscribedCodecs.length > 0) {\n        if (!pub.videoTrack) {\n          return;\n        }\n        const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n        try {\n          for (var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true) {\n            _c = newCodecs_1_1.value;\n            _f = false;\n            const codec = _c;\n            if (isBackupCodec(codec)) {\n              this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n              yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else if (update.subscribedQualities.length > 0) {\n        yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n      }\n    });\n    this.handleLocalTrackUnpublished = unpublished => {\n      const track = this.trackPublications.get(unpublished.trackSid);\n      if (!track) {\n        this.log.warn('received unpublished event for unknown track', Object.assign(Object.assign({}, this.logContext), {\n          trackSid: unpublished.trackSid\n        }));\n        return;\n      }\n      this.unpublishTrack(track.track);\n    };\n    this.handleTrackEnded = track => __awaiter(this, void 0, void 0, function* () {\n      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n        this.log.debug('unpublishing local track due to TrackEnded', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        this.unpublishTrack(track);\n      } else if (track.isUserProvided) {\n        yield track.mute();\n      } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\n        try {\n          if (isWeb()) {\n            try {\n              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\n                // @ts-ignore\n                name: track.source === Track.Source.Camera ? 'camera' : 'microphone'\n              });\n              if (currentPermissions && currentPermissions.state === 'denied') {\n                this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                // detect granted change after permissions were denied to try and resume then\n                currentPermissions.onchange = () => {\n                  if (currentPermissions.state !== 'denied') {\n                    if (!track.isMuted) {\n                      track.restartTrack();\n                    }\n                    currentPermissions.onchange = null;\n                  }\n                };\n                throw new Error('GetUserMedia Permission denied');\n              }\n            } catch (e) {\n              // permissions query fails for firefox, we continue and try to restart the track\n            }\n          }\n          if (!track.isMuted) {\n            this.log.debug('track ended, attempting to use a different device', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            if (isLocalAudioTrack(track)) {\n              // fall back to default device if available\n              yield track.restartTrack({\n                deviceId: 'default'\n              });\n            } else {\n              yield track.restartTrack();\n            }\n          }\n        } catch (e) {\n          this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n          yield track.mute();\n        }\n      }\n    });\n    this.audioTrackPublications = new Map();\n    this.videoTrackPublications = new Map();\n    this.trackPublications = new Map();\n    this.engine = engine;\n    this.roomOptions = options;\n    this.setupEngine(engine);\n    this.activeDeviceMap = new Map([['audioinput', 'default'], ['videoinput', 'default'], ['audiooutput', 'default']]);\n    this.pendingSignalRequests = new Map();\n    this.rpcHandlers = roomRpcHandlers;\n  }\n  get lastCameraError() {\n    return this.cameraError;\n  }\n  get lastMicrophoneError() {\n    return this.microphoneError;\n  }\n  get isE2EEEnabled() {\n    return this.encryptionType !== Encryption_Type.NONE;\n  }\n  getTrackPublication(source) {\n    const track = super.getTrackPublication(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackPublicationByName(name) {\n    const track = super.getTrackPublicationByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * @internal\n   */\n  setupEngine(engine) {\n    this.engine = engine;\n    this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {\n      const pub = this.trackPublications.get(trackSid);\n      if (!pub || !pub.track) {\n        return;\n      }\n      if (muted) {\n        pub.mute();\n      } else {\n        pub.unmute();\n      }\n    });\n    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\n  }\n  /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */\n  setMetadata(metadata) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMetadataUpdate({\n        metadata\n      });\n    });\n  }\n  /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */\n  setName(name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMetadataUpdate({\n        name\n      });\n    });\n  }\n  /**\n   * Set or update participant attributes. It will make updates only to keys that\n   * are present in `attributes`, and will not override others.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param attributes attributes to update\n   */\n  setAttributes(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMetadataUpdate({\n        attributes\n      });\n    });\n  }\n  requestMetadataUpdate(_a) {\n    return __awaiter(this, arguments, void 0, function (_ref) {\n      var _this = this;\n      let {\n        metadata,\n        name,\n        attributes\n      } = _ref;\n      return function* () {\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\n          var _a, _b;\n          try {\n            let isRejected = false;\n            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : '', (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : '', attributes);\n            const startTime = performance.now();\n            this.pendingSignalRequests.set(requestId, {\n              resolve,\n              reject: error => {\n                reject(error);\n                isRejected = true;\n              },\n              values: {\n                name,\n                metadata,\n                attributes\n              }\n            });\n            while (performance.now() - startTime < 5000 && !isRejected) {\n              if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every(_ref2 => {\n                let [key, value] = _ref2;\n                return this.attributes[key] === value || value === '' && !this.attributes[key];\n              }))) {\n                this.pendingSignalRequests.delete(requestId);\n                resolve();\n                return;\n              }\n              yield sleep(50);\n            }\n            reject(new SignalRequestError('Request to update local metadata timed out', 'TimeoutError'));\n          } catch (e) {\n            if (e instanceof Error) reject(e);\n          }\n        }));\n      }();\n    });\n  }\n  /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setCameraEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n  }\n  /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setMicrophoneEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n  }\n  /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setScreenShareEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n  }\n  /** @internal */\n  setPermissions(permissions) {\n    const prevPermissions = this.permissions;\n    const changed = super.setPermissions(permissions);\n    if (changed && prevPermissions) {\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n    }\n    return changed;\n  }\n  /** @internal */\n  setE2EEEnabled(enabled) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n      yield this.republishAllTracks(undefined, false);\n    });\n  }\n  setTrackEnabled(source, enabled, options, publishOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      this.log.debug('setTrackEnabled', Object.assign(Object.assign({}, this.logContext), {\n        source,\n        enabled\n      }));\n      if (this.republishPromise) {\n        yield this.republishPromise;\n      }\n      let track = this.getTrackPublication(source);\n      if (enabled) {\n        if (track) {\n          yield track.unmute();\n        } else {\n          let localTracks;\n          if (this.pendingPublishing.has(source)) {\n            const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\n            if (!pendingTrack) {\n              this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\n                source\n              }));\n            }\n            yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\n            return pendingTrack;\n          }\n          this.pendingPublishing.add(source);\n          try {\n            switch (source) {\n              case Track.Source.Camera:\n                localTracks = yield this.createTracks({\n                  video: (_a = options) !== null && _a !== void 0 ? _a : true\n                });\n                break;\n              case Track.Source.Microphone:\n                localTracks = yield this.createTracks({\n                  audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                });\n                break;\n              case Track.Source.ScreenShare:\n                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                break;\n              default:\n                throw new TrackInvalidError(source);\n            }\n          } catch (e) {\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\n              tr.stop();\n            });\n            if (e instanceof Error) {\n              this.emit(ParticipantEvent.MediaDevicesError, e);\n            }\n            this.pendingPublishing.delete(source);\n            throw e;\n          }\n          try {\n            const publishPromises = [];\n            for (const localTrack of localTracks) {\n              this.log.info('publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n              publishPromises.push(this.publishTrack(localTrack, publishOptions));\n            }\n            const publishedTracks = yield Promise.all(publishPromises);\n            // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n            // revisit if we want to return an array of tracks instead for v2\n            [track] = publishedTracks;\n          } catch (e) {\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\n              tr.stop();\n            });\n            throw e;\n          } finally {\n            this.pendingPublishing.delete(source);\n          }\n        }\n      } else {\n        if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\n          // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\n          track = yield this.waitForPendingPublicationOfSource(source);\n          if (!track) {\n            this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\n              source\n            }));\n          }\n        }\n        if (track && track.track) {\n          // screenshare cannot be muted, unpublish instead\n          if (source === Track.Source.ScreenShare) {\n            track = yield this.unpublishTrack(track.track);\n            const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\n            if (screenAudioTrack && screenAudioTrack.track) {\n              this.unpublishTrack(screenAudioTrack.track);\n            }\n          } else {\n            yield track.mute();\n          }\n        }\n      }\n      return track;\n    });\n  }\n  /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */\n  enableCameraAndMicrophone() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n        // no-op it's already been requested\n        return;\n      }\n      this.pendingPublishing.add(Track.Source.Camera);\n      this.pendingPublishing.add(Track.Source.Microphone);\n      try {\n        const tracks = yield this.createTracks({\n          audio: true,\n          video: true\n        });\n        yield Promise.all(tracks.map(track => this.publishTrack(track)));\n      } finally {\n        this.pendingPublishing.delete(Track.Source.Camera);\n        this.pendingPublishing.delete(Track.Source.Microphone);\n      }\n    });\n  }\n  /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */\n  createTracks(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      options !== null && options !== void 0 ? options : options = {};\n      const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n      try {\n        const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        const localTracks = tracks.map(track => {\n          if (isAudioTrack(track)) {\n            this.microphoneError = undefined;\n            track.setAudioContext(this.audioContext);\n            track.source = Track.Source.Microphone;\n            this.emit(ParticipantEvent.AudioStreamAcquired);\n          }\n          if (isVideoTrack(track)) {\n            this.cameraError = undefined;\n            track.source = Track.Source.Camera;\n          }\n          return track;\n        });\n        return localTracks;\n      } catch (err) {\n        if (err instanceof Error) {\n          if (options.audio) {\n            this.microphoneError = err;\n          }\n          if (options.video) {\n            this.cameraError = err;\n          }\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */\n  createScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (options === undefined) {\n        options = {};\n      }\n      if (navigator.mediaDevices.getDisplayMedia === undefined) {\n        throw new DeviceUnsupportedError('getDisplayMedia not supported');\n      }\n      if (options.resolution === undefined && !isSafari17()) {\n        // we need to constrain the dimensions, otherwise it could lead to low bitrate\n        // due to encoding a huge video. Encoding such large surfaces is really expensive\n        // unfortunately Safari 17 has a but and cannot be constrained by default\n        options.resolution = ScreenSharePresets.h1080fps30.resolution;\n      }\n      const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n      const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n      const tracks = stream.getVideoTracks();\n      if (tracks.length === 0) {\n        throw new TrackInvalidError('no video track found');\n      }\n      const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n        loggerName: this.roomOptions.loggerName,\n        loggerContextCb: () => this.logContext\n      });\n      screenVideo.source = Track.Source.ScreenShare;\n      if (options.contentHint) {\n        screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n      }\n      const localTracks = [screenVideo];\n      if (stream.getAudioTracks().length > 0) {\n        this.emit(ParticipantEvent.AudioStreamAcquired);\n        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        screenAudio.source = Track.Source.ScreenShareAudio;\n        localTracks.push(screenAudio);\n      }\n      return localTracks;\n    });\n  }\n  /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */\n  publishTrack(track, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.publishOrRepublishTrack(track, options);\n    });\n  }\n  publishOrRepublishTrack(track_1, options_1) {\n    return __awaiter(this, arguments, void 0, function (track, options) {\n      var _this2 = this;\n      let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return function* () {\n        var _a, _b, _c, _d;\n        if (isLocalAudioTrack(track)) {\n          track.setAudioContext(_this2.audioContext);\n        }\n        yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n        if (_this2.republishPromise && !isRepublish) {\n          yield _this2.republishPromise;\n        }\n        if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\n          yield _this2.pendingPublishPromises.get(track);\n        }\n        let defaultConstraints;\n        if (track instanceof MediaStreamTrack) {\n          defaultConstraints = track.getConstraints();\n        } else {\n          // we want to access constraints directly as `track.mediaStreamTrack`\n          // might be pointing to a non-device track (e.g. processed track) already\n          defaultConstraints = track.constraints;\n          let deviceKind = undefined;\n          switch (track.source) {\n            case Track.Source.Microphone:\n              deviceKind = 'audioinput';\n              break;\n            case Track.Source.Camera:\n              deviceKind = 'videoinput';\n          }\n          if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\n            defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n              deviceId: _this2.activeDeviceMap.get(deviceKind)\n            });\n          }\n        }\n        // convert raw media track into audio or video track\n        if (track instanceof MediaStreamTrack) {\n          switch (track.kind) {\n            case 'audio':\n              track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\n                loggerName: _this2.roomOptions.loggerName,\n                loggerContextCb: () => _this2.logContext\n              });\n              break;\n            case 'video':\n              track = new LocalVideoTrack(track, defaultConstraints, true, {\n                loggerName: _this2.roomOptions.loggerName,\n                loggerContextCb: () => _this2.logContext\n              });\n              break;\n            default:\n              throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n          }\n        } else {\n          track.updateLoggerOptions({\n            loggerName: _this2.roomOptions.loggerName,\n            loggerContextCb: () => _this2.logContext\n          });\n        }\n        // is it already published? if so skip\n        let existingPublication;\n        _this2.trackPublications.forEach(publication => {\n          if (!publication.track) {\n            return;\n          }\n          if (publication.track === track) {\n            existingPublication = publication;\n          }\n        });\n        if (existingPublication) {\n          _this2.log.warn('track has already been published, skipping', Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\n          return existingPublication;\n        }\n        const isStereoInput = 'channelCount' in track.mediaStreamTrack.getSettings() &&\n        // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n        track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n        const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n        // disable dtx for stereo track if not enabled explicitly\n        if (isStereo) {\n          if (!options) {\n            options = {};\n          }\n          if (options.dtx === undefined) {\n            _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\n          }\n          if (options.red === undefined) {\n            _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n          }\n          (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n          (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n        }\n        const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\n        if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\n          _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\n          opts.simulcast = false;\n        }\n        if (opts.source) {\n          track.source = opts.source;\n        }\n        const publishPromise = new Promise((resolve, reject) => __awaiter(_this2, void 0, void 0, function* () {\n          try {\n            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\n              this.log.debug('deferring track publication until signal is connected', Object.assign(Object.assign({}, this.logContext), {\n                track: getLogContextFromTrack(track)\n              }));\n              const onSignalConnected = () => __awaiter(this, void 0, void 0, function* () {\n                try {\n                  const publication = yield this.publish(track, opts, isStereo);\n                  resolve(publication);\n                } catch (e) {\n                  reject(e);\n                }\n              });\n              setTimeout(() => {\n                this.engine.off(EngineEvent.SignalConnected, onSignalConnected);\n                reject(new PublishTrackError('publishing rejected as engine not connected within timeout', 408));\n              }, 15000);\n              this.engine.once(EngineEvent.SignalConnected, onSignalConnected);\n              this.engine.on(EngineEvent.Closing, () => {\n                this.engine.off(EngineEvent.SignalConnected, onSignalConnected);\n                reject(new PublishTrackError('publishing rejected as engine closed', 499));\n              });\n            } else {\n              try {\n                const publication = yield this.publish(track, opts, isStereo);\n                resolve(publication);\n              } catch (e) {\n                reject(e);\n              }\n            }\n          } catch (e) {\n            reject(e);\n          }\n        }));\n        _this2.pendingPublishPromises.set(track, publishPromise);\n        try {\n          const publication = yield publishPromise;\n          return publication;\n        } catch (e) {\n          throw e;\n        } finally {\n          _this2.pendingPublishPromises.delete(track);\n        }\n      }();\n    });\n  }\n  hasPermissionsToPublish(track) {\n    if (!this.permissions) {\n      this.log.warn('no permissions present for publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      return false;\n    }\n    const {\n      canPublish,\n      canPublishSources\n    } = this.permissions;\n    if (canPublish && (canPublishSources.length === 0 || canPublishSources.map(source => getTrackSourceFromProto(source)).includes(track.source))) {\n      return true;\n    }\n    this.log.warn('insufficient permissions to publish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n    return false;\n  }\n  publish(track, opts, isStereo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n      if (!this.hasPermissionsToPublish(track)) {\n        throw new PublishTrackError('failed to publish track, insufficient permissions', 403);\n      }\n      const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => isLocalTrack(track) && publishedTrack.source === track.source);\n      if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n        this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      }\n      if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\n        track.stopOnMute = true;\n      }\n      if (track.source === Track.Source.ScreenShare && isFireFox()) {\n        // Firefox does not work well with simulcasted screen share\n        // we frequently get no data on layer 0 when enabled\n        opts.simulcast = false;\n      }\n      // require full AV1/VP9 SVC support prior to using it\n      if (opts.videoCodec === 'av1' && !supportsAV1()) {\n        opts.videoCodec = undefined;\n      }\n      if (opts.videoCodec === 'vp9' && !supportsVP9()) {\n        opts.videoCodec = undefined;\n      }\n      if (opts.videoCodec === undefined) {\n        opts.videoCodec = defaultVideoCodec;\n      }\n      if (this.enabledPublishVideoCodecs.length > 0) {\n        // fallback to a supported codec if it is not supported\n        if (!this.enabledPublishVideoCodecs.some(c => opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\n          opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\n        }\n      }\n      const videoCodec = opts.videoCodec;\n      // handle track actions\n      track.on(TrackEvent.Muted, this.onTrackMuted);\n      track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n      track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n      // create track publication from track\n      const req = new AddTrackRequest({\n        // get local track id for use during publishing\n        cid: track.mediaStreamTrack.id,\n        name: opts.name,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n        encryption: this.encryptionType,\n        stereo: isStereo,\n        disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n        stream: opts === null || opts === void 0 ? void 0 : opts.stream,\n        backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy\n      });\n      // compute encodings and layers for video\n      let encodings;\n      if (track.kind === Track.Kind.Video) {\n        let dims = {\n          width: 0,\n          height: 0\n        };\n        try {\n          dims = yield track.waitForDimensions();\n        } catch (e) {\n          // use defaults, it's quite painful for congestion control without simulcast\n          // so using default dims according to publish settings\n          const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n          dims = {\n            width: defaultRes.width,\n            height: defaultRes.height\n          };\n          // log failure\n          this.log.error('could not determine track dimensions, using defaults', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n            dims\n          }));\n        }\n        // width and height should be defined for video\n        req.width = dims.width;\n        req.height = dims.height;\n        // for svc codecs, disable simulcast and use vp8 for backup codec\n        if (isLocalVideoTrack(track)) {\n          if (isSVCCodec(videoCodec)) {\n            if (track.source === Track.Source.ScreenShare) {\n              // vp9 svc with screenshare cannot encode multiple spatial layers\n              // doing so reduces publish resolution to minimal resolution\n              opts.scalabilityMode = 'L1T3';\n              // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\n              // It has a different path for screenshare handling and it seems to be untested/buggy\n              // As a workaround, we are setting contentHint to force it to go through the same\n              // path as regular camera video. While this is not optimal, it delivers the performance\n              // that we need\n              if ('contentHint' in track.mediaStreamTrack) {\n                track.mediaStreamTrack.contentHint = 'motion';\n                this.log.info('forcing contentHint to motion for screenshare with SVC codecs', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n              }\n            }\n            // set scalabilityMode to 'L3T3_KEY' by default\n            opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';\n          }\n          req.simulcastCodecs = [new SimulcastCodec({\n            codec: videoCodec,\n            cid: track.mediaStreamTrack.id\n          })];\n          // set up backup\n          if (opts.backupCodec === true) {\n            opts.backupCodec = {\n              codec: defaultVideoCodec\n            };\n          }\n          if (opts.backupCodec && videoCodec !== opts.backupCodec.codec &&\n          // TODO remove this once e2ee is supported for backup codecs\n          req.encryption === Encryption_Type.NONE) {\n            // multi-codec simulcast requires dynacast\n            if (!this.roomOptions.dynacast) {\n              this.roomOptions.dynacast = true;\n            }\n            req.simulcastCodecs.push(new SimulcastCodec({\n              codec: opts.backupCodec.codec,\n              cid: ''\n            }));\n          }\n        }\n        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n        req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n      } else if (track.kind === Track.Kind.Audio) {\n        encodings = [{\n          maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\n          priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : 'high',\n          networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : 'high'\n        }];\n      }\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\n      }\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        if (!this.engine.pcManager) {\n          throw new UnexpectedConnectionState('pcManager is not ready');\n        }\n        track.sender = yield this.engine.createSender(track, opts, encodings);\n        if (isLocalVideoTrack(track)) {\n          (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\n          track.setDegradationPreference(opts.degradationPreference);\n        }\n        if (encodings) {\n          if (isFireFox() && track.kind === Track.Kind.Audio) {\n            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n               publish high quality audio track. But firefox always uses this value as the actual\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n               fix the issue.\n             */\n            let trackTransceiver = undefined;\n            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\n              if (transceiver.sender === track.sender) {\n                trackTransceiver = transceiver;\n                break;\n              }\n            }\n            if (trackTransceiver) {\n              this.engine.pcManager.publisher.setTrackCodecBitrate({\n                transceiver: trackTransceiver,\n                codec: 'opus',\n                maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n              });\n            }\n          } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\n            this.engine.pcManager.publisher.setTrackCodecBitrate({\n              cid: req.cid,\n              codec: track.codec,\n              maxbr: encodings[0].maxBitrate / 1000\n            });\n          }\n        }\n        yield this.engine.negotiate();\n      });\n      let ti;\n      if (this.enabledPublishVideoCodecs.length > 0) {\n        const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);\n        ti = rets[0];\n      } else {\n        ti = yield this.engine.addTrack(req);\n        // server might not support the codec the client has requested, in that case, fallback\n        // to a supported codec\n        let primaryCodecMime;\n        ti.codecs.forEach(codec => {\n          if (primaryCodecMime === undefined) {\n            primaryCodecMime = codec.mimeType;\n          }\n        });\n        if (primaryCodecMime && track.kind === Track.Kind.Video) {\n          const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n          if (updatedCodec !== videoCodec) {\n            this.log.debug('falling back to server selected codec', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n              codec: updatedCodec\n            }));\n            opts.videoCodec = updatedCodec;\n            // recompute encodings since bitrates/etc could have changed\n            encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n          }\n        }\n        yield negotiate();\n      }\n      const publication = new LocalTrackPublication(track.kind, ti, track, {\n        loggerName: this.roomOptions.loggerName,\n        loggerContextCb: () => this.logContext\n      });\n      // save options for when it needs to be republished again\n      publication.options = opts;\n      track.sid = ti.sid;\n      this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n        encodings,\n        trackInfo: ti\n      }));\n      if (isLocalVideoTrack(track)) {\n        track.startMonitor(this.engine.client);\n      } else if (isLocalAudioTrack(track)) {\n        track.startMonitor();\n      }\n      this.addTrackPublication(publication);\n      // send event for publication\n      this.emit(ParticipantEvent.LocalTrackPublished, publication);\n      return publication;\n    });\n  }\n  get isLocal() {\n    return true;\n  }\n  /** @internal\n   * publish additional codec to existing track\n   */\n  publishAdditionalCodecForTrack(track, videoCodec, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      // TODO remove once e2ee is supported for backup tracks\n      if (this.encryptionType !== Encryption_Type.NONE) {\n        return;\n      }\n      // is it not published? if so skip\n      let existingPublication;\n      this.trackPublications.forEach(publication => {\n        if (!publication.track) {\n          return;\n        }\n        if (publication.track === track) {\n          existingPublication = publication;\n        }\n      });\n      if (!existingPublication) {\n        throw new TrackInvalidError('track is not published');\n      }\n      if (!isLocalVideoTrack(track)) {\n        throw new TrackInvalidError('track is not a video track');\n      }\n      const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n      const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n      if (!encodings) {\n        this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return;\n      }\n      const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n      if (!simulcastTrack) {\n        return;\n      }\n      const req = new AddTrackRequest({\n        cid: simulcastTrack.mediaStreamTrack.id,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        sid: track.sid,\n        simulcastCodecs: [{\n          codec: opts.videoCodec,\n          cid: simulcastTrack.mediaStreamTrack.id\n        }]\n      });\n      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\n      }\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\n        yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n        yield this.engine.negotiate();\n      });\n      const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);\n      const ti = rets[0];\n      this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n        encodings,\n        trackInfo: ti\n      }));\n    });\n  }\n  unpublishTrack(track, stopOnUnpublish) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (isLocalTrack(track)) {\n        const publishPromise = this.pendingPublishPromises.get(track);\n        if (publishPromise) {\n          this.log.info('awaiting publish promise before attempting to unpublish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n          yield publishPromise;\n        }\n      }\n      // look through all published tracks to find the right ones\n      const publication = this.getPublicationForTrack(track);\n      const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n      this.log.debug('unpublishing track', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n      if (!publication || !publication.track) {\n        this.log.warn('track was not unpublished because no publication was found', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n        return undefined;\n      }\n      track = publication.track;\n      track.off(TrackEvent.Muted, this.onTrackMuted);\n      track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.off(TrackEvent.Ended, this.handleTrackEnded);\n      track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n      if (stopOnUnpublish === undefined) {\n        stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n      }\n      if (stopOnUnpublish) {\n        track.stop();\n      } else {\n        track.stopMonitor();\n      }\n      let negotiationNeeded = false;\n      const trackSender = track.sender;\n      track.sender = undefined;\n      if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n        try {\n          for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\n            // if sender is not currently sending (after replaceTrack(null))\n            // removeTrack would have no effect.\n            // to ensure we end up successfully removing the track, manually set\n            // the transceiver to inactive\n            if (transceiver.sender === trackSender) {\n              transceiver.direction = 'inactive';\n              negotiationNeeded = true;\n            }\n          }\n          if (this.engine.removeTrack(trackSender)) {\n            negotiationNeeded = true;\n          }\n          if (isLocalVideoTrack(track)) {\n            for (const [, trackInfo] of track.simulcastCodecs) {\n              if (trackInfo.sender) {\n                if (this.engine.removeTrack(trackInfo.sender)) {\n                  negotiationNeeded = true;\n                }\n                trackInfo.sender = undefined;\n              }\n            }\n            track.simulcastCodecs.clear();\n          }\n        } catch (e) {\n          this.log.warn('failed to unpublish track', Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n            error: e\n          }));\n        }\n      }\n      // remove from our maps\n      this.trackPublications.delete(publication.trackSid);\n      switch (publication.kind) {\n        case Track.Kind.Audio:\n          this.audioTrackPublications.delete(publication.trackSid);\n          break;\n        case Track.Kind.Video:\n          this.videoTrackPublications.delete(publication.trackSid);\n          break;\n      }\n      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n      publication.setTrack(undefined);\n      if (negotiationNeeded) {\n        yield this.engine.negotiate();\n      }\n      return publication;\n    });\n  }\n  unpublishTracks(tracks) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const results = yield Promise.all(tracks.map(track => this.unpublishTrack(track)));\n      return results.filter(track => !!track);\n    });\n  }\n  republishAllTracks(options_1) {\n    return __awaiter(this, arguments, void 0, function (options) {\n      var _this3 = this;\n      let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        if (_this3.republishPromise) {\n          yield _this3.republishPromise;\n        }\n        _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {\n          try {\n            const localPubs = [];\n            this.trackPublications.forEach(pub => {\n              if (pub.track) {\n                if (options) {\n                  pub.options = Object.assign(Object.assign({}, pub.options), options);\n                }\n                localPubs.push(pub);\n              }\n            });\n            yield Promise.all(localPubs.map(pub => __awaiter(this, void 0, void 0, function* () {\n              const track = pub.track;\n              yield this.unpublishTrack(track, false);\n              if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\n                // generally we need to restart the track before publishing, often a full reconnect\n                // is necessary because computer had gone to sleep.\n                this.log.debug('restarting existing track', Object.assign(Object.assign({}, this.logContext), {\n                  track: pub.trackSid\n                }));\n                yield track.restartTrack();\n              }\n              yield this.publishOrRepublishTrack(track, pub.options, true);\n            })));\n            resolve();\n          } catch (error) {\n            reject(error);\n          } finally {\n            this.republishPromise = undefined;\n          }\n        }));\n        yield _this3.republishPromise;\n      }();\n    });\n  }\n  /**\n   * Publish a new data payload to the room. Data will be forwarded to each\n   * participant in the room if the destination field in publishOptions is empty\n   *\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\n   * @param options optionally specify a `reliable`, `topic` and `destination`\n   */\n  publishData(data_1) {\n    return __awaiter(this, arguments, void 0, function (data) {\n      var _this4 = this;\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return function* () {\n        const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\n        const destinationIdentities = options.destinationIdentities;\n        const topic = options.topic;\n        const packet = new DataPacket({\n          kind: kind,\n          value: {\n            case: 'user',\n            value: new UserPacket({\n              participantIdentity: _this4.identity,\n              payload: data,\n              destinationIdentities,\n              topic\n            })\n          }\n        });\n        yield _this4.engine.sendDataPacket(packet, kind);\n      }();\n    });\n  }\n  /**\n   * Publish SIP DTMF message to the room.\n   *\n   * @param code DTMF code\n   * @param digit DTMF digit\n   */\n  publishDtmf(code, digit) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'sipDtmf',\n          value: new SipDTMF({\n            code: code,\n            digit: digit\n          })\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  sendChatMessage(text, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = {\n        id: crypto.randomUUID(),\n        message: text,\n        timestamp: Date.now(),\n        attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\n      };\n      const packet = new DataPacket({\n        value: {\n          case: 'chatMessage',\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n            timestamp: protoInt64.parse(msg.timestamp)\n          }))\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      this.emit(ParticipantEvent.ChatMessage, msg);\n      return msg;\n    });\n  }\n  editChatMessage(editText, originalMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = Object.assign(Object.assign({}, originalMessage), {\n        message: editText,\n        editTimestamp: Date.now()\n      });\n      const packet = new DataPacket({\n        value: {\n          case: 'chatMessage',\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n            timestamp: protoInt64.parse(msg.timestamp),\n            editTimestamp: protoInt64.parse(msg.editTimestamp)\n          }))\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      this.emit(ParticipantEvent.ChatMessage, msg);\n      return msg;\n    });\n  }\n  sendText(text, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const streamId = crypto.randomUUID();\n      const textInBytes = new TextEncoder().encode(text);\n      const totalTextLength = textInBytes.byteLength;\n      const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(() => crypto.randomUUID());\n      const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\n      const handleProgress = (progress, idx) => {\n        var _a;\n        progresses[idx] = progress;\n        const totalProgress = progresses.reduce((acc, val) => acc + val, 0);\n        (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\n      };\n      const writer = yield this.streamText({\n        streamId,\n        totalSize: totalTextLength,\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\n        topic: options === null || options === void 0 ? void 0 : options.topic,\n        attachedStreamIds: fileIds,\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\n      });\n      yield writer.write(text);\n      // set text part of progress to 1\n      handleProgress(1, 0);\n      yield writer.close();\n      if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\n        yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {\n          return this._sendFile(fileIds[idx], file, {\n            topic: options.topic,\n            mimeType: file.type,\n            onProgress: progress => {\n              handleProgress(progress, idx + 1);\n            }\n          });\n        })));\n      }\n      return writer.info;\n    });\n  }\n  /**\n   * @internal\n   * @experimental CAUTION, might get removed in a minor release\n   */\n  streamText(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n      const info = {\n        id: streamId,\n        mimeType: 'text/plain',\n        timestamp: Date.now(),\n        topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : '',\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\n      };\n      const header = new DataStream_Header({\n        streamId,\n        mimeType: info.mimeType,\n        topic: info.topic,\n        timestamp: numberToBigInt(info.timestamp),\n        totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\n        attributes: info.attributes,\n        contentHeader: {\n          case: 'textHeader',\n          value: new DataStream_TextHeader({\n            version: options === null || options === void 0 ? void 0 : options.version,\n            attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\n            replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\n            operationType: (options === null || options === void 0 ? void 0 : options.type) === 'update' ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\n          })\n        }\n      });\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n      const packet = new DataPacket({\n        destinationIdentities,\n        value: {\n          case: 'streamHeader',\n          value: header\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      let chunkId = 0;\n      const localP = this;\n      const writableStream = new WritableStream({\n        // Implement the sink\n        write(text) {\n          return __awaiter(this, void 0, void 0, function* () {\n            for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {\n              yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\n              const chunk = new DataStream_Chunk({\n                content: textByteChunk,\n                streamId,\n                chunkIndex: numberToBigInt(chunkId)\n              });\n              const chunkPacket = new DataPacket({\n                destinationIdentities,\n                value: {\n                  case: 'streamChunk',\n                  value: chunk\n                }\n              });\n              yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n              chunkId += 1;\n            }\n          });\n        },\n        close() {\n          return __awaiter(this, void 0, void 0, function* () {\n            const trailer = new DataStream_Trailer({\n              streamId\n            });\n            const trailerPacket = new DataPacket({\n              destinationIdentities,\n              value: {\n                case: 'streamTrailer',\n                value: trailer\n              }\n            });\n            yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n          });\n        },\n        abort(err) {\n          console.log('Sink error:', err);\n          // TODO handle aborts to signal something to receiver side\n        }\n      });\n      let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {\n        yield writer.close();\n      });\n      localP.engine.once(EngineEvent.Closing, onEngineClose);\n      const writer = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));\n      return writer;\n    });\n  }\n  sendFile(file, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const streamId = crypto.randomUUID();\n      yield this._sendFile(streamId, file, options);\n      return {\n        id: streamId\n      };\n    });\n  }\n  _sendFile(streamId, file, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const writer = yield this.streamBytes({\n        streamId,\n        totalSize: file.size,\n        name: file.name,\n        mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\n        topic: options === null || options === void 0 ? void 0 : options.topic,\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\n      });\n      const reader = file.stream().getReader();\n      while (true) {\n        const {\n          done,\n          value\n        } = yield reader.read();\n        if (done) {\n          break;\n        }\n        yield writer.write(value);\n      }\n      yield writer.close();\n      return writer.info;\n    });\n  }\n  streamBytes(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e;\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n      const info = {\n        id: streamId,\n        mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : 'application/octet-stream',\n        topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : '',\n        timestamp: Date.now(),\n        attributes: options === null || options === void 0 ? void 0 : options.attributes,\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\n        name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : 'unknown'\n      };\n      const header = new DataStream_Header({\n        totalLength: numberToBigInt((_e = info.size) !== null && _e !== void 0 ? _e : 0),\n        mimeType: info.mimeType,\n        streamId,\n        topic: info.topic,\n        timestamp: numberToBigInt(Date.now()),\n        contentHeader: {\n          case: 'byteHeader',\n          value: new DataStream_ByteHeader({\n            name: info.name\n          })\n        }\n      });\n      const packet = new DataPacket({\n        destinationIdentities,\n        value: {\n          case: 'streamHeader',\n          value: header\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      let chunkId = 0;\n      const writeMutex = new _();\n      const engine = this.engine;\n      const log = this.log;\n      const writableStream = new WritableStream({\n        write(chunk) {\n          return __awaiter(this, void 0, void 0, function* () {\n            const unlock = yield writeMutex.lock();\n            let byteOffset = 0;\n            try {\n              while (byteOffset < chunk.byteLength) {\n                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\n                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\n                const chunkPacket = new DataPacket({\n                  destinationIdentities,\n                  value: {\n                    case: 'streamChunk',\n                    value: new DataStream_Chunk({\n                      content: subChunk,\n                      streamId,\n                      chunkIndex: numberToBigInt(chunkId)\n                    })\n                  }\n                });\n                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                chunkId += 1;\n                byteOffset += subChunk.byteLength;\n              }\n            } finally {\n              unlock();\n            }\n          });\n        },\n        close() {\n          return __awaiter(this, void 0, void 0, function* () {\n            const trailer = new DataStream_Trailer({\n              streamId\n            });\n            const trailerPacket = new DataPacket({\n              destinationIdentities,\n              value: {\n                case: 'streamTrailer',\n                value: trailer\n              }\n            });\n            yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n          });\n        },\n        abort(err) {\n          log.error('Sink error:', err);\n        }\n      });\n      const byteWriter = new ByteStreamWriter(writableStream, info);\n      return byteWriter;\n    });\n  }\n  /**\n   * Initiate an RPC call to a remote participant\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\n   * @returns A promise that resolves with the response payload or rejects with an error.\n   * @throws Error on failure. Details in `message`.\n   */\n  performRpc(_a) {\n    return __awaiter(this, arguments, void 0, function (_ref3) {\n      var _this5 = this;\n      let {\n        destinationIdentity,\n        method,\n        payload,\n        responseTimeout = 10000\n      } = _ref3;\n      return function* () {\n        const maxRoundTripLatency = 2000;\n        return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {\n          var _a, _b, _c, _d;\n          if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\n            reject(RpcError.builtIn('REQUEST_PAYLOAD_TOO_LARGE'));\n            return;\n          }\n          if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, '1.8.0') < 0) {\n            reject(RpcError.builtIn('UNSUPPORTED_SERVER'));\n            return;\n          }\n          const id = crypto.randomUUID();\n          yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);\n          const ackTimeoutId = setTimeout(() => {\n            this.pendingAcks.delete(id);\n            reject(RpcError.builtIn('CONNECTION_TIMEOUT'));\n            this.pendingResponses.delete(id);\n            clearTimeout(responseTimeoutId);\n          }, maxRoundTripLatency);\n          this.pendingAcks.set(id, {\n            resolve: () => {\n              clearTimeout(ackTimeoutId);\n            },\n            participantIdentity: destinationIdentity\n          });\n          const responseTimeoutId = setTimeout(() => {\n            this.pendingResponses.delete(id);\n            reject(RpcError.builtIn('RESPONSE_TIMEOUT'));\n          }, responseTimeout);\n          this.pendingResponses.set(id, {\n            resolve: (responsePayload, responseError) => {\n              clearTimeout(responseTimeoutId);\n              if (this.pendingAcks.has(id)) {\n                console.warn('RPC response received before ack', id);\n                this.pendingAcks.delete(id);\n                clearTimeout(ackTimeoutId);\n              }\n              if (responseError) {\n                reject(responseError);\n              } else {\n                resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : '');\n              }\n            },\n            participantIdentity: destinationIdentity\n          });\n        }));\n      }();\n    });\n  }\n  /**\n   * @deprecated use `room.registerRpcMethod` instead\n   */\n  registerRpcMethod(method, handler) {\n    if (this.rpcHandlers.has(method)) {\n      this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\n    }\n    this.rpcHandlers.set(method, handler);\n  }\n  /**\n   * @deprecated use `room.unregisterRpcMethod` instead\n   */\n  unregisterRpcMethod(method) {\n    this.rpcHandlers.delete(method);\n  }\n  /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */\n  setTrackSubscriptionPermissions(allParticipantsAllowed) {\n    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.participantTrackPermissions = participantTrackPermissions;\n    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n    if (!this.engine.client.isDisconnected) {\n      this.updateTrackSubscriptionPermissions();\n    }\n  }\n  handleIncomingRpcAck(requestId) {\n    const handler = this.pendingAcks.get(requestId);\n    if (handler) {\n      handler.resolve();\n      this.pendingAcks.delete(requestId);\n    } else {\n      console.error('Ack received for unexpected RPC request', requestId);\n    }\n  }\n  handleIncomingRpcResponse(requestId, payload, error) {\n    const handler = this.pendingResponses.get(requestId);\n    if (handler) {\n      handler.resolve(payload, error);\n      this.pendingResponses.delete(requestId);\n    } else {\n      console.error('Response received for unexpected RPC request', requestId);\n    }\n  }\n  /** @internal */\n  publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        destinationIdentities: [destinationIdentity],\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'rpcRequest',\n          value: new RpcRequest({\n            id: requestId,\n            method,\n            payload,\n            responseTimeoutMs: responseTimeout,\n            version: 1\n          })\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /** @internal */\n  handleParticipantDisconnected(participantIdentity) {\n    for (const [id, {\n      participantIdentity: pendingIdentity\n    }] of this.pendingAcks) {\n      if (pendingIdentity === participantIdentity) {\n        this.pendingAcks.delete(id);\n      }\n    }\n    for (const [id, {\n      participantIdentity: pendingIdentity,\n      resolve\n    }] of this.pendingResponses) {\n      if (pendingIdentity === participantIdentity) {\n        resolve(null, RpcError.builtIn('RECIPIENT_DISCONNECTED'));\n        this.pendingResponses.delete(id);\n      }\n    }\n  }\n  /** @internal */\n  setEnabledPublishCodecs(codecs) {\n    this.enabledPublishVideoCodecs = codecs.filter(c => c.mime.split('/')[0].toLowerCase() === 'video');\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (info.sid !== this.sid) {\n      // drop updates that specify a wrong sid.\n      // the sid for local participant is only explicitly set on join and full reconnect\n      return false;\n    }\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    // reconcile track mute status.\n    // if server's track mute status doesn't match actual, we'll have to update\n    // the server's copy\n    info.tracks.forEach(ti => {\n      var _a, _b;\n      const pub = this.trackPublications.get(ti.sid);\n      if (pub) {\n        const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n        if (mutedOnServer !== ti.muted) {\n          this.log.debug('updating server mute state after reconcile', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n            mutedOnServer\n          }));\n          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n        }\n      }\n    });\n    return true;\n  }\n  getPublicationForTrack(track) {\n    let publication;\n    this.trackPublications.forEach(pub => {\n      const localTrack = pub.track;\n      if (!localTrack) {\n        return;\n      }\n      // this looks overly complicated due to this object tree\n      if (track instanceof MediaStreamTrack) {\n        if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\n          if (localTrack.mediaStreamTrack === track) {\n            publication = pub;\n          }\n        }\n      } else if (track === localTrack) {\n        publication = pub;\n      }\n    });\n    return publication;\n  }\n  waitForPendingPublicationOfSource(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const waitForPendingTimeout = 10000;\n      const startTime = Date.now();\n      while (Date.now() < startTime + waitForPendingTimeout) {\n        const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find(_ref4 => {\n          let [pendingTrack] = _ref4;\n          return pendingTrack.source === source;\n        });\n        if (publishPromiseEntry) {\n          return publishPromiseEntry[1];\n        }\n        yield sleep(20);\n      }\n    });\n  }\n}\n\nclass RemoteTrackPublication extends TrackPublication {\n  constructor(kind, ti, autoSubscribe, loggerOptions) {\n    super(kind, ti.sid, ti.name, loggerOptions);\n    this.track = undefined;\n    /** @internal */\n    this.allowed = true;\n    this.disabled = false;\n    this.currentVideoQuality = VideoQuality.HIGH;\n    this.handleEnded = track => {\n      this.setTrack(undefined);\n      this.emit(TrackEvent.Ended, track);\n    };\n    this.handleVisibilityChange = visible => {\n      this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n      this.disabled = !visible;\n      this.emitTrackUpdate();\n    };\n    this.handleVideoDimensionsChange = dimensions => {\n      this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n      this.videoDimensions = dimensions;\n      this.emitTrackUpdate();\n    };\n    this.subscribed = autoSubscribe;\n    this.updateInfo(ti);\n  }\n  /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */\n  setSubscribed(subscribed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.subscribed = subscribed;\n    // reset allowed status when desired subscription state changes\n    // server will notify client via signal message if it's not allowed\n    if (subscribed) {\n      this.allowed = true;\n    }\n    const sub = new UpdateSubscription({\n      trackSids: [this.trackSid],\n      subscribe: this.subscribed,\n      participantTracks: [new ParticipantTracks({\n        // sending an empty participant id since TrackPublication doesn't keep it\n        // this is filled in by the participant that receives this message\n        participantSid: '',\n        trackSids: [this.trackSid]\n      })]\n    });\n    this.emit(TrackEvent.UpdateSubscription, sub);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n    this.emitPermissionUpdateIfChanged(prevPermission);\n  }\n  get subscriptionStatus() {\n    if (this.subscribed === false) {\n      return TrackPublication.SubscriptionStatus.Unsubscribed;\n    }\n    if (!super.isSubscribed) {\n      return TrackPublication.SubscriptionStatus.Desired;\n    }\n    return TrackPublication.SubscriptionStatus.Subscribed;\n  }\n  get permissionStatus() {\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n  }\n  /**\n   * Returns true if track is subscribed, and ready for playback\n   */\n  get isSubscribed() {\n    if (this.subscribed === false) {\n      return false;\n    }\n    return super.isSubscribed;\n  }\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n  get isDesired() {\n    return this.subscribed !== false;\n  }\n  get isEnabled() {\n    return !this.disabled;\n  }\n  get isLocal() {\n    return false;\n  }\n  /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */\n  setEnabled(enabled) {\n    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n      return;\n    }\n    this.disabled = !enabled;\n    this.emitTrackUpdate();\n  }\n  /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */\n  setVideoQuality(quality) {\n    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n      return;\n    }\n    this.currentVideoQuality = quality;\n    this.videoDimensions = undefined;\n    this.emitTrackUpdate();\n  }\n  setVideoDimensions(dimensions) {\n    var _a, _b;\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n      return;\n    }\n    if (isRemoteVideoTrack(this.track)) {\n      this.videoDimensions = dimensions;\n    }\n    this.currentVideoQuality = undefined;\n    this.emitTrackUpdate();\n  }\n  setVideoFPS(fps) {\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (!isRemoteVideoTrack(this.track)) {\n      return;\n    }\n    if (this.fps === fps) {\n      return;\n    }\n    this.fps = fps;\n    this.emitTrackUpdate();\n  }\n  get videoQuality() {\n    return this.currentVideoQuality;\n  }\n  /** @internal */\n  setTrack(track) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    const prevTrack = this.track;\n    if (prevTrack === track) {\n      return;\n    }\n    if (prevTrack) {\n      // unregister listener\n      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      prevTrack.off(TrackEvent.Ended, this.handleEnded);\n      prevTrack.detach();\n      prevTrack.stopMonitor();\n      this.emit(TrackEvent.Unsubscribed, prevTrack);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.sid = this.trackSid;\n      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      track.on(TrackEvent.Ended, this.handleEnded);\n      this.emit(TrackEvent.Subscribed, track);\n    }\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  setAllowed(allowed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.allowed = allowed;\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  setSubscriptionError(error) {\n    this.emit(TrackEvent.SubscriptionFailed, error);\n  }\n  /** @internal */\n  updateInfo(info) {\n    super.updateInfo(info);\n    const prevMetadataMuted = this.metadataMuted;\n    this.metadataMuted = info.muted;\n    if (this.track) {\n      this.track.setMuted(info.muted);\n    } else if (prevMetadataMuted !== info.muted) {\n      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n    }\n  }\n  emitSubscriptionUpdateIfChanged(previousStatus) {\n    const currentStatus = this.subscriptionStatus;\n    if (previousStatus === currentStatus) {\n      return;\n    }\n    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n  }\n  emitPermissionUpdateIfChanged(previousPermissionStatus) {\n    const currentPermissionStatus = this.permissionStatus;\n    if (currentPermissionStatus !== previousPermissionStatus) {\n      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n    }\n  }\n  isManualOperationAllowed() {\n    if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n      this.log.warn('adaptive stream is enabled, cannot change video track settings', this.logContext);\n      return false;\n    }\n    if (!this.isDesired) {\n      this.log.warn('cannot update track settings when not subscribed', this.logContext);\n      return false;\n    }\n    return true;\n  }\n  get isAdaptiveStream() {\n    return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\n  }\n  /* @internal */\n  emitTrackUpdate() {\n    const settings = new UpdateTrackSettings({\n      trackSids: [this.trackSid],\n      disabled: this.disabled,\n      fps: this.fps\n    });\n    if (this.videoDimensions) {\n      settings.width = Math.ceil(this.videoDimensions.width);\n      settings.height = Math.ceil(this.videoDimensions.height);\n    } else if (this.currentVideoQuality !== undefined) {\n      settings.quality = this.currentVideoQuality;\n    } else {\n      // defaults to high quality\n      settings.quality = VideoQuality.HIGH;\n    }\n    this.emit(TrackEvent.UpdateSettings, settings);\n  }\n}\n\nclass RemoteParticipant extends Participant {\n  /** @internal */\n  static fromParticipantInfo(signalClient, pi, loggerOptions) {\n    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\n  }\n  get logContext() {\n    return Object.assign(Object.assign({}, super.logContext), {\n      rpID: this.sid,\n      remoteParticipant: this.identity\n    });\n  }\n  /** @internal */\n  constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {\n    let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\n    super(sid, identity || '', name, metadata, attributes, loggerOptions, kind);\n    this.signalClient = signalClient;\n    this.trackPublications = new Map();\n    this.audioTrackPublications = new Map();\n    this.videoTrackPublications = new Map();\n    this.volumeMap = new Map();\n  }\n  addTrackPublication(publication) {\n    super.addTrackPublication(publication);\n    // register action events\n    publication.on(TrackEvent.UpdateSettings, settings => {\n      this.log.debug('send update settings', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n      this.signalClient.sendUpdateTrackSettings(settings);\n    });\n    publication.on(TrackEvent.UpdateSubscription, sub => {\n      sub.participantTracks.forEach(pt => {\n        pt.participantSid = this.sid;\n      });\n      this.signalClient.sendUpdateSubscription(sub);\n    });\n    publication.on(TrackEvent.SubscriptionPermissionChanged, status => {\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n    });\n    publication.on(TrackEvent.SubscriptionStatusChanged, status => {\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n    });\n    publication.on(TrackEvent.Subscribed, track => {\n      this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n    });\n    publication.on(TrackEvent.Unsubscribed, previousTrack => {\n      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n    });\n    publication.on(TrackEvent.SubscriptionFailed, error => {\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n    });\n  }\n  getTrackPublication(source) {\n    const track = super.getTrackPublication(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackPublicationByName(name) {\n    const track = super.getTrackPublicationByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */\n  setVolume(volume) {\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n    this.volumeMap.set(source, volume);\n    const audioPublication = this.getTrackPublication(source);\n    if (audioPublication && audioPublication.track) {\n      audioPublication.track.setVolume(volume);\n    }\n  }\n  /**\n   * gets the volume on the participant's microphone track\n   */\n  getVolume() {\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n    const audioPublication = this.getTrackPublication(source);\n    if (audioPublication && audioPublication.track) {\n      return audioPublication.track.getVolume();\n    }\n    return this.volumeMap.get(source);\n  }\n  /** @internal */\n  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n    // find the track publication\n    // it's possible for the media track to arrive before participant info\n    let publication = this.getTrackPublicationBySid(sid);\n    // it's also possible that the browser didn't honor our original track id\n    // FireFox would use its own local uuid instead of server track id\n    if (!publication) {\n      if (!sid.startsWith('TR')) {\n        // find the first track that matches type\n        this.trackPublications.forEach(p => {\n          if (!publication && mediaTrack.kind === p.kind.toString()) {\n            publication = p;\n          }\n        });\n      }\n    }\n    // when we couldn't locate the track, it's possible that the metadata hasn't\n    // yet arrived. Wait a bit longer for it to arrive, or fire an error\n    if (!publication) {\n      if (triesLeft === 0) {\n        this.log.error('could not find published track', Object.assign(Object.assign({}, this.logContext), {\n          trackSid: sid\n        }));\n        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n        return;\n      }\n      if (triesLeft === undefined) triesLeft = 20;\n      setTimeout(() => {\n        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n      }, 150);\n      return;\n    }\n    if (mediaTrack.readyState === 'ended') {\n      this.log.error('unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n      return;\n    }\n    const isVideo = mediaTrack.kind === 'video';\n    let track;\n    if (isVideo) {\n      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n    } else {\n      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n    }\n    // set track info\n    track.source = publication.source;\n    // keep publication's muted status\n    track.isMuted = publication.isMuted;\n    track.setMediaStream(mediaStream);\n    track.start();\n    publication.setTrack(track);\n    // set participant volumes on new audio tracks\n    if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\n      track.setVolume(this.volumeMap.get(publication.source));\n    }\n    return publication;\n  }\n  /** @internal */\n  get hasMetadata() {\n    return !!this.participantInfo;\n  }\n  /**\n   * @internal\n   */\n  getTrackPublicationBySid(sid) {\n    return this.trackPublications.get(sid);\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    // we are getting a list of all available tracks, reconcile in here\n    // and send out events for changes\n    // reconcile track publications, publish events only if metadata is already there\n    // i.e. changes since the local participant has joined\n    const validTracks = new Map();\n    const newTracks = new Map();\n    info.tracks.forEach(ti => {\n      var _a, _b;\n      let publication = this.getTrackPublicationBySid(ti.sid);\n      if (!publication) {\n        // new publication\n        const kind = Track.kindFromProto(ti.type);\n        if (!kind) {\n          return;\n        }\n        publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n          loggerContextCb: () => this.logContext,\n          loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n        });\n        publication.updateInfo(ti);\n        newTracks.set(ti.sid, publication);\n        const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n          this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n            oldTrack: getLogContextFromTrack(existingTrackOfSource),\n            newTrack: getLogContextFromTrack(publication)\n          }));\n        }\n        this.addTrackPublication(publication);\n      } else {\n        publication.updateInfo(ti);\n      }\n      validTracks.set(ti.sid, publication);\n    });\n    // detect removed tracks\n    this.trackPublications.forEach(publication => {\n      if (!validTracks.has(publication.trackSid)) {\n        this.log.trace('detected removed track on remote participant, unpublishing', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n        this.unpublishTrack(publication.trackSid, true);\n      }\n    });\n    // always emit events for new publications, Room will not forward them unless it's ready\n    newTracks.forEach(publication => {\n      this.emit(ParticipantEvent.TrackPublished, publication);\n    });\n    return true;\n  }\n  /** @internal */\n  unpublishTrack(sid, sendUnpublish) {\n    const publication = this.trackPublications.get(sid);\n    if (!publication) {\n      return;\n    }\n    // also send unsubscribe, if track is actively subscribed\n    const {\n      track\n    } = publication;\n    if (track) {\n      track.stop();\n      publication.setTrack(undefined);\n    }\n    // remove track from maps only after unsubscribed has been fired\n    this.trackPublications.delete(sid);\n    // remove from the right type map\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTrackPublications.delete(sid);\n        break;\n      case Track.Kind.Video:\n        this.videoTrackPublications.delete(sid);\n        break;\n    }\n    if (sendUnpublish) {\n      this.emit(ParticipantEvent.TrackUnpublished, publication);\n    }\n  }\n  /**\n   * @internal\n   */\n  setAudioOutput(output) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.audioOutput = output;\n      const promises = [];\n      this.audioTrackPublications.forEach(pub => {\n        var _a;\n        if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\n          promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default'));\n        }\n      });\n      yield Promise.all(promises);\n    });\n  }\n  /** @internal */\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    this.log.trace('participant event', Object.assign(Object.assign({}, this.logContext), {\n      event,\n      args\n    }));\n    return super.emit(event, ...args);\n  }\n}\n\nvar ConnectionState;\n(function (ConnectionState) {\n  ConnectionState[\"Disconnected\"] = \"disconnected\";\n  ConnectionState[\"Connecting\"] = \"connecting\";\n  ConnectionState[\"Connected\"] = \"connected\";\n  ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n  ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 4 * 1000;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */\nclass Room extends eventsExports.EventEmitter {\n  /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */\n  constructor(options) {\n    var _this;\n    var _a, _b, _c;\n    super();\n    _this = this;\n    this.state = ConnectionState.Disconnected;\n    /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */\n    this.activeSpeakers = [];\n    /** reflects the sender encryption status of the local participant */\n    this.isE2EEEnabled = false;\n    this.audioEnabled = true;\n    this.isVideoPlaybackBlocked = false;\n    this.log = livekitLogger;\n    this.bufferedEvents = [];\n    this.isResuming = false;\n    this.byteStreamControllers = new Map();\n    this.textStreamControllers = new Map();\n    this.byteStreamHandlers = new Map();\n    this.textStreamHandlers = new Map();\n    this.rpcHandlers = new Map();\n    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!isBrowserSupported()) {\n        if (isReactNative()) {\n          throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\n        } else {\n          throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\n        }\n      }\n      // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n      const unlockDisconnect = yield this.disconnectLock.lock();\n      if (this.state === ConnectionState.Connected) {\n        // when the state is reconnecting or connected, this function returns immediately\n        this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n        unlockDisconnect();\n        return Promise.resolve();\n      }\n      if (this.connectFuture) {\n        unlockDisconnect();\n        return this.connectFuture.promise;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connecting);\n      if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== url) {\n        this.regionUrl = undefined;\n        this.regionUrlProvider = undefined;\n      }\n      if (isCloud(new URL(url))) {\n        if (this.regionUrlProvider === undefined) {\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\n        } else {\n          this.regionUrlProvider.updateToken(token);\n        }\n        // trigger the first fetch without waiting for a response\n        // if initial connection fails, this will speed up picking regional url\n        // on subsequent runs\n        this.regionUrlProvider.fetchRegionSettings().then(settings => {\n          var _a;\n          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\n        }).catch(e => {\n          this.log.warn('could not fetch region settings', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n        });\n      }\n      const connectFn = (resolve, reject, regionUrl) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (this.abortController) {\n          this.abortController.abort();\n        }\n        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n        const abortController = new AbortController();\n        this.abortController = abortController;\n        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n        try {\n          yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n          this.abortController = undefined;\n          resolve();\n        } catch (e) {\n          if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== ConnectionErrorReason.Cancelled && e.reason !== ConnectionErrorReason.NotAllowed) {\n            let nextUrl = null;\n            try {\n              nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n            } catch (error) {\n              if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {\n                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                reject(error);\n                return;\n              }\n            }\n            if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\n              this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n              this.recreateEngine();\n              yield connectFn(resolve, reject, nextUrl);\n            } else {\n              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e));\n              reject(e);\n            }\n          } else {\n            let disconnectReason = DisconnectReason.UNKNOWN_REASON;\n            if (e instanceof ConnectionError) {\n              disconnectReason = getDisconnectReasonFromConnectionError(e);\n            }\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\n            reject(e);\n          }\n        }\n      });\n      const regionUrl = this.regionUrl;\n      this.regionUrl = undefined;\n      this.connectFuture = new Future((resolve, reject) => {\n        connectFn(resolve, reject, regionUrl);\n      }, () => {\n        this.clearConnectionFutures();\n      });\n      return this.connectFuture.promise;\n    });\n    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      const joinResponse = yield engine.join(url, token, {\n        autoSubscribe: connectOptions.autoSubscribe,\n        adaptiveStream: typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,\n        maxRetries: connectOptions.maxRetries,\n        e2eeEnabled: !!this.e2eeManager,\n        websocketTimeout: connectOptions.websocketTimeout\n      }, abortController.signal);\n      let serverInfo = joinResponse.serverInfo;\n      if (!serverInfo) {\n        serverInfo = {\n          version: joinResponse.serverVersion,\n          region: joinResponse.serverRegion\n        };\n      }\n      this.serverInfo = serverInfo;\n      this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map(_ref => {\n        let [key, value] = _ref;\n        return \"\".concat(key, \": \").concat(value);\n      }).join(', ')), {\n        room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\n        roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\n        identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\n      });\n      if (!serverInfo.version) {\n        throw new UnsupportedServer('unknown server version');\n      }\n      if (serverInfo.version === '0.15.1' && this.options.dynacast) {\n        this.log.debug('disabling dynacast due to server version', this.logContext);\n        // dynacast has a bug in 0.15.1, so we cannot use it then\n        roomOptions.dynacast = false;\n      }\n      return joinResponse;\n    });\n    this.applyJoinResponse = joinResponse => {\n      const pi = joinResponse.participant;\n      this.localParticipant.sid = pi.sid;\n      this.localParticipant.identity = pi.identity;\n      this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\n      if (this.options.e2ee && this.e2eeManager) {\n        try {\n          this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n        } catch (e) {\n          this.log.error(e instanceof Error ? e.message : 'Could not set SifTrailer', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n        }\n      }\n      // populate remote participants, these should not trigger new events\n      this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);\n      if (joinResponse.room) {\n        this.handleRoomUpdate(joinResponse.room);\n      }\n    };\n    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\n        this.log.info('Reconnection attempt replaced by new connection attempt', this.logContext);\n        // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n        this.recreateEngine();\n      } else {\n        // create engine if previously disconnected\n        this.maybeCreateEngine();\n      }\n      if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\n        this.engine.setRegionUrlProvider(this.regionUrlProvider);\n      }\n      this.acquireAudioContext();\n      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n      if (this.connOptions.rtcConfig) {\n        this.engine.rtcConfig = this.connOptions.rtcConfig;\n      }\n      if (this.connOptions.peerConnectionTimeout) {\n        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n      }\n      try {\n        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n        this.applyJoinResponse(joinResponse);\n        // forward metadata changed for the local participant\n        this.setupLocalParticipantEvents();\n        this.emit(RoomEvent.SignalConnected);\n      } catch (err) {\n        yield this.engine.close();\n        this.recreateEngine();\n        const resultingError = new ConnectionError(\"could not establish signal connection\", ConnectionErrorReason.ServerUnreachable);\n        if (err instanceof Error) {\n          resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n        }\n        if (err instanceof ConnectionError) {\n          resultingError.reason = err.reason;\n          resultingError.status = err.status;\n        }\n        this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n          error: err\n        }));\n        throw resultingError;\n      }\n      if (abortController.signal.aborted) {\n        yield this.engine.close();\n        this.recreateEngine();\n        throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\n      }\n      try {\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n      } catch (e) {\n        yield this.engine.close();\n        this.recreateEngine();\n        throw e;\n      }\n      // also hook unload event\n      if (isWeb() && this.options.disconnectOnPageLeave) {\n        // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n        window.addEventListener('pagehide', this.onPageLeave);\n        window.addEventListener('beforeunload', this.onPageLeave);\n      }\n      if (isWeb()) {\n        document.addEventListener('freeze', this.onPageLeave);\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Connected);\n      this.registerConnectionReconcile();\n    });\n    /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */\n    this.disconnect = function () {\n      for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {\n        args_1[_key] = arguments[_key];\n      }\n      return __awaiter(_this, [...args_1], void 0, function () {\n        var _this2 = this;\n        let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        return function* () {\n          var _a, _b, _c, _d;\n          const unlock = yield _this2.disconnectLock.lock();\n          try {\n            if (_this2.state === ConnectionState.Disconnected) {\n              _this2.log.debug('already disconnected', _this2.logContext);\n              return;\n            }\n            _this2.log.info('disconnect from room', Object.assign({}, _this2.logContext));\n            if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\n              // try aborting pending connection attempt\n              _this2.log.warn('abort connection attempt', _this2.logContext);\n              (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n              // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n              (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError('Client initiated disconnect', ConnectionErrorReason.Cancelled));\n              _this2.connectFuture = undefined;\n            }\n            // send leave\n            if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {\n              yield _this2.engine.client.sendLeave();\n            }\n            // close engine (also closes client)\n            if (_this2.engine) {\n              yield _this2.engine.close();\n            }\n            _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n            /* @ts-ignore */\n            _this2.engine = undefined;\n          } finally {\n            unlock();\n          }\n        }();\n      });\n    };\n    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\n      this.log.info('Page leave detected, disconnecting', this.logContext);\n      yield this.disconnect();\n    });\n    /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */\n    this.startAudio = () => __awaiter(this, void 0, void 0, function* () {\n      const elements = [];\n      const browser = getBrowser();\n      if (browser && browser.os === 'iOS') {\n        /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */\n        const audioId = 'livekit-dummy-audio-el';\n        let dummyAudioEl = document.getElementById(audioId);\n        if (!dummyAudioEl) {\n          dummyAudioEl = document.createElement('audio');\n          dummyAudioEl.id = audioId;\n          dummyAudioEl.autoplay = true;\n          dummyAudioEl.hidden = true;\n          const track = getEmptyAudioStreamTrack();\n          track.enabled = true;\n          const stream = new MediaStream([track]);\n          dummyAudioEl.srcObject = stream;\n          document.addEventListener('visibilitychange', () => {\n            if (!dummyAudioEl) {\n              return;\n            }\n            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n            dummyAudioEl.srcObject = document.hidden ? null : stream;\n            if (!document.hidden) {\n              this.log.debug('page visible again, triggering startAudio to resume playback and update playback status', this.logContext);\n              this.startAudio();\n            }\n          });\n          document.body.append(dummyAudioEl);\n          this.once(RoomEvent.Disconnected, () => {\n            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n            dummyAudioEl = null;\n          });\n        }\n        elements.push(dummyAudioEl);\n      }\n      this.remoteParticipants.forEach(p => {\n        p.audioTrackPublications.forEach(t => {\n          if (t.track) {\n            t.track.attachedElements.forEach(e => {\n              elements.push(e);\n            });\n          }\n        });\n      });\n      try {\n        yield Promise.all([this.acquireAudioContext(), ...elements.map(e => {\n          e.muted = false;\n          return e.play();\n        })]);\n        this.handleAudioPlaybackStarted();\n      } catch (err) {\n        this.handleAudioPlaybackFailed(err);\n        throw err;\n      }\n    });\n    this.startVideo = () => __awaiter(this, void 0, void 0, function* () {\n      const elements = [];\n      for (const p of this.remoteParticipants.values()) {\n        p.videoTrackPublications.forEach(tr => {\n          var _a;\n          (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach(el => {\n            if (!elements.includes(el)) {\n              elements.push(el);\n            }\n          });\n        });\n      }\n      yield Promise.all(elements.map(el => el.play())).then(() => {\n        this.handleVideoPlaybackStarted();\n      }).catch(e => {\n        if (e.name === 'NotAllowedError') {\n          this.handleVideoPlaybackFailed();\n        } else {\n          this.log.warn('Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler', this.logContext);\n        }\n      });\n    });\n    this.handleRestarting = () => {\n      this.clearConnectionReconcile();\n      // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\n      this.isResuming = false;\n      // also unwind existing participants & existing subscriptions\n      for (const p of this.remoteParticipants.values()) {\n        this.handleParticipantDisconnected(p.identity, p);\n      }\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n    };\n    this.handleSignalRestarted = joinResponse => __awaiter(this, void 0, void 0, function* () {\n      this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n        region: joinResponse.serverRegion\n      }));\n      this.bufferedEvents = [];\n      this.applyJoinResponse(joinResponse);\n      try {\n        // unpublish & republish tracks\n        yield this.localParticipant.republishAllTracks(undefined, true);\n      } catch (error) {\n        this.log.error('error trying to re-publish tracks after reconnection', Object.assign(Object.assign({}, this.logContext), {\n          error\n        }));\n      }\n      try {\n        yield this.engine.waitForRestarted();\n        this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n          region: joinResponse.serverRegion\n        }));\n      } catch (_a) {\n        // reconnection failed, handleDisconnect is being invoked already, just return here\n        return;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Reconnected);\n      this.registerConnectionReconcile();\n      this.emitBufferedEvents();\n    });\n    this.handleParticipantUpdates = participantInfos => {\n      // handle changes to participant state, and send events\n      participantInfos.forEach(info => {\n        var _a;\n        if (info.identity === this.localParticipant.identity) {\n          this.localParticipant.updateInfo(info);\n          return;\n        }\n        // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\n        // so we try to map an empty identity to an already known sID manually\n        if (info.identity === '') {\n          info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : '';\n        }\n        let remoteParticipant = this.remoteParticipants.get(info.identity);\n        // when it's disconnected, send updates\n        if (info.state === ParticipantInfo_State.DISCONNECTED) {\n          this.handleParticipantDisconnected(info.identity, remoteParticipant);\n        } else {\n          // create participant if doesn't exist\n          remoteParticipant = this.getOrCreateParticipant(info.identity, info);\n        }\n      });\n    };\n    // updates are sent only when there's a change to speaker ordering\n    this.handleActiveSpeakersUpdate = speakers => {\n      const activeSpeakers = [];\n      const seenSids = {};\n      speakers.forEach(speaker => {\n        seenSids[speaker.sid] = true;\n        if (speaker.sid === this.localParticipant.sid) {\n          this.localParticipant.audioLevel = speaker.level;\n          this.localParticipant.setIsSpeaking(true);\n          activeSpeakers.push(this.localParticipant);\n        } else {\n          const p = this.getRemoteParticipantBySid(speaker.sid);\n          if (p) {\n            p.audioLevel = speaker.level;\n            p.setIsSpeaking(true);\n            activeSpeakers.push(p);\n          }\n        }\n      });\n      if (!seenSids[this.localParticipant.sid]) {\n        this.localParticipant.audioLevel = 0;\n        this.localParticipant.setIsSpeaking(false);\n      }\n      this.remoteParticipants.forEach(p => {\n        if (!seenSids[p.sid]) {\n          p.audioLevel = 0;\n          p.setIsSpeaking(false);\n        }\n      });\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    // process list of changed speakers\n    this.handleSpeakersChanged = speakerUpdates => {\n      const lastSpeakers = new Map();\n      this.activeSpeakers.forEach(p => {\n        const remoteParticipant = this.remoteParticipants.get(p.identity);\n        if (remoteParticipant && remoteParticipant.sid !== p.sid) {\n          return;\n        }\n        lastSpeakers.set(p.sid, p);\n      });\n      speakerUpdates.forEach(speaker => {\n        let p = this.getRemoteParticipantBySid(speaker.sid);\n        if (speaker.sid === this.localParticipant.sid) {\n          p = this.localParticipant;\n        }\n        if (!p) {\n          return;\n        }\n        p.audioLevel = speaker.level;\n        p.setIsSpeaking(speaker.active);\n        if (speaker.active) {\n          lastSpeakers.set(speaker.sid, p);\n        } else {\n          lastSpeakers.delete(speaker.sid);\n        }\n      });\n      const activeSpeakers = Array.from(lastSpeakers.values());\n      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    this.handleStreamStateUpdate = streamStateUpdate => {\n      streamStateUpdate.streamStates.forEach(streamState => {\n        const participant = this.getRemoteParticipantBySid(streamState.participantSid);\n        if (!participant) {\n          return;\n        }\n        const pub = participant.getTrackPublicationBySid(streamState.trackSid);\n        if (!pub || !pub.track) {\n          return;\n        }\n        const newStreamState = Track.streamStateFromProto(streamState.state);\n        if (newStreamState !== pub.track.streamState) {\n          pub.track.streamState = newStreamState;\n          participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n          this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n        }\n      });\n    };\n    this.handleSubscriptionPermissionUpdate = update => {\n      const participant = this.getRemoteParticipantBySid(update.participantSid);\n      if (!participant) {\n        return;\n      }\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\n      if (!pub) {\n        return;\n      }\n      pub.setAllowed(update.allowed);\n    };\n    this.handleSubscriptionError = update => {\n      const participant = Array.from(this.remoteParticipants.values()).find(p => p.trackPublications.has(update.trackSid));\n      if (!participant) {\n        return;\n      }\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\n      if (!pub) {\n        return;\n      }\n      pub.setSubscriptionError(update.err);\n    };\n    this.handleDataPacket = packet => {\n      // find the participant\n      const participant = this.remoteParticipants.get(packet.participantIdentity);\n      if (packet.value.case === 'user') {\n        this.handleUserPacket(participant, packet.value.value, packet.kind);\n      } else if (packet.value.case === 'transcription') {\n        this.handleTranscription(participant, packet.value.value);\n      } else if (packet.value.case === 'sipDtmf') {\n        this.handleSipDtmf(participant, packet.value.value);\n      } else if (packet.value.case === 'chatMessage') {\n        this.handleChatMessage(participant, packet.value.value);\n      } else if (packet.value.case === 'metrics') {\n        this.handleMetrics(packet.value.value, participant);\n      } else if (packet.value.case === 'streamHeader') {\n        this.handleStreamHeader(packet.value.value, packet.participantIdentity);\n      } else if (packet.value.case === 'streamChunk') {\n        this.handleStreamChunk(packet.value.value);\n      } else if (packet.value.case === 'streamTrailer') {\n        this.handleStreamTrailer(packet.value.value);\n      } else if (packet.value.case === 'rpcRequest') {\n        const rpc = packet.value.value;\n        this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\n      }\n    };\n    this.handleUserPacket = (participant, userPacket, kind) => {\n      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n      // also emit on the participant\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n    };\n    this.handleSipDtmf = (participant, dtmf) => {\n      this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\n      // also emit on the participant\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\n    };\n    this.bufferedSegments = new Map();\n    this.handleTranscription = (_remoteParticipant, transcription) => {\n      // find the participant\n      const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\n      const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\n      const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\n      publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\n      this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\n    };\n    this.handleChatMessage = (participant, chatMessage) => {\n      const msg = extractChatMessage(chatMessage);\n      this.emit(RoomEvent.ChatMessage, msg, participant);\n    };\n    this.handleMetrics = (metrics, participant) => {\n      this.emit(RoomEvent.MetricsReceived, metrics, participant);\n    };\n    this.handleAudioPlaybackStarted = () => {\n      if (this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = true;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n    };\n    this.handleAudioPlaybackFailed = e => {\n      this.log.warn('could not playback audio', Object.assign(Object.assign({}, this.logContext), {\n        error: e\n      }));\n      if (!this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = false;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n    };\n    this.handleVideoPlaybackStarted = () => {\n      if (this.isVideoPlaybackBlocked) {\n        this.isVideoPlaybackBlocked = false;\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n      }\n    };\n    this.handleVideoPlaybackFailed = () => {\n      if (!this.isVideoPlaybackBlocked) {\n        this.isVideoPlaybackBlocked = true;\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n      }\n    };\n    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const previousDevices = DeviceManager.getInstance().previousDevices;\n      // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\n      const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\n      const browser = getBrowser();\n      if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && browser.os !== 'iOS') {\n        for (let availableDevice of availableDevices) {\n          const previousDevice = previousDevices.find(info => info.deviceId === availableDevice.deviceId);\n          if (previousDevice && previousDevice.label !== '' && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\n            // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\n            if (this.getActiveDevice(availableDevice.kind) === 'default') {\n              // emit an active device change event only if the selected output device is actually on `default`\n              this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\n            }\n          }\n        }\n      }\n      // inputs are automatically handled via TrackEvent.Ended causing a TrackEvent.Restarted. Here we only need to worry about audiooutputs changing\n      const kinds = ['audiooutput', 'audioinput', 'videoinput'];\n      for (let kind of kinds) {\n        const devicesOfKind = availableDevices.filter(d => d.kind === kind);\n        const activeDevice = this.getActiveDevice(kind);\n        if (activeDevice === ((_a = previousDevices.filter(info => info.kind === kind)[0]) === null || _a === void 0 ? void 0 : _a.deviceId)) {\n          // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\n          // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\n          if (devicesOfKind.length > 0 && ((_b = devicesOfKind[0]) === null || _b === void 0 ? void 0 : _b.deviceId) !== activeDevice) {\n            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n            continue;\n          }\n        }\n        if (kind === 'audioinput' && !isSafari() || kind === 'videoinput') {\n          // airpods on Safari need special handling for audioinput as the track doesn't end as soon as you take them out\n          continue;\n        }\n        // switch to first available device if previously active device is not available any more\n        if (devicesOfKind.length > 0 && !devicesOfKind.find(deviceInfo => deviceInfo.deviceId === this.getActiveDevice(kind))) {\n          yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n        }\n      }\n      this.emit(RoomEvent.MediaDevicesChanged);\n    });\n    this.handleRoomUpdate = room => {\n      const oldRoom = this.roomInfo;\n      this.roomInfo = room;\n      if (oldRoom && oldRoom.metadata !== room.metadata) {\n        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n      }\n      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n      }\n    };\n    this.handleConnectionQualityUpdate = update => {\n      update.updates.forEach(info => {\n        if (info.participantSid === this.localParticipant.sid) {\n          this.localParticipant.setConnectionQuality(info.quality);\n          return;\n        }\n        const participant = this.getRemoteParticipantBySid(info.participantSid);\n        if (participant) {\n          participant.setConnectionQuality(info.quality);\n        }\n      });\n    };\n    this.onLocalParticipantMetadataChanged = metadata => {\n      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n    };\n    this.onLocalParticipantNameChanged = name => {\n      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n    };\n    this.onLocalAttributesChanged = changedAttributes => {\n      this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\n    };\n    this.onLocalTrackMuted = pub => {\n      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n    };\n    this.onLocalTrackUnmuted = pub => {\n      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n    };\n    this.onTrackProcessorUpdate = processor => {\n      var _a;\n      (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\n    };\n    this.onLocalTrackPublished = pub => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e, _f;\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\n      (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n      if (isLocalAudioTrack(pub.track)) {\n        const trackIsSilent = yield pub.track.checkForSilence();\n        if (trackIsSilent) {\n          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n        }\n      }\n      const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\n      const deviceKind = sourceToKind(pub.source);\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n      }\n    });\n    this.onLocalTrackUnpublished = pub => {\n      var _a, _b;\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\n      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n    };\n    this.onLocalTrackRestarted = track => __awaiter(this, void 0, void 0, function* () {\n      const deviceId = yield track.getDeviceId(false);\n      const deviceKind = sourceToKind(track.source);\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n        this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n      }\n    });\n    this.onLocalConnectionQualityChanged = quality => {\n      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n    };\n    this.onMediaDevicesError = e => {\n      this.emit(RoomEvent.MediaDevicesError, e);\n    };\n    this.onLocalParticipantPermissionsChanged = prevPermissions => {\n      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n    };\n    this.onLocalChatMessageSent = msg => {\n      this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\n    };\n    this.setMaxListeners(100);\n    this.remoteParticipants = new Map();\n    this.sidToIdentity = new Map();\n    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n    this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n    this.transcriptionReceivedTimes = new Map();\n    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n    this.maybeCreateEngine();\n    this.disconnectLock = new _();\n    this.localParticipant = new LocalParticipant('', '', this.engine, this.options, this.rpcHandlers);\n    if (this.options.videoCaptureDefaults.deviceId) {\n      this.localParticipant.activeDeviceMap.set('videoinput', unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n    }\n    if (this.options.audioCaptureDefaults.deviceId) {\n      this.localParticipant.activeDeviceMap.set('audioinput', unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n    }\n    if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n      this.switchActiveDevice('audiooutput', unwrapConstraint(this.options.audioOutput.deviceId)).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n    }\n    if (this.options.e2ee) {\n      this.setupE2EE();\n    }\n    if (isWeb()) {\n      const abortController = new AbortController();\n      // in order to catch device changes prior to room connection we need to register the event in the constructor\n      (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener('devicechange', this.handleDeviceChange, {\n        signal: abortController.signal\n      });\n      if (Room.cleanupRegistry) {\n        Room.cleanupRegistry.register(this, () => {\n          abortController.abort();\n        });\n      }\n    }\n  }\n  registerTextStreamHandler(topic, callback) {\n    if (this.textStreamHandlers.has(topic)) {\n      throw new TypeError(\"A text stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"));\n    }\n    this.textStreamHandlers.set(topic, callback);\n  }\n  unregisterTextStreamHandler(topic) {\n    this.textStreamHandlers.delete(topic);\n  }\n  registerByteStreamHandler(topic, callback) {\n    if (this.byteStreamHandlers.has(topic)) {\n      throw new TypeError(\"A byte stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"));\n    }\n    this.byteStreamHandlers.set(topic, callback);\n  }\n  unregisterByteStreamHandler(topic) {\n    this.byteStreamHandlers.delete(topic);\n  }\n  /**\n   * Establishes the participant as a receiver for calls of the specified RPC method.\n   *\n   * @param method - The name of the indicated RPC method\n   * @param handler - Will be invoked when an RPC request for this method is received\n   * @returns A promise that resolves when the method is successfully registered\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\n   *\n   * @example\n   * ```typescript\n   * room.localParticipant?.registerRpcMethod(\n   *   'greet',\n   *   async (data: RpcInvocationData) => {\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\n   *     return `Hello, ${data.callerIdentity}!`;\n   *   }\n   * );\n   * ```\n   *\n   * The handler should return a Promise that resolves to a string.\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\n   *\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\n   * and they will be received on the caller's side with the message intact.\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\n   */\n  registerRpcMethod(method, handler) {\n    if (this.rpcHandlers.has(method)) {\n      throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\n    }\n    this.rpcHandlers.set(method, handler);\n  }\n  /**\n   * Unregisters a previously registered RPC method.\n   *\n   * @param method - The name of the RPC method to unregister\n   */\n  unregisterRpcMethod(method) {\n    this.rpcHandlers.delete(method);\n  }\n  handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.engine.publishRpcAck(callerIdentity, requestId);\n      if (version !== 1) {\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_VERSION'));\n        return;\n      }\n      const handler = this.rpcHandlers.get(method);\n      if (!handler) {\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_METHOD'));\n        return;\n      }\n      let responseError = null;\n      let responsePayload = null;\n      try {\n        const response = yield handler({\n          requestId,\n          callerIdentity,\n          payload,\n          responseTimeout\n        });\n        if (byteLength(response) > MAX_PAYLOAD_BYTES) {\n          responseError = RpcError.builtIn('RESPONSE_PAYLOAD_TOO_LARGE');\n          console.warn(\"RPC Response payload too large for \".concat(method));\n        } else {\n          responsePayload = response;\n        }\n      } catch (error) {\n        if (error instanceof RpcError) {\n          responseError = error;\n        } else {\n          console.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\n          responseError = RpcError.builtIn('APPLICATION_ERROR');\n        }\n      }\n      yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\n    });\n  }\n  /**\n   * @experimental\n   */\n  setE2EEEnabled(enabled) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.e2eeManager) {\n        yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);\n        if (this.localParticipant.identity !== '') {\n          this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n        }\n      } else {\n        throw Error('e2ee not configured, please set e2ee settings within the room options');\n      }\n    });\n  }\n  setupE2EE() {\n    var _a;\n    if (this.options.e2ee) {\n      if ('e2eeManager' in this.options.e2ee) {\n        this.e2eeManager = this.options.e2ee.e2eeManager;\n      } else {\n        this.e2eeManager = new E2EEManager(this.options.e2ee);\n      }\n      this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {\n        if (isLocalParticipant(participant)) {\n          this.isE2EEEnabled = enabled;\n        }\n        this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n      });\n      this.e2eeManager.on(EncryptionEvent.EncryptionError, error => this.emit(RoomEvent.EncryptionError, error));\n      (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n    }\n  }\n  get logContext() {\n    var _a;\n    return {\n      room: this.name,\n      roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\n      participant: this.localParticipant.identity,\n      pID: this.localParticipant.sid\n    };\n  }\n  /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/\n  get isRecording() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\n   * server assigned unique room id.\n   * returns once a sid has been issued by the server.\n   */\n  getSid() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === ConnectionState.Disconnected) {\n        return '';\n      }\n      if (this.roomInfo && this.roomInfo.sid !== '') {\n        return this.roomInfo.sid;\n      }\n      return new Promise((resolve, reject) => {\n        const handleRoomUpdate = roomInfo => {\n          if (roomInfo.sid !== '') {\n            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n            resolve(roomInfo.sid);\n          }\n        };\n        this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\n        this.once(RoomEvent.Disconnected, () => {\n          this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n          reject('Room disconnected before room server id was available');\n        });\n      });\n    });\n  }\n  /** user assigned name, derived from JWT token */\n  get name() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n  }\n  /** room metadata */\n  get metadata() {\n    var _a;\n    return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n  }\n  get numParticipants() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n  }\n  get numPublishers() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n  }\n  maybeCreateEngine() {\n    if (this.engine && !this.engine.isClosed) {\n      return;\n    }\n    this.engine = new RTCEngine(this.options);\n    this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {\n      this.onTrackAdded(mediaTrack, stream, receiver);\n    }).on(EngineEvent.Disconnected, reason => {\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\n      this.clearConnectionReconcile();\n      this.isResuming = true;\n      this.log.info('Resuming signal connection', this.logContext);\n      if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\n        this.emit(RoomEvent.SignalReconnecting);\n      }\n    }).on(EngineEvent.Resumed, () => {\n      this.registerConnectionReconcile();\n      this.isResuming = false;\n      this.log.info('Resumed signal connection', this.logContext);\n      this.updateSubscriptions();\n      this.emitBufferedEvents();\n      if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\n        this.emit(RoomEvent.Reconnected);\n      }\n    }).on(EngineEvent.SignalResumed, () => {\n      this.bufferedEvents = [];\n      if (this.state === ConnectionState.Reconnecting || this.isResuming) {\n        this.sendSyncState();\n      }\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n    }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {\n      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n    }).on(EngineEvent.LocalTrackSubscribed, subscribedSid => {\n      const trackPublication = this.localParticipant.getTrackPublications().find(_ref2 => {\n        let {\n          trackSid\n        } = _ref2;\n        return trackSid === subscribedSid;\n      });\n      if (!trackPublication) {\n        this.log.warn('could not find local track subscription for subscribed event', this.logContext);\n        return;\n      }\n      this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\n      this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\n    });\n    if (this.localParticipant) {\n      this.localParticipant.setupEngine(this.engine);\n    }\n    if (this.e2eeManager) {\n      this.e2eeManager.setupEngine(this.engine);\n    }\n  }\n  /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it requests device permissions by default if needed\n   * and makes sure the returned device does not consist of dummy devices\n   * @param kind\n   * @returns a list of available local devices\n   */\n  static getLocalDevices(kind) {\n    let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n  }\n  /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */\n  prepareConnection(url, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state !== ConnectionState.Disconnected) {\n        return;\n      }\n      this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n      try {\n        if (isCloud(new URL(url)) && token) {\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\n          const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n          // we will not replace the regionUrl if an attempt had already started\n          // to avoid overriding regionUrl after a new connection attempt had started\n          if (regionUrl && this.state === ConnectionState.Disconnected) {\n            this.regionUrl = regionUrl;\n            yield fetch(toHttpUrl(regionUrl), {\n              method: 'HEAD'\n            });\n            this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n          }\n        } else {\n          yield fetch(toHttpUrl(url), {\n            method: 'HEAD'\n          });\n        }\n      } catch (e) {\n        this.log.warn('could not prepare connection', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n      }\n    });\n  }\n  /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */\n  getParticipantByIdentity(identity) {\n    if (this.localParticipant.identity === identity) {\n      return this.localParticipant;\n    }\n    return this.remoteParticipants.get(identity);\n  }\n  clearConnectionFutures() {\n    this.connectFuture = undefined;\n  }\n  /**\n   * @internal for testing\n   */\n  simulateScenario(scenario, arg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let postAction = () => {};\n      let req;\n      switch (scenario) {\n        case 'signal-reconnect':\n          // @ts-expect-error function is private\n          yield this.engine.client.handleOnClose('simulate disconnect');\n          break;\n        case 'speaker':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'speakerUpdate',\n              value: 3\n            }\n          });\n          break;\n        case 'node-failure':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'nodeFailure',\n              value: true\n            }\n          });\n          break;\n        case 'server-leave':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'serverLeave',\n              value: true\n            }\n          });\n          break;\n        case 'migration':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'migration',\n              value: true\n            }\n          });\n          break;\n        case 'resume-reconnect':\n          this.engine.failNext();\n          // @ts-expect-error function is private\n          yield this.engine.client.handleOnClose('simulate resume-disconnect');\n          break;\n        case 'disconnect-signal-on-resume':\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            // @ts-expect-error function is private\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n          });\n          req = new SimulateScenario({\n            scenario: {\n              case: 'disconnectSignalOnResume',\n              value: true\n            }\n          });\n          break;\n        case 'disconnect-signal-on-resume-no-messages':\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            // @ts-expect-error function is private\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n          });\n          req = new SimulateScenario({\n            scenario: {\n              case: 'disconnectSignalOnResumeNoMessages',\n              value: true\n            }\n          });\n          break;\n        case 'full-reconnect':\n          this.engine.fullReconnectOnNext = true;\n          // @ts-expect-error function is private\n          yield this.engine.client.handleOnClose('simulate full-reconnect');\n          break;\n        case 'force-tcp':\n        case 'force-tls':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'switchCandidateProtocol',\n              value: scenario === 'force-tls' ? 2 : 1\n            }\n          });\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            const onLeave = this.engine.client.onLeave;\n            if (onLeave) {\n              onLeave(new LeaveRequest({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                action: LeaveRequest_Action.RECONNECT\n              }));\n            }\n          });\n          break;\n        case 'subscriber-bandwidth':\n          if (arg === undefined || typeof arg !== 'number') {\n            throw new Error('subscriber-bandwidth requires a number as argument');\n          }\n          req = new SimulateScenario({\n            scenario: {\n              case: 'subscriberBandwidth',\n              value: numberToBigInt(arg)\n            }\n          });\n          break;\n        case 'leave-full-reconnect':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'leaveRequestFullReconnect',\n              value: true\n            }\n          });\n      }\n      if (req) {\n        yield this.engine.client.sendSimulateScenario(req);\n        yield postAction();\n      }\n    });\n  }\n  /**\n   * Returns true if audio playback is enabled\n   */\n  get canPlaybackAudio() {\n    return this.audioEnabled;\n  }\n  /**\n   * Returns true if video playback is enabled\n   */\n  get canPlaybackVideo() {\n    return !this.isVideoPlaybackBlocked;\n  }\n  getActiveDevice(kind) {\n    return this.localParticipant.activeDeviceMap.get(kind);\n  }\n  /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */\n  switchActiveDevice(kind_1, deviceId_1) {\n    return __awaiter(this, arguments, void 0, function (kind, deviceId) {\n      var _this3 = this;\n      let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return function* () {\n        var _a, _b, _c, _d, _e, _f, _g;\n        var _h;\n        let success = true;\n        let needsUpdateWithoutTracks = false;\n        const deviceConstraint = exact ? {\n          exact: deviceId\n        } : deviceId;\n        if (kind === 'audioinput') {\n          needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;\n          const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\n          _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\n          const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter(track => track.source === Track.Source.Microphone);\n          try {\n            success = (yield Promise.all(tracks.map(t => {\n              var _a;\n              return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n            }))).every(val => val === true);\n          } catch (e) {\n            _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\n            throw e;\n          }\n        } else if (kind === 'videoinput') {\n          needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;\n          const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\n          _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\n          const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter(track => track.source === Track.Source.Camera);\n          try {\n            success = (yield Promise.all(tracks.map(t => {\n              var _a;\n              return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n            }))).every(val => val === true);\n          } catch (e) {\n            _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\n            throw e;\n          }\n        } else if (kind === 'audiooutput') {\n          if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !('setSinkId' in _this3.audioContext)) {\n            throw new Error('cannot switch audio output, setSinkId not supported');\n          }\n          if (_this3.options.webAudioMix) {\n            // setting `default` for web audio output doesn't work, so we need to normalize the id before\n            deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId('audiooutput', deviceId)) !== null && _c !== void 0 ? _c : '';\n          }\n          (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};\n          const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\n          _this3.options.audioOutput.deviceId = deviceId;\n          try {\n            if (_this3.options.webAudioMix) {\n              // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n              (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\n            }\n            // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\n            // see https://issues.chromium.org/issues/40252911#comment7\n            yield Promise.all(Array.from(_this3.remoteParticipants.values()).map(p => p.setAudioOutput({\n              deviceId\n            })));\n          } catch (e) {\n            _this3.options.audioOutput.deviceId = prevDeviceId;\n            throw e;\n          }\n        }\n        if (needsUpdateWithoutTracks || kind === 'audiooutput') {\n          // if there are not active tracks yet or we're switching audiooutput, we need to manually update the active device map here as changing audio output won't result in a track restart\n          _this3.localParticipant.activeDeviceMap.set(kind, kind === 'audiooutput' && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);\n          _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n        }\n        return success;\n      }();\n    });\n  }\n  setupLocalParticipantEvents() {\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n  }\n  recreateEngine() {\n    var _a;\n    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n    /* @ts-ignore */\n    this.engine = undefined;\n    this.isResuming = false;\n    // clear out existing remote participants, since they may have attached\n    // the old engine\n    this.remoteParticipants.clear();\n    this.sidToIdentity.clear();\n    this.bufferedEvents = [];\n    this.maybeCreateEngine();\n  }\n  onTrackAdded(mediaTrack, stream, receiver) {\n    // don't fire onSubscribed when connecting\n    // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n    // at that time, ICE connectivity has not been established so the track is not\n    // technically subscribed.\n    // We'll defer these events until when the room is connected or eventually disconnected.\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n      const reconnectedHandler = () => {\n        this.onTrackAdded(mediaTrack, stream, receiver);\n        cleanup();\n      };\n      const cleanup = () => {\n        this.off(RoomEvent.Reconnected, reconnectedHandler);\n        this.off(RoomEvent.Connected, reconnectedHandler);\n        this.off(RoomEvent.Disconnected, cleanup);\n      };\n      this.once(RoomEvent.Reconnected, reconnectedHandler);\n      this.once(RoomEvent.Connected, reconnectedHandler);\n      this.once(RoomEvent.Disconnected, cleanup);\n      return;\n    }\n    if (this.state === ConnectionState.Disconnected) {\n      this.log.warn('skipping incoming track after Room disconnected', this.logContext);\n      return;\n    }\n    if (mediaTrack.readyState === 'ended') {\n      this.log.info('skipping incoming track as it already ended', this.logContext);\n      return;\n    }\n    const parts = unpackStreamId(stream.id);\n    const participantSid = parts[0];\n    let streamId = parts[1];\n    let trackId = mediaTrack.id;\n    // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n    // and generates its own track id instead of infer from sdp track id.\n    if (streamId && streamId.startsWith('TR')) trackId = streamId;\n    if (participantSid === this.localParticipant.sid) {\n      this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);\n      return;\n    }\n    const participant = Array.from(this.remoteParticipants.values()).find(p => p.sid === participantSid);\n    if (!participant) {\n      this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n      return;\n    }\n    let adaptiveStreamSettings;\n    if (this.options.adaptiveStream) {\n      if (typeof this.options.adaptiveStream === 'object') {\n        adaptiveStreamSettings = this.options.adaptiveStream;\n      } else {\n        adaptiveStreamSettings = {};\n      }\n    }\n    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n  }\n  handleDisconnect() {\n    let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    var _a;\n    this.clearConnectionReconcile();\n    this.isResuming = false;\n    this.bufferedEvents = [];\n    this.transcriptionReceivedTimes.clear();\n    if (this.state === ConnectionState.Disconnected) {\n      return;\n    }\n    this.regionUrl = undefined;\n    try {\n      this.remoteParticipants.forEach(p => {\n        p.trackPublications.forEach(pub => {\n          p.unpublishTrack(pub.trackSid);\n        });\n      });\n      this.localParticipant.trackPublications.forEach(pub => {\n        var _a, _b, _c;\n        if (pub.track) {\n          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n        }\n        if (shouldStopTracks) {\n          (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n        } else {\n          (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\n        }\n      });\n      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n      this.localParticipant.trackPublications.clear();\n      this.localParticipant.videoTrackPublications.clear();\n      this.localParticipant.audioTrackPublications.clear();\n      this.remoteParticipants.clear();\n      this.sidToIdentity.clear();\n      this.activeSpeakers = [];\n      if (this.audioContext && typeof this.options.webAudioMix === 'boolean') {\n        this.audioContext.close();\n        this.audioContext = undefined;\n      }\n      if (isWeb()) {\n        window.removeEventListener('beforeunload', this.onPageLeave);\n        window.removeEventListener('pagehide', this.onPageLeave);\n        window.removeEventListener('freeze', this.onPageLeave);\n        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener('devicechange', this.handleDeviceChange);\n      }\n    } finally {\n      this.setAndEmitConnectionState(ConnectionState.Disconnected);\n      this.emit(RoomEvent.Disconnected, reason);\n    }\n  }\n  handleParticipantDisconnected(identity, participant) {\n    var _a;\n    // remove and send event\n    this.remoteParticipants.delete(identity);\n    if (!participant) {\n      return;\n    }\n    participant.trackPublications.forEach(publication => {\n      participant.unpublishTrack(publication.trackSid, true);\n    });\n    this.emit(RoomEvent.ParticipantDisconnected, participant);\n    (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\n  }\n  handleStreamHeader(streamHeader, participantIdentity) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (streamHeader.contentHeader.case === 'byteHeader') {\n        const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\n        if (!streamHandlerCallback) {\n          this.log.debug('ignoring incoming byte stream due to no handler for topic', streamHeader.topic);\n          return;\n        }\n        let streamController;\n        const info = {\n          id: streamHeader.streamId,\n          name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : 'unknown',\n          mimeType: streamHeader.mimeType,\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n          topic: streamHeader.topic,\n          timestamp: bigIntToNumber(streamHeader.timestamp),\n          attributes: streamHeader.attributes\n        };\n        const stream = new ReadableStream({\n          start: controller => {\n            streamController = controller;\n            this.byteStreamControllers.set(streamHeader.streamId, {\n              info,\n              controller: streamController,\n              startTime: Date.now()\n            });\n          }\n        });\n        streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\n          identity: participantIdentity\n        });\n      } else if (streamHeader.contentHeader.case === 'textHeader') {\n        const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\n        if (!streamHandlerCallback) {\n          this.log.debug('ignoring incoming text stream due to no handler for topic', streamHeader.topic);\n          return;\n        }\n        let streamController;\n        const info = {\n          id: streamHeader.streamId,\n          mimeType: streamHeader.mimeType,\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n          topic: streamHeader.topic,\n          timestamp: Number(streamHeader.timestamp),\n          attributes: streamHeader.attributes\n        };\n        const stream = new ReadableStream({\n          start: controller => {\n            streamController = controller;\n            this.textStreamControllers.set(streamHeader.streamId, {\n              info,\n              controller: streamController,\n              startTime: Date.now()\n            });\n          }\n        });\n        streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\n          identity: participantIdentity\n        });\n      }\n    });\n  }\n  handleStreamChunk(chunk) {\n    const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\n    if (fileBuffer) {\n      if (chunk.content.length > 0) {\n        fileBuffer.controller.enqueue(chunk);\n      }\n    }\n    const textBuffer = this.textStreamControllers.get(chunk.streamId);\n    if (textBuffer) {\n      if (chunk.content.length > 0) {\n        textBuffer.controller.enqueue(chunk);\n      }\n    }\n  }\n  handleStreamTrailer(trailer) {\n    const textBuffer = this.textStreamControllers.get(trailer.streamId);\n    if (textBuffer) {\n      textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\n      textBuffer.controller.close();\n      this.textStreamControllers.delete(trailer.streamId);\n    }\n    const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\n    if (fileBuffer) {\n      {\n        fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\n        fileBuffer.controller.close();\n        this.byteStreamControllers.delete(trailer.streamId);\n      }\n    }\n  }\n  acquireAudioContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (typeof this.options.webAudioMix !== 'boolean' && this.options.webAudioMix.audioContext) {\n        // override audio context with custom audio context if supplied by user\n        this.audioContext = this.options.webAudioMix.audioContext;\n      } else if (!this.audioContext || this.audioContext.state === 'closed') {\n        // by using an AudioContext, it reduces lag on audio elements\n        // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n        this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n      }\n      if (this.options.webAudioMix) {\n        this.remoteParticipants.forEach(participant => participant.setAudioContext(this.audioContext));\n      }\n      this.localParticipant.setAudioContext(this.audioContext);\n      if (this.audioContext && this.audioContext.state === 'suspended') {\n        // for iOS a newly created AudioContext is always in `suspended` state.\n        // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n        try {\n          yield Promise.race([this.audioContext.resume(), sleep(200)]);\n        } catch (e) {\n          this.log.warn('Could not resume audio context', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n        }\n      }\n      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';\n      if (newContextIsRunning !== this.canPlaybackAudio) {\n        this.audioEnabled = newContextIsRunning;\n        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n      }\n    });\n  }\n  createParticipant(identity, info) {\n    var _a;\n    let participant;\n    if (info) {\n      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\n        loggerContextCb: () => this.logContext,\n        loggerName: this.options.loggerName\n      });\n    } else {\n      participant = new RemoteParticipant(this.engine.client, '', identity, undefined, undefined, undefined, {\n        loggerContextCb: () => this.logContext,\n        loggerName: this.options.loggerName\n      });\n    }\n    if (this.options.webAudioMix) {\n      participant.setAudioContext(this.audioContext);\n    }\n    if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n      participant.setAudioOutput(this.options.audioOutput).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n    }\n    return participant;\n  }\n  getOrCreateParticipant(identity, info) {\n    if (this.remoteParticipants.has(identity)) {\n      const existingParticipant = this.remoteParticipants.get(identity);\n      if (info) {\n        const wasUpdated = existingParticipant.updateInfo(info);\n        if (wasUpdated) {\n          this.sidToIdentity.set(info.sid, info.identity);\n        }\n      }\n      return existingParticipant;\n    }\n    const participant = this.createParticipant(identity, info);\n    this.remoteParticipants.set(identity, participant);\n    this.sidToIdentity.set(info.sid, info.identity);\n    // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n    // firing here to make sure that `ParticipantConnected` fires before the initial track events\n    this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n    // also forward events\n    // trackPublished is only fired for tracks added after both local participant\n    // and remote participant joined the room\n    participant.on(ParticipantEvent.TrackPublished, trackPublication => {\n      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {\n      // monitor playback status\n      if (track.kind === Track.Kind.Audio) {\n        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n      } else if (track.kind === Track.Kind.Video) {\n        track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n        track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n      }\n      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackUnpublished, publication => {\n      this.emit(RoomEvent.TrackUnpublished, publication, participant);\n    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {\n      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackMuted, pub => {\n      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n    }).on(ParticipantEvent.TrackUnmuted, pub => {\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n    }).on(ParticipantEvent.ParticipantMetadataChanged, metadata => {\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n    }).on(ParticipantEvent.ParticipantNameChanged, name => {\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n    }).on(ParticipantEvent.AttributesChanged, changedAttributes => {\n      this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\n    }).on(ParticipantEvent.ConnectionQualityChanged, quality => {\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions => {\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {\n      this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n    });\n    // update info at the end after callbacks have been set up\n    if (info) {\n      participant.updateInfo(info);\n    }\n    return participant;\n  }\n  sendSyncState() {\n    const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {\n      acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n      return acc;\n    }, []);\n    const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n    this.engine.sendSyncState(remoteTracks, localTracks);\n  }\n  /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */\n  updateSubscriptions() {\n    for (const p of this.remoteParticipants.values()) {\n      for (const pub of p.videoTrackPublications.values()) {\n        if (pub.isSubscribed && isRemotePub(pub)) {\n          pub.emitTrackUpdate();\n        }\n      }\n    }\n  }\n  getRemoteParticipantBySid(sid) {\n    const identity = this.sidToIdentity.get(sid);\n    if (identity) {\n      return this.remoteParticipants.get(identity);\n    }\n  }\n  registerConnectionReconcile() {\n    this.clearConnectionReconcile();\n    let consecutiveFailures = 0;\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\n      if (\n      // ensure we didn't tear it down\n      !this.engine ||\n      // engine detected close, but Room missed it\n      this.engine.isClosed ||\n      // transports failed without notifying engine\n      !this.engine.verifyTransport()) {\n        consecutiveFailures++;\n        this.log.warn('detected connection state mismatch', Object.assign(Object.assign({}, this.logContext), {\n          numFailures: consecutiveFailures,\n          engine: this.engine ? {\n            closed: this.engine.isClosed,\n            transportsConnected: this.engine.verifyTransport()\n          } : undefined\n        }));\n        if (consecutiveFailures >= 3) {\n          this.recreateEngine();\n          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n        }\n      } else {\n        consecutiveFailures = 0;\n      }\n    }, connectionReconcileFrequency);\n  }\n  clearConnectionReconcile() {\n    if (this.connectionReconcileInterval) {\n      CriticalTimers.clearInterval(this.connectionReconcileInterval);\n    }\n  }\n  setAndEmitConnectionState(state) {\n    if (state === this.state) {\n      // unchanged\n      return false;\n    }\n    this.state = state;\n    this.emit(RoomEvent.ConnectionStateChanged, this.state);\n    return true;\n  }\n  emitBufferedEvents() {\n    this.bufferedEvents.forEach(_ref3 => {\n      let [ev, args] = _ref3;\n      this.emit(ev, ...args);\n    });\n    this.bufferedEvents = [];\n  }\n  emitWhenConnected(event) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\n      // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n      this.bufferedEvents.push([event, args]);\n    } else if (this.state === ConnectionState.Connected) {\n      return this.emit(event, ...args);\n    }\n    return false;\n  }\n  /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */\n  simulateParticipants(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const publishOptions = Object.assign({\n        audio: true,\n        video: true,\n        useRealTracks: false\n      }, options.publish);\n      const participantOptions = Object.assign({\n        count: 9,\n        audio: false,\n        video: true,\n        aspectRatios: [1.66, 1.7, 1.3]\n      }, options.participants);\n      this.handleDisconnect();\n      this.roomInfo = new Room$1({\n        sid: 'RM_SIMULATED',\n        name: 'simulated-room',\n        emptyTimeout: 0,\n        maxParticipants: 0,\n        creationTime: protoInt64.parse(new Date().getTime()),\n        metadata: '',\n        numParticipants: 1,\n        numPublishers: 1,\n        turnPassword: '',\n        enabledCodecs: [],\n        activeRecording: false\n      });\n      this.localParticipant.updateInfo(new ParticipantInfo({\n        identity: 'simulated-local',\n        name: 'local-name'\n      }));\n      this.setupLocalParticipantEvents();\n      this.emit(RoomEvent.SignalConnected);\n      this.emit(RoomEvent.Connected);\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      if (publishOptions.video) {\n        const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n          source: TrackSource.CAMERA,\n          sid: Math.floor(Math.random() * 10000).toString(),\n          type: TrackType.AUDIO,\n          name: 'video-dummy'\n        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n          video: true\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        }), {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        // @ts-ignore\n        this.localParticipant.addTrackPublication(camPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n      }\n      if (publishOptions.audio) {\n        const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n          source: TrackSource.MICROPHONE,\n          sid: Math.floor(Math.random() * 10000).toString(),\n          type: TrackType.AUDIO\n        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          audio: true\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        }), {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        // @ts-ignore\n        this.localParticipant.addTrackPublication(audioPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n      }\n      for (let i = 0; i < participantOptions.count - 1; i += 1) {\n        let info = new ParticipantInfo({\n          sid: Math.floor(Math.random() * 10000).toString(),\n          identity: \"simulated-\".concat(i),\n          state: ParticipantInfo_State.ACTIVE,\n          tracks: [],\n          joinedAt: protoInt64.parse(Date.now())\n        });\n        const p = this.getOrCreateParticipant(info.identity, info);\n        if (participantOptions.video) {\n          const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n          const videoTrack = new TrackInfo({\n            source: TrackSource.CAMERA,\n            sid: Math.floor(Math.random() * 10000).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());\n          info.tracks = [...info.tracks, videoTrack];\n        }\n        if (participantOptions.audio) {\n          const dummyTrack = getEmptyAudioStreamTrack();\n          const audioTrack = new TrackInfo({\n            source: TrackSource.MICROPHONE,\n            sid: Math.floor(Math.random() * 10000).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());\n          info.tracks = [...info.tracks, audioTrack];\n        }\n        p.updateInfo(info);\n      }\n    });\n  }\n  // /** @internal */\n  emit(event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    // active speaker updates are too spammy\n    if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\n      // only extract logContext from arguments in order to avoid logging the whole object tree\n      const minimizedArgs = mapArgs(args).filter(arg => arg !== undefined);\n      this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n        event,\n        args: minimizedArgs\n      }));\n    }\n    return super.emit(event, ...args);\n  }\n}\nRoom.cleanupRegistry = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(cleanup => {\n  cleanup();\n});\nfunction mapArgs(args) {\n  return args.map(arg => {\n    if (!arg) {\n      return;\n    }\n    if (Array.isArray(arg)) {\n      return mapArgs(arg);\n    }\n    if (typeof arg === 'object') {\n      return 'logContext' in arg ? arg.logContext : undefined;\n    }\n    return arg;\n  });\n}\n\nvar CheckStatus;\n(function (CheckStatus) {\n  CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n  CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n  CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n  CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n  CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.status = CheckStatus.IDLE;\n    this.logs = [];\n    this.options = {};\n    this.url = url;\n    this.token = token;\n    this.name = this.constructor.name;\n    this.room = new Room(options.roomOptions);\n    this.connectOptions = options.connectOptions;\n    this.options = options;\n  }\n  run(onComplete) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== CheckStatus.IDLE) {\n        throw Error('check is running already');\n      }\n      this.setStatus(CheckStatus.RUNNING);\n      try {\n        yield this.perform();\n      } catch (err) {\n        if (err instanceof Error) {\n          if (this.options.errorsAsWarnings) {\n            this.appendWarning(err.message);\n          } else {\n            this.appendError(err.message);\n          }\n        }\n      }\n      yield this.disconnect();\n      // sleep for a bit to ensure disconnect\n      yield new Promise(resolve => setTimeout(resolve, 500));\n      // @ts-ignore\n      if (this.status !== CheckStatus.SKIPPED) {\n        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n      }\n      if (onComplete) {\n        onComplete();\n      }\n      return this.getInfo();\n    });\n  }\n  isSuccess() {\n    return !this.logs.some(l => l.level === 'error');\n  }\n  connect(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room.state === ConnectionState.Connected) {\n        return this.room;\n      }\n      if (!url) {\n        url = this.url;\n      }\n      yield this.room.connect(url, this.token, this.connectOptions);\n      return this.room;\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room && this.room.state !== ConnectionState.Disconnected) {\n        yield this.room.disconnect();\n        // wait for it to go through\n        yield new Promise(resolve => setTimeout(resolve, 500));\n      }\n    });\n  }\n  skip() {\n    this.setStatus(CheckStatus.SKIPPED);\n  }\n  switchProtocol(protocol) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let hasReconnecting = false;\n      let hasReconnected = false;\n      this.room.on(RoomEvent.Reconnecting, () => {\n        hasReconnecting = true;\n      });\n      this.room.once(RoomEvent.Reconnected, () => {\n        hasReconnected = true;\n      });\n      this.room.simulateScenario(\"force-\".concat(protocol));\n      yield new Promise(resolve => setTimeout(resolve, 1000));\n      if (!hasReconnecting) {\n        // no need to wait for reconnection\n        return;\n      }\n      // wait for 10 seconds for reconnection\n      const timeout = Date.now() + 10000;\n      while (Date.now() < timeout) {\n        if (hasReconnected) {\n          return;\n        }\n        yield sleep(100);\n      }\n      throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\n    });\n  }\n  appendMessage(message) {\n    this.logs.push({\n      level: 'info',\n      message\n    });\n    this.emit('update', this.getInfo());\n  }\n  appendWarning(message) {\n    this.logs.push({\n      level: 'warning',\n      message\n    });\n    this.emit('update', this.getInfo());\n  }\n  appendError(message) {\n    this.logs.push({\n      level: 'error',\n      message\n    });\n    this.emit('update', this.getInfo());\n  }\n  setStatus(status) {\n    this.status = status;\n    this.emit('update', this.getInfo());\n  }\n  get engine() {\n    var _a;\n    return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n  }\n  getInfo() {\n    return {\n      logs: this.logs,\n      name: this.name,\n      status: this.status,\n      description: this.description\n    };\n  }\n}\n\n/**\n * Checks for connections quality to closests Cloud regions and determining the best quality\n */\nclass CloudRegionCheck extends Checker {\n  get description() {\n    return 'Cloud regions';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const regionProvider = new RegionUrlProvider(this.url, this.token);\n      if (!regionProvider.isCloud()) {\n        this.skip();\n        return;\n      }\n      const regionStats = [];\n      const seenUrls = new Set();\n      for (let i = 0; i < 3; i++) {\n        const regionUrl = yield regionProvider.getNextBestRegionUrl();\n        if (!regionUrl) {\n          break;\n        }\n        if (seenUrls.has(regionUrl)) {\n          continue;\n        }\n        seenUrls.add(regionUrl);\n        const stats = yield this.checkCloudRegion(regionUrl);\n        this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\n        regionStats.push(stats);\n      }\n      regionStats.sort((a, b) => {\n        return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\n      });\n      const bestRegion = regionStats[0];\n      this.bestStats = bestRegion;\n      this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\n    });\n  }\n  getInfo() {\n    const info = super.getInfo();\n    info.data = this.bestStats;\n    return info;\n  }\n  checkCloudRegion(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      yield this.connect(url);\n      if (this.options.protocol === 'tcp') {\n        yield this.switchProtocol('tcp');\n      }\n      const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\n      if (!region) {\n        throw new Error('Region not found');\n      }\n      const writer = yield this.room.localParticipant.streamText({\n        topic: 'test'\n      });\n      const chunkSize = 1000; // each chunk is about 1000 bytes\n      const totalSize = 1000000; // approximately 1MB of data\n      const numChunks = totalSize / chunkSize; // will yield 1000 chunks\n      const chunkData = 'A'.repeat(chunkSize); // create a string of 1000 'A' characters\n      const startTime = Date.now();\n      for (let i = 0; i < numChunks; i++) {\n        yield writer.write(chunkData);\n      }\n      yield writer.close();\n      const endTime = Date.now();\n      const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\n      const regionStats = {\n        region: region,\n        rtt: 10000,\n        duration: endTime - startTime\n      };\n      stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\n        if (stat.type === 'candidate-pair' && stat.nominated) {\n          regionStats.rtt = stat.currentRoundTripTime * 1000;\n        }\n      });\n      yield this.disconnect();\n      return regionStats;\n    });\n  }\n}\n\nconst TEST_DURATION = 10000;\nclass ConnectionProtocolCheck extends Checker {\n  get description() {\n    return 'Connection via UDP vs TCP';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const udpStats = yield this.checkConnectionProtocol('udp');\n      const tcpStats = yield this.checkConnectionProtocol('tcp');\n      this.bestStats = udpStats;\n      // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\n      // 1. the bandwidth limitation is worse on UDP by 500ms\n      // 2. the packet loss is higher on UDP by 1%\n      if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\n        this.appendMessage('best connection quality via tcp');\n        this.bestStats = tcpStats;\n      } else {\n        this.appendMessage('best connection quality via udp');\n      }\n      const stats = this.bestStats;\n      this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\n      this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\n      this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\n      if (stats.packetsLost > 0) {\n        this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\n      }\n      if (stats.qualityLimitationDurations.bandwidth > 1) {\n        this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n      }\n      if (stats.qualityLimitationDurations.cpu > 0) {\n        this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n      }\n    });\n  }\n  getInfo() {\n    const info = super.getInfo();\n    info.data = this.bestStats;\n    return info;\n  }\n  checkConnectionProtocol(protocol) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connect();\n      if (protocol === 'tcp') {\n        yield this.switchProtocol('tcp');\n      } else {\n        yield this.switchProtocol('udp');\n      }\n      // create a canvas with animated content\n      const canvas = document.createElement('canvas');\n      canvas.width = 1280;\n      canvas.height = 720;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error('Could not get canvas context');\n      }\n      let hue = 0;\n      const animate = () => {\n        hue = (hue + 1) % 360;\n        ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        requestAnimationFrame(animate);\n      };\n      animate();\n      // create video track from canvas\n      const stream = canvas.captureStream(30); // 30fps\n      const videoTrack = stream.getVideoTracks()[0];\n      // publish to room\n      const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\n        simulcast: false,\n        degradationPreference: 'maintain-resolution',\n        videoEncoding: {\n          maxBitrate: 2000000\n        }\n      });\n      const track = pub.track;\n      const protocolStats = {\n        protocol,\n        packetsLost: 0,\n        packetsSent: 0,\n        qualityLimitationDurations: {},\n        rttTotal: 0,\n        jitterTotal: 0,\n        bitrateTotal: 0,\n        count: 0\n      };\n      // gather stats once a second\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        const stats = yield track.getRTCStatsReport();\n        stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\n          if (stat.type === 'outbound-rtp') {\n            protocolStats.packetsSent = stat.packetsSent;\n            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\n            protocolStats.bitrateTotal += stat.targetBitrate;\n            protocolStats.count++;\n          } else if (stat.type === 'remote-inbound-rtp') {\n            protocolStats.packetsLost = stat.packetsLost;\n            protocolStats.rttTotal += stat.roundTripTime;\n            protocolStats.jitterTotal += stat.jitter;\n          }\n        });\n      }), 1000);\n      // wait a bit to gather stats\n      yield new Promise(resolve => setTimeout(resolve, TEST_DURATION));\n      clearInterval(interval);\n      videoTrack.stop();\n      canvas.remove();\n      yield this.disconnect();\n      return protocolStats;\n    });\n  }\n}\n\nclass PublishAudioCheck extends Checker {\n  get description() {\n    return 'Can publish audio';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const room = yield this.connect();\n      const track = yield createLocalAudioTrack();\n      const trackIsSilent = yield detectSilence(track, 1000);\n      if (trackIsSilent) {\n        throw new Error('unable to detect audio from microphone');\n      }\n      this.appendMessage('detected audio from microphone');\n      room.localParticipant.publishTrack(track);\n      // wait for a few seconds to publish\n      yield new Promise(resolve => setTimeout(resolve, 3000));\n      // verify RTC stats that it's publishing\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error('Could not get RTCStats');\n      }\n      let numPackets = 0;\n      stats.forEach(stat => {\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'audio' || !stat.kind && stat.mediaType === 'audio')) {\n          numPackets = stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error('Could not determine packets are sent');\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n    });\n  }\n}\n\nclass PublishVideoCheck extends Checker {\n  get description() {\n    return 'Can publish video';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const room = yield this.connect();\n      const track = yield createLocalVideoTrack();\n      // check if we have video from camera\n      yield this.checkForVideo(track.mediaStreamTrack);\n      room.localParticipant.publishTrack(track);\n      // wait for a few seconds to publish\n      yield new Promise(resolve => setTimeout(resolve, 5000));\n      // verify RTC stats that it's publishing\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error('Could not get RTCStats');\n      }\n      let numPackets = 0;\n      stats.forEach(stat => {\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'video' || !stat.kind && stat.mediaType === 'video')) {\n          numPackets += stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error('Could not determine packets are sent');\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n    });\n  }\n  checkForVideo(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stream = new MediaStream();\n      stream.addTrack(track.clone());\n      // Create video element to check frames\n      const video = document.createElement('video');\n      video.srcObject = stream;\n      video.muted = true;\n      yield new Promise(resolve => {\n        video.onplay = () => {\n          setTimeout(() => {\n            var _a, _b, _c, _d;\n            const canvas = document.createElement('canvas');\n            const settings = track.getSettings();\n            const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\n            const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            // Draw video frame to canvas\n            ctx.drawImage(video, 0, 0);\n            // Get image data and check if all pixels are black\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            const data = imageData.data;\n            let isAllBlack = true;\n            for (let i = 0; i < data.length; i += 4) {\n              if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\n                isAllBlack = false;\n                break;\n              }\n            }\n            if (isAllBlack) {\n              this.appendError('camera appears to be producing only black frames');\n            } else {\n              this.appendMessage('received video frames');\n            }\n            resolve();\n          }, 1000);\n        };\n        video.play();\n      });\n      video.remove();\n    });\n  }\n}\n\nclass ReconnectCheck extends Checker {\n  get description() {\n    return 'Resuming connection after interruption';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const room = yield this.connect();\n      let reconnectingTriggered = false;\n      let reconnected = false;\n      let reconnectResolver;\n      const reconnectTimeout = new Promise(resolve => {\n        setTimeout(resolve, 5000);\n        reconnectResolver = resolve;\n      });\n      const handleReconnecting = () => {\n        reconnectingTriggered = true;\n      };\n      room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {\n        reconnected = true;\n        reconnectResolver(true);\n      });\n      (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n      const onClose = room.engine.client.onClose;\n      if (onClose) {\n        onClose('');\n      }\n      yield reconnectTimeout;\n      if (!reconnectingTriggered) {\n        throw new Error('Did not attempt to reconnect');\n      } else if (!reconnected || room.state !== ConnectionState.Connected) {\n        this.appendWarning('reconnection is only possible in Redis-based configurations');\n        throw new Error('Not able to reconnect');\n      }\n    });\n  }\n}\n\nclass TURNCheck extends Checker {\n  get description() {\n    return 'Can connect via TURN';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0,\n        e2eeEnabled: false,\n        websocketTimeout: 15000\n      });\n      let hasTLS = false;\n      let hasTURN = false;\n      let hasSTUN = false;\n      for (let iceServer of joinRes.iceServers) {\n        for (let url of iceServer.urls) {\n          if (url.startsWith('turn:')) {\n            hasTURN = true;\n            hasSTUN = true;\n          } else if (url.startsWith('turns:')) {\n            hasTURN = true;\n            hasSTUN = true;\n            hasTLS = true;\n          }\n          if (url.startsWith('stun:')) {\n            hasSTUN = true;\n          }\n        }\n      }\n      if (!hasSTUN) {\n        this.appendWarning('No STUN servers configured on server side.');\n      } else if (hasTURN && !hasTLS) {\n        this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');\n      }\n      yield signalClient.close();\n      if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n        yield this.room.connect(this.url, this.token, {\n          rtcConfig: {\n            iceTransportPolicy: 'relay'\n          }\n        });\n      } else {\n        this.appendWarning('No TURN servers configured.');\n        this.skip();\n        yield new Promise(resolve => setTimeout(resolve, 0));\n      }\n    });\n  }\n}\n\nclass WebRTCCheck extends Checker {\n  get description() {\n    return 'Establishing WebRTC connection';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let hasTcp = false;\n      let hasIpv4Udp = false;\n      this.room.on(RoomEvent.SignalConnected, () => {\n        const prevTrickle = this.room.engine.client.onTrickle;\n        this.room.engine.client.onTrickle = (sd, target) => {\n          if (sd.candidate) {\n            const candidate = new RTCIceCandidate(sd);\n            let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n            if (candidate.address) {\n              if (isIPPrivate(candidate.address)) {\n                str += ' (private)';\n              } else {\n                if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {\n                  hasTcp = true;\n                  str += ' (passive)';\n                } else if (candidate.protocol === 'udp') {\n                  hasIpv4Udp = true;\n                }\n              }\n            }\n            this.appendMessage(str);\n          }\n          if (prevTrickle) {\n            prevTrickle(sd, target);\n          }\n        };\n        if (this.room.engine.pcManager) {\n          this.room.engine.pcManager.subscriber.onIceCandidateError = ev => {\n            if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n              this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n            }\n          };\n        }\n      });\n      try {\n        yield this.connect();\n        livekitLogger.info('now the room is connected');\n      } catch (err) {\n        this.appendWarning('ports need to be open on firewall in order to connect.');\n        throw err;\n      }\n      if (!hasTcp) {\n        this.appendWarning('Server is not configured for ICE/TCP');\n      }\n      if (!hasIpv4Udp) {\n        this.appendWarning('No public IPv4 UDP candidates were found. Your server is likely not configured correctly');\n      }\n    });\n  }\n}\nfunction isIPPrivate(address) {\n  const parts = address.split('.');\n  if (parts.length === 4) {\n    if (parts[0] === '10') {\n      return true;\n    } else if (parts[0] === '192' && parts[1] === '168') {\n      return true;\n    } else if (parts[0] === '172') {\n      const second = parseInt(parts[1], 10);\n      if (second >= 16 && second <= 31) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nclass WebSocketCheck extends Checker {\n  get description() {\n    return 'Connecting to signal connection via WebSocket';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {\n        this.appendWarning('Server is insecure, clients may block connections to it');\n      }\n      let signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0,\n        e2eeEnabled: false,\n        websocketTimeout: 15000\n      });\n      this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n      if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n        this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n      }\n      yield signalClient.close();\n    });\n  }\n}\n\nclass ConnectionCheck extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.options = {};\n    this.checkResults = new Map();\n    this.url = url;\n    this.token = token;\n    this.options = options;\n  }\n  getNextCheckId() {\n    const nextId = this.checkResults.size;\n    this.checkResults.set(nextId, {\n      logs: [],\n      status: CheckStatus.IDLE,\n      name: '',\n      description: ''\n    });\n    return nextId;\n  }\n  updateCheck(checkId, info) {\n    this.checkResults.set(checkId, info);\n    this.emit('checkUpdate', checkId, info);\n  }\n  isSuccess() {\n    return Array.from(this.checkResults.values()).every(r => r.status !== CheckStatus.FAILED);\n  }\n  getResults() {\n    return Array.from(this.checkResults.values());\n  }\n  createAndRunCheck(check) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const checkId = this.getNextCheckId();\n      const test = new check(this.url, this.token, this.options);\n      const handleUpdate = info => {\n        this.updateCheck(checkId, info);\n      };\n      test.on('update', handleUpdate);\n      const result = yield test.run();\n      test.off('update', handleUpdate);\n      return result;\n    });\n  }\n  checkWebsocket() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebSocketCheck);\n    });\n  }\n  checkWebRTC() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebRTCCheck);\n    });\n  }\n  checkTURN() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(TURNCheck);\n    });\n  }\n  checkReconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(ReconnectCheck);\n    });\n  }\n  checkPublishAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishAudioCheck);\n    });\n  }\n  checkPublishVideo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishVideoCheck);\n    });\n  }\n  checkConnectionProtocol() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\n      if (info.data && 'protocol' in info.data) {\n        const stats = info.data;\n        this.options.protocol = stats.protocol;\n      }\n      return info;\n    });\n  }\n  checkCloudRegion() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(CloudRegionCheck);\n    });\n  }\n}\n\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */\nfunction facingModeFromLocalTrack(localTrack) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\n  const trackSettings = track.getSettings();\n  let result = {\n    facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',\n    confidence: 'low'\n  };\n  // 1. Try to get facingMode from track settings.\n  if ('facingMode' in trackSettings) {\n    const rawFacingMode = trackSettings.facingMode;\n    livekitLogger.trace('rawFacingMode', {\n      rawFacingMode\n    });\n    if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {\n      result = {\n        facingMode: rawFacingMode,\n        confidence: 'high'\n      };\n    }\n  }\n  // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n  if (['low', 'medium'].includes(result.confidence)) {\n    livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n    const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n    if (labelAnalysisResult !== undefined) {\n      result = labelAnalysisResult;\n    }\n  }\n  return result;\n}\nconst knownDeviceLabels = new Map([['obs virtual camera', {\n  facingMode: 'environment',\n  confidence: 'medium'\n}]]);\nconst knownDeviceLabelSections = new Map([['iphone', {\n  facingMode: 'environment',\n  confidence: 'medium'\n}], ['ipad', {\n  facingMode: 'environment',\n  confidence: 'medium'\n}]]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */\nfunction facingModeFromDeviceLabel(deviceLabel) {\n  var _a;\n  const label = deviceLabel.trim().toLowerCase();\n  // Empty string is a valid device label but we can't infer anything from it.\n  if (label === '') {\n    return undefined;\n  }\n  // Can we match against widely known device labels.\n  if (knownDeviceLabels.has(label)) {\n    return knownDeviceLabels.get(label);\n  }\n  // Can we match against sections of the device label.\n  return (_a = Array.from(knownDeviceLabelSections.entries()).find(_ref => {\n    let [section] = _ref;\n    return label.includes(section);\n  })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n  const allowedValues = ['user', 'environment', 'left', 'right'];\n  return item === undefined || allowedValues.includes(item);\n}\n\n\n//# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMy9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxTQUFTO0FBQ2pFLFVBQVUsTUFBTSw2Q0FBNkMsTUFBTSxHQUFHLElBQUk7QUFDMUUsSUFBSSxLQUFLLEdBQUcsSUFBSSxPQUFPLEtBQUs7QUFDNUI7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsZUFBZSxJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw4RUFBOEU7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1Q0FBdUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDZDQUE2QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4REFBOEQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQW9GO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0RBQXdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCLGVBQWUsdUJBQXVCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQixlQUFlLHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlGQUF5RjtBQUN6RjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwRUFBMEU7QUFDMUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDLFVBQVU7QUFDbEQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLGVBQWUsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxhQUFhO0FBQzdDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQyxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsOENBQThDO0FBQzlDO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOERBQThEO0FBQ2xIO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEhBQThIO0FBQzlIO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGlGQUFpRjtBQUNqRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0k7QUFDcEk7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUZBQXlGO0FBQ3pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUZBQXlGO0FBQ3pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseUNBQXlDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHlDQUF5QztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix5Q0FBeUM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Rix5Q0FBeUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsK0RBQStEO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixnRkFBZ0Y7QUFDaEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4SEFBOEg7QUFDOUg7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLDBHQUEwRztBQUMxRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFO0FBQzVFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJGQUEyRjtBQUMzRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5Q0FBeUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlDQUF5QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrRkFBa0Y7QUFDckY7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4RUFBOEU7QUFDakYsQ0FBQyw0Q0FBNEM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHdFQUF3RTtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkpBQTZKO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsNEtBQTRLO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFIQUFxSDtBQUNySDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpR0FBaUc7QUFDakc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpSkFBaUo7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0tBQStLO0FBQy9LO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUZBQXlGO0FBQ3pGO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvSEFBb0g7QUFDcEg7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEg7QUFDOUg7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw2R0FBNkc7QUFDN0c7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0IsSUFBSSxhQUFhO0FBQ3BGLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1Isb0ZBQW9GO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix3RkFBd0Y7QUFDeEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxLQUFLO0FBQ0wsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZUFBZTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGVBQWU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyeUQ7QUFDM3lEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGZpc2NoXFxJQV9ERU1PXFxub2RlX21vZHVsZXNcXC5wbnBtXFxsaXZla2l0LWNsaWVudEAyLjExLjNcXG5vZGVfbW9kdWxlc1xcbGl2ZWtpdC1jbGllbnRcXGRpc3RcXGxpdmVraXQtY2xpZW50LmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG4gIG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIGUgJiYgdHlwZW9mIGUgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIShrIGluIG4pKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBoID0gKGksIHMsIHQpID0+IHMgaW4gaSA/IGUoaSwgcywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogdFxufSkgOiBpW3NdID0gdDtcbnZhciBvID0gKGksIHMsIHQpID0+IGgoaSwgdHlwZW9mIHMgIT0gXCJzeW1ib2xcIiA/IHMgKyBcIlwiIDogcywgdCk7XG5jbGFzcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbyh0aGlzLCBcIl9sb2NraW5nXCIpO1xuICAgIG8odGhpcywgXCJfbG9ja3NcIik7XG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpLCB0aGlzLl9sb2NrcyA9IDA7XG4gIH1cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tzID4gMDtcbiAgfVxuICBsb2NrKCkge1xuICAgIHRoaXMuX2xvY2tzICs9IDE7XG4gICAgbGV0IHM7XG4gICAgY29uc3QgdCA9IG5ldyBQcm9taXNlKGwgPT4gcyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fbG9ja3MgLT0gMSwgbCgpO1xuICAgICAgfSksXG4gICAgICBjID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHMpO1xuICAgIHJldHVybiB0aGlzLl9sb2NraW5nID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHQpLCBjO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LFxuICBGTE9BVDMyX01JTiA9IC0zNDAyODIzNDY2Mzg1Mjg4NmUyMixcbiAgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsXG4gIElOVDMyX01BWCA9IDB4N2ZmZmZmZmYsXG4gIElOVDMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBzaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVJbnQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBwcm90b2J1ZiBmbG9hdCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFyZykpIHJldHVybjtcbiAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcbi8qKlxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcbiAqIGVudW0sIGl0IHJhaXNlcyBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bVR5cGUoZW51bU9iamVjdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IHQgPSBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXTtcbiAgYXNzZXJ0KHQsIFwibWlzc2luZyBlbnVtIHR5cGUgb24gZW51bSBvYmplY3RcIik7XG4gIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5mdW5jdGlvbiBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXSA9IG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLm1hcCh2ID0+ICh7XG4gICAgbm86IHYubm8sXG4gICAgbmFtZTogdi5uYW1lLFxuICAgIGxvY2FsTmFtZTogZW51bU9iamVjdFt2Lm5vXVxuICB9KSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcyxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9vcHQpIHtcbiAgY29uc3QgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgbm9ybWFsVmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBjb25zdCB2YWx1ZTogRW51bVZhbHVlSW5mbyA9IHsuLi52LCBvcHRpb25zOiB2Lm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdH07XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgbm9ybWFsVmFsdWVzLnB1c2gobik7XG4gICAgbmFtZXNbdmFsdWUubmFtZV0gPSBuO1xuICAgIG51bWJlcnNbdmFsdWUubm9dID0gbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVOYW1lLFxuICAgIHZhbHVlczogbm9ybWFsVmFsdWVzLFxuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgZmluZE5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWVzW25hbWVdO1xuICAgIH0sXG4gICAgZmluZE51bWJlcihubykge1xuICAgICAgcmV0dXJuIG51bWJlcnNbbm9dO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVudW0gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUVudW0odHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gIGNvbnN0IGVudW1PYmplY3QgPSB7fTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICBlbnVtT2JqZWN0W24ubG9jYWxOYW1lXSA9IG4ubm87XG4gICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICB9XG4gIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMpO1xuICByZXR1cm4gZW51bU9iamVjdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSkge1xuICBpZiAoXCJsb2NhbE5hbWVcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHtcbiAgICBsb2NhbE5hbWU6IHZhbHVlLm5hbWVcbiAgfSk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIE1lc3NhZ2UgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgZXZlcnkgbWVzc2FnZSwgZ2VuZXJhdGVkLCBvciBjcmVhdGVkIGF0XG4gKiBydW50aW1lLlxuICpcbiAqIEl0IGlzIF9ub3RfIHNhZmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG1lc3NhZ2UgYXRcbiAqIHJ1biB0aW1lLCB1c2UgcHJvdG8zLm1ha2VNZXNzYWdlVHlwZSgpLlxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgLyoqXG4gICAqIENvbXBhcmUgd2l0aCBhIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGlzcmVnYXJkcyBleHRlbnNpb25zIGFuZCB1bmtub3duIGZpZWxkcy5cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuZXF1YWxzKHRoaXMuZ2V0VHlwZSgpLCB0aGlzLCBvdGhlcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRlZXAgY29weS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuY2xvbmUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGZyb20gYmluYXJ5IGRhdGEsIG1lcmdpbmcgZmllbGRzLlxuICAgKlxuICAgKiBSZXBlYXRlZCBmaWVsZHMgYXJlIGFwcGVuZGVkLiBNYXAgZW50cmllcyBhcmUgYWRkZWQsIG92ZXJ3cml0aW5nXG4gICAqIGV4aXN0aW5nIGtleXMuXG4gICAqXG4gICAqIElmIGEgbWVzc2FnZSBmaWVsZCBpcyBhbHJlYWR5IHByZXNlbnQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAqIG5ldyBkYXRhLlxuICAgKi9cbiAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5iaW4sXG4gICAgICBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0aGlzLCBvcHQucmVhZGVyRmFjdG9yeShieXRlcyksIGJ5dGVzLmJ5dGVMZW5ndGgsIG9wdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAgICovXG4gIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5qc29uLFxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UodHlwZSwganNvblZhbHVlLCBvcHQsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIFwiLmNvbmNhdCh0aGlzLmdldFR5cGUoKS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxuICAgKi9cbiAgdG9CaW5hcnkob3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGJpbiA9IHR5cGUucnVudGltZS5iaW4sXG4gICAgICBvcHQgPSBiaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSxcbiAgICAgIHdyaXRlciA9IG9wdC53cml0ZXJGYWN0b3J5KCk7XG4gICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XG4gICAgcmV0dXJuIHdyaXRlci5maW5pc2goKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiB2YWx1ZSwgYSBKYXZhU2NyaXB0IHZhbHVlIHRoYXQgY2FuIGJlXG4gICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxuICAgKi9cbiAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBqc29uID0gdHlwZS5ydW50aW1lLmpzb24sXG4gICAgICBvcHQgPSBqc29uLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGpzb24ud3JpdGVNZXNzYWdlKHRoaXMsIG9wdCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgdG9Kc29uU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvSnNvbihvcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBmb3Igc2VyaWFsaXphdGlvbiBiZWhhdmlvci4gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbiBjYWxsaW5nXG4gICAqIEpTT04uc3RyaW5naWZ5IG9uIHRoaXMgbWVzc2FnZSAoaS5lLiBKU09OLnN0cmluZ2lmeShtc2cpKS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3Qgc2VyaWFsaXplIGdvb2dsZS5wcm90b2J1Zi5Bbnkgd2l0aCBhIHBhY2tlZFxuICAgKiBtZXNzYWdlIGJlY2F1c2UgdGhlIHByb3RvYnVmIEpTT04gZm9ybWF0IHNwZWNpZmllcyB0aGF0IGl0IG5lZWRzIHRvIGJlXG4gICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXG4gICAqIG1lc3NhZ2UgdHlwZS4gIEFzIGEgcmVzdWx0LCBhdHRlbXB0aW5nIHRvIHNlcmlhbGl6ZSBhIG1lc3NhZ2Ugd2l0aCB0aGlzXG4gICAqIHR5cGUgd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcHJvdGVjdGVkIGJlY2F1c2UgeW91IHNob3VsZCBub3QgbmVlZCB0byBpbnZva2UgaXRcbiAgICogZGlyZWN0bHkgLS0gaW5zdGVhZCB1c2UgSlNPTi5zdHJpbmdpZnkgb3IgdG9Kc29uU3RyaW5nIGZvclxuICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxuICAgKiB1c2UgdG9Kc29uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSnNvbih7XG4gICAgICBlbWl0RGVmYXVsdFZhbHVlczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXG4gICAqIHRoZSBwcm90b2J1ZiBtZXNzYWdlIGRlY2xhcmF0aW9uIGFuZCBwcm92aWRlcyBtZXRhZGF0YSBmb3IgcmVmbGVjdGlvbi1cbiAgICogYmFzZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgTWVzc2FnZVR5cGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5sb2NhbE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHR5cGVOYW1lLnN1YnN0cmluZyh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgY29uc3QgdHlwZSA9IHtcbiAgICBbbG9jYWxOYW1lXTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0RmllbGRzKHRoaXMpO1xuICAgICAgcnVudGltZS51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgfVtsb2NhbE5hbWVdO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUsIG5ldyBNZXNzYWdlKCkpO1xuICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICBydW50aW1lLFxuICAgIHR5cGVOYW1lLFxuICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUudXRpbC5lcXVhbHModHlwZSwgYSwgYik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbi8vIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIFByb3RvY29sIEJ1ZmZlciBjb21waWxlciBpcyBvd25lZCBieSB0aGUgb3duZXJcbi8vIG9mIHRoZSBpbnB1dCBmaWxlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGl0LiAgVGhpcyBjb2RlIGlzIG5vdFxuLy8gc3RhbmRhbG9uZSBhbmQgcmVxdWlyZXMgYSBzdXBwb3J0IGxpYnJhcnkgdG8gYmUgbGlua2VkIHdpdGggaXQuICBUaGlzXG4vLyBzdXBwb3J0IGxpYnJhcnkgaXMgaXRzZWxmIGNvdmVyZWQgYnkgdGhlIGFib3ZlIGxpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QsQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgKi9cbi8qKlxuICogUmVhZCBhIDY0IGJpdCB2YXJpbnQgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogbG93IGJpdHNcbiAqIFsxXTogaGlnaCBiaXRzXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMTc1XG4gKi9cbmZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcbiAgbGV0IGxvd0JpdHMgPSAwO1xuICBsZXQgaGlnaEJpdHMgPSAwO1xuICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGxvd0JpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICB9XG4gIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIC8vIGxhc3QgZm91ciBiaXRzIG9mIHRoZSBmaXJzdCAzMiBiaXQgbnVtYmVyXG4gIGxvd0JpdHMgfD0gKG1pZGRsZUJ5dGUgJiAweDBmKSA8PCAyODtcbiAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgaGlnaEJpdHMgPSAobWlkZGxlQnl0ZSAmIDB4NzApID4+IDQ7XG4gIGlmICgobWlkZGxlQnl0ZSAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICB9XG4gIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbn1cbi8qKlxuICogV3JpdGUgYSA2NCBiaXQgdmFyaW50LCBnaXZlbiBhcyB0d28gSlMgbnVtYmVycywgdG8gdGhlIGdpdmVuIGJ5dGVzIGFycmF5LlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvd3JpdGVyLmpzI0wzNDRcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjR3cml0ZShsbywgaGksIGJ5dGVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjg7IGkgPSBpICsgNykge1xuICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XG4gICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCAmJiBoaSA9PSAwKTtcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHNwbGl0Qml0cyA9IGxvID4+PiAyOCAmIDB4MGYgfCAoaGkgJiAweDA3KSA8PCA0O1xuICBjb25zdCBoYXNNb3JlQml0cyA9ICEoaGkgPj4gMyA9PSAwKTtcbiAgYnl0ZXMucHVzaCgoaGFzTW9yZUJpdHMgPyBzcGxpdEJpdHMgfCAweDgwIDogc3BsaXRCaXRzKSAmIDB4ZmYpO1xuICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgMzE7IGkgPSBpICsgNykge1xuICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCk7XG4gICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcbiAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBieXRlcy5wdXNoKGhpID4+PiAzMSAmIDB4MDEpO1xufVxuLy8gY29uc3RhbnRzIGZvciBiaW5hcnkgbWF0aFxuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSAweDEwMDAwMDAwMDtcbi8qKlxuICogUGFyc2UgZGVjaW1hbCBzdHJpbmcgb2YgNjQgYml0IGludGVnZXIgdmFsdWUgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIGludDY0RnJvbVN0cmluZyhkZWMpIHtcbiAgLy8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24uXG4gIGNvbnN0IG1pbnVzID0gZGVjWzBdID09PSBcIi1cIjtcbiAgaWYgKG1pbnVzKSB7XG4gICAgZGVjID0gZGVjLnNsaWNlKDEpO1xuICB9XG4gIC8vIFdvcmsgNiBkZWNpbWFsIGRpZ2l0cyBhdCBhIHRpbWUsIGFjdGluZyBsaWtlIHdlJ3JlIGNvbnZlcnRpbmcgYmFzZSAxZTZcbiAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXG4gIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICBjb25zdCBiYXNlID0gMWU2O1xuICBsZXQgbG93Qml0cyA9IDA7XG4gIGxldCBoaWdoQml0cyA9IDA7XG4gIGZ1bmN0aW9uIGFkZDFlNmRpZ2l0KGJlZ2luLCBlbmQpIHtcbiAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgICBoaWdoQml0cyAqPSBiYXNlO1xuICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvXG4gICAgaWYgKGxvd0JpdHMgPj0gVFdPX1BXUl8zMl9EQkwpIHtcbiAgICAgIGhpZ2hCaXRzID0gaGlnaEJpdHMgKyAobG93Qml0cyAvIFRXT19QV1JfMzJfREJMIHwgMCk7XG4gICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xuICAgIH1cbiAgfVxuICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gIGFkZDFlNmRpZ2l0KC0xOCwgLTEyKTtcbiAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XG4gIGFkZDFlNmRpZ2l0KC02KTtcbiAgcmV0dXJuIG1pbnVzID8gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSA6IG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gIGxldCBiaXRzID0gbmV3Qml0cyhsbywgaGkpO1xuICAvLyBJZiB3ZSdyZSB0cmVhdGluZyB0aGUgaW5wdXQgYXMgYSBzaWduZWQgdmFsdWUgYW5kIHRoZSBoaWdoIGJpdCBpcyBzZXQsIGRvXG4gIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cbiAgY29uc3QgbmVnYXRpdmUgPSBiaXRzLmhpICYgMHg4MDAwMDAwMDtcbiAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgYml0cyA9IG5lZ2F0ZShiaXRzLmxvLCBiaXRzLmhpKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB1SW50NjRUb1N0cmluZyhiaXRzLmxvLCBiaXRzLmhpKTtcbiAgcmV0dXJuIG5lZ2F0aXZlID8gXCItXCIgKyByZXN1bHQgOiByZXN1bHQ7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5mdW5jdGlvbiB1SW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgKHtcbiAgICBsbyxcbiAgICBoaVxuICB9ID0gdG9VbnNpZ25lZChsbywgaGkpKTtcbiAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxuICAvLyBidWlsdC1pbiBjb252ZXJzaW9ucy5cbiAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSAweDAwMUZGRkZGIEZGRkZGRkZGLCB0aHVzIGFueSBudW1iZXIgd2l0aFxuICAvLyBoaWdoQml0cyA8PSAweDFGRkZGRiBjYW4gYmUgc2FmZWx5IGV4cHJlc3NlZCB3aXRoIGEgZG91YmxlIGFuZCByZXRhaW5cbiAgLy8gaW50ZWdlciBwcmVjaXNpb24uXG4gIC8vIFByb3ZlbiBieTogTnVtYmVyLmlzU2FmZUludGVnZXIoMHgxRkZGRkYgKiAyKiozMiArIDB4RkZGRkZGRkYpID09IHRydWUuXG4gIGlmIChoaSA8PSAweDFGRkZGRikge1xuICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcbiAgfVxuICAvLyBXaGF0IHRoaXMgY29kZSBpcyBkb2luZyBpcyBlc3NlbnRpYWxseSBjb252ZXJ0aW5nIHRoZSBpbnB1dCBudW1iZXIgZnJvbVxuICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gIC8vIG9ubHkgMyAodmVyeSBsYXJnZSkgZGlnaXRzLiBUaG9zZSBkaWdpdHMgYXJlIHRoZW4gdHJpdmlhbCB0byBjb252ZXJ0IHRvXG4gIC8vIGEgYmFzZS0xMCBzdHJpbmcuXG4gIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAvLyAyXjI0ID0gMTY3NzcyMTYgPSAoMSw2Nzc3MjE2KSBpbiBiYXNlLTFlNy5cbiAgLy8gMl40OCA9IDI4MTQ3NDk3NjcxMDY1NiA9ICgyLDgxNDc0OTcsNjcxMDY1NikgaW4gYmFzZS0xZTcuXG4gIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gIC8vIGludGVybWVkaWF0ZSBkaWdpdHMgZG9uJ3Qgb3ZlcmZsb3cuXG4gIGNvbnN0IGxvdyA9IGxvICYgMHhGRkZGRkY7XG4gIGNvbnN0IG1pZCA9IChsbyA+Pj4gMjQgfCBoaSA8PCA4KSAmIDB4RkZGRkZGO1xuICBjb25zdCBoaWdoID0gaGkgPj4gMTYgJiAweEZGRkY7XG4gIC8vIEFzc2VtYmxlIG91ciB0aHJlZSBiYXNlLTFlNyBkaWdpdHMsIGlnbm9yaW5nIGNhcnJpZXMuIFRoZSBtYXhpbXVtXG4gIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgLy8gY2FuIGJlIHN0b3JlZCBpbiBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gIGxldCBkaWdpdEEgPSBsb3cgKyBtaWQgKiA2Nzc3MjE2ICsgaGlnaCAqIDY3MTA2NTY7XG4gIGxldCBkaWdpdEIgPSBtaWQgKyBoaWdoICogODE0NzQ5NztcbiAgbGV0IGRpZ2l0QyA9IGhpZ2ggKiAyO1xuICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgY29uc3QgYmFzZSA9IDEwMDAwMDAwO1xuICBpZiAoZGlnaXRBID49IGJhc2UpIHtcbiAgICBkaWdpdEIgKz0gTWF0aC5mbG9vcihkaWdpdEEgLyBiYXNlKTtcbiAgICBkaWdpdEEgJT0gYmFzZTtcbiAgfVxuICBpZiAoZGlnaXRCID49IGJhc2UpIHtcbiAgICBkaWdpdEMgKz0gTWF0aC5mbG9vcihkaWdpdEIgLyBiYXNlKTtcbiAgICBkaWdpdEIgJT0gYmFzZTtcbiAgfVxuICAvLyBJZiBkaWdpdEMgaXMgMCwgdGhlbiB3ZSBzaG91bGQgaGF2ZSByZXR1cm5lZCBpbiB0aGUgdHJpdmlhbCBjb2RlIHBhdGhcbiAgLy8gYXQgdGhlIHRvcCBmb3Igbm9uLXNhZmUgaW50ZWdlcnMuIEdpdmVuIHRoaXMsIHdlIGNhbiBhc3N1bWUgYm90aCBkaWdpdEJcbiAgLy8gYW5kIGRpZ2l0QSBuZWVkIGxlYWRpbmcgemVyb3MuXG4gIHJldHVybiBkaWdpdEMudG9TdHJpbmcoKSArIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEIpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QSk7XG59XG5mdW5jdGlvbiB0b1Vuc2lnbmVkKGxvLCBoaSkge1xuICByZXR1cm4ge1xuICAgIGxvOiBsbyA+Pj4gMCxcbiAgICBoaTogaGkgPj4+IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIG5ld0JpdHMobG8sIGhpKSB7XG4gIHJldHVybiB7XG4gICAgbG86IGxvIHwgMCxcbiAgICBoaTogaGkgfCAwXG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzI1NpZ25lZF8zMi1iaXRfaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gIGhpZ2hCaXRzID0gfmhpZ2hCaXRzO1xuICBpZiAobG93Qml0cykge1xuICAgIGxvd0JpdHMgPSB+bG93Qml0cyArIDE7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbG93Qml0cyBpcyAwLCB0aGVuIGJpdHdpc2Utbm90IGlzIDB4RkZGRkZGRkYsXG4gICAgLy8gYWRkaW5nIDEgdG8gdGhhdCwgcmVzdWx0cyBpbiAweDEwMDAwMDAwMCwgd2hpY2ggbGVhdmVzXG4gICAgLy8gdGhlIGxvdyBiaXRzIDB4MCBhbmQgc2ltcGx5IGFkZHMgb25lIHRvIHRoZSBoaWdoIGJpdHMuXG4gICAgaGlnaEJpdHMgKz0gMTtcbiAgfVxuICByZXR1cm4gbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIFJldHVybnMgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBkaWdpdDFlNyB3aXRoIGxlYWRpbmcgemVyb3MuXG4gKi9cbmNvbnN0IGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyA9IGRpZ2l0MWU3ID0+IHtcbiAgY29uc3QgcGFydGlhbCA9IFN0cmluZyhkaWdpdDFlNyk7XG4gIHJldHVybiBcIjAwMDAwMDBcIi5zbGljZShwYXJ0aWFsLmxlbmd0aCkgKyBwYXJ0aWFsO1xufTtcbi8qKlxuICogV3JpdGUgYSAzMiBiaXQgdmFyaW50LCBzaWduZWQgb3IgdW5zaWduZWQuIFNhbWUgYXMgYHZhcmludDY0d3JpdGUoMCwgdmFsdWUsIGJ5dGVzKWBcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzFiMTg4MzNmNGYyYTJmNjgxZjRlNGEyNWNkZjNiMGE0MzExNWVjMjYvanMvYmluYXJ5L2VuY29kZXIuanMjTDE0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgIH1cbiAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDEyNyB8IDEyOCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+IDc7XG4gICAgfVxuICAgIGJ5dGVzLnB1c2goMSk7XG4gIH1cbn1cbi8qKlxuICogUmVhZCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDIyMFxuICovXG5mdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIGxldCByZXN1bHQgPSBiICYgMHg3ZjtcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDc7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAxNDtcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDIxO1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xuICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoYiAmIDB4ODApICE9PSAwICYmIHJlYWRCeXRlcyA8IDEwOyByZWFkQnl0ZXMrKykgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICBpZiAoKGIgJiAweDgwKSAhPSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbiAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgcmV0dXJuIHJlc3VsdCA+Pj4gMDtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmZ1bmN0aW9uIG1ha2VJbnQ2NFN1cHBvcnQoKSB7XG4gIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gIC8vIG5vdGUgdGhhdCBTYWZhcmkgMTQgaW1wbGVtZW50cyBCaWdJbnQsIGJ1dCBub3QgdGhlIERhdGFWaWV3IG1ldGhvZHNcbiAgY29uc3Qgb2sgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LmdldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LmdldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5zZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5zZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIHByb2Nlc3MgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fCBwcm9jZXNzLmVudi5CVUZfQklHSU5UX0RJU0FCTEUgIT09IFwiMVwiKTtcbiAgaWYgKG9rKSB7XG4gICAgY29uc3QgTUlOID0gQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksXG4gICAgICBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLFxuICAgICAgVU1JTiA9IEJpZ0ludChcIjBcIiksXG4gICAgICBVTUFYID0gQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHplcm86IEJpZ0ludCgwKSxcbiAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGlmIChiaSA+IE1BWCB8fCBiaSA8IE1JTikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaTtcbiAgICAgIH0sXG4gICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGJpID4gVU1BWCB8fCBiaSA8IFVNSU4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1aW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgfSxcbiAgICAgIGVuYyh2YWx1ZSkge1xuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHVFbmModmFsdWUpIHtcbiAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjKGxvLCBoaSkge1xuICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGR2LmdldEJpZ0ludDY0KDAsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIHVEZWMobG8sIGhpKSB7XG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnVWludDY0KDAsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY29uc3QgYXNzZXJ0SW50NjRTdHJpbmcgPSB2YWx1ZSA9PiBhc3NlcnQoL14tP1swLTldKyQvLnRlc3QodmFsdWUpLCBcImludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICBjb25zdCBhc3NlcnRVSW50NjRTdHJpbmcgPSB2YWx1ZSA9PiBhc3NlcnQoL15bMC05XSskLy50ZXN0KHZhbHVlKSwgXCJ1aW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gIHJldHVybiB7XG4gICAgemVybzogXCIwXCIsXG4gICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBlbmModmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICB9LFxuICAgIHVFbmModmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGludDY0RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICBkZWMobG8sIGhpKSB7XG4gICAgICByZXR1cm4gaW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgIH0sXG4gICAgdURlYyhsbywgaGkpIHtcbiAgICAgIHJldHVybiB1SW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHByb3RvSW50NjQgPSBtYWtlSW50NjRTdXBwb3J0KCk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xudmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAvLyBPcmRlciBpcyB3ZWlyZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQ2NCBpZlxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDY0XCJdID0gNF0gPSBcIlVJTlQ2NFwiO1xuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDMyXCJdID0gNV0gPSBcIklOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQk9PTFwiXSA9IDhdID0gXCJCT09MXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gIC8vIEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCBhbmQgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuIEhvd2V2ZXIsIFByb3RvM1xuICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gIC8vIFRZUEVfR1JPVVAgPSAxMCxcbiAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQllURVNcIl0gPSAxMl0gPSBcIkJZVEVTXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gIC8vIFRZUEVfRU5VTSA9IDE0LFxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQzMlwiXSA9IDE1XSA9IFwiU0ZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQ2NFwiXSA9IDE4XSA9IFwiU0lOVDY0XCI7XG59KShTY2FsYXJUeXBlIHx8IChTY2FsYXJUeXBlID0ge30pKTtcbi8qKlxuICogSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBmaWVsZHMgd2l0aCA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4gKiBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KS5cbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuSlNUeXBlLCB3aGljaCBkZWZpbmVzIEpTX05PUk1BTCxcbiAqIEpTX1NUUklORywgYW5kIEpTX05VTUJFUi4gUHJvdG9idWYtRVMgdXNlcyBCaWdJbnQgYnkgZGVmYXVsdCwgYnV0IHdpbGwgdXNlXG4gKiBTdHJpbmcgaWYgYFtqc3R5cGUgPSBKU19TVFJJTkddYCBpcyBzcGVjaWZpZWQuXG4gKlxuICogYGBgcHJvdG9idWZcbiAqIHVpbnQ2NCBmaWVsZF9hID0gMTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05PUk1BTF07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfU1RSSU5HXTsgLy8gU3RyaW5nXG4gKiBgYGBcbiAqL1xudmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAvKipcbiAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gIC8qKlxuICAgKiBVc2UgSmF2YVNjcmlwdCBTdHJpbmcuXG4gICAqXG4gICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYm90aCBzY2FsYXIgdmFsdWVzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2NhbGFyRXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICAvLyBUaGlzIGNvcnJlY3RseSBtYXRjaGVzIGVxdWFsIHZhbHVlcyBleGNlcHQgQllURVMgYW5kIChwb3NzaWJseSkgNjQtYml0IGludGVnZXJzLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFNwZWNpYWwgY2FzZSBCWVRFUyAtIHdlIG5lZWQgdG8gY29tcGFyZSBlYWNoIGJ5dGUgaW5kaXZpZHVhbGx5XG4gIGlmICh0eXBlID09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgVWludDhBcnJheSkgfHwgIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIDY0LWJpdCBpbnRlZ2VycyAtIHdlIHN1cHBvcnQgbnVtYmVyLCBzdHJpbmcgYW5kIGJpZ2ludCByZXByZXNlbnRhdGlvbi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAvLyBMb29zZSBjb21wYXJpc29uIHdpbGwgbWF0Y2ggYmV0d2VlbiAwbiwgMCBhbmQgXCIwXCIuXG4gICAgICByZXR1cm4gYSA9PSBiO1xuICB9XG4gIC8vIEFueXRoaW5nIHRoYXQgaGFzbid0IGJlZW4gY2F1Z2h0IGJ5IHN0cmljdCBjb21wYXJpc29uIG9yIHNwZWNpYWwgY2FzZWRcbiAgLy8gQllURVMgYW5kIDY0LWJpdCBpbnRlZ2VycyBpcyBub3QgZXF1YWwuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgemVybyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHNjYWxhciB0eXBlLlxuICovXG5mdW5jdGlvbiBzY2FsYXJaZXJvVmFsdWUodHlwZSwgbG9uZ1R5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgIHJldHVybiBsb25nVHlwZSA9PSAwID8gcHJvdG9JbnQ2NC56ZXJvIDogXCIwXCI7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICByZXR1cm4gMC4wO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEhhbmRsZXMgSU5UMzIsIFVJTlQzMiwgU0lOVDMyLCBGSVhFRDMyLCBTRklYRUQzMi5cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgaW5kaXZpZHVhbCBjYXNlcyB0byBzYXZlIGEgZmV3IGJ5dGVzIGNvZGUgc2l6ZS5cbiAgICAgIHJldHVybiAwO1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBmb3IgYSB6ZXJvLXZhbHVlLiBGb3IgZXhhbXBsZSwgYW4gaW50ZWdlciBoYXMgdGhlIHplcm8tdmFsdWUgYDBgLFxuICogYSBib29sZWFuIGlzIGBmYWxzZWAsIGEgc3RyaW5nIGlzIGBcIlwiYCwgYW5kIGJ5dGVzIGlzIGFuIGVtcHR5IFVpbnQ4QXJyYXkuXG4gKlxuICogSW4gcHJvdG8zLCB6ZXJvLXZhbHVlcyBhcmUgbm90IHdyaXR0ZW4gdG8gdGhlIHdpcmUsIHVubGVzcyB0aGUgZmllbGQgaXNcbiAqIG9wdGlvbmFsIG9yIHJlcGVhdGVkLlxuICovXG5mdW5jdGlvbiBpc1NjYWxhclplcm9WYWx1ZSh0eXBlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJcIjtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWUgPT0gMDtcbiAgICAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbnZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAvKipcbiAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICpcbiAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUsIHN1Y2ggYXMgYSBwcm90bzIgZ3JvdXAsIG9yIGEgbWVzc2FnZVxuICAgKiBpbiBlZGl0aW9ucyB3aXRoIG1lc3NhZ2VfZW5jb2RpbmcgPSBERUxJTUlURUQuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAvKipcbiAgICogRW5kIG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXG4gICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcbmNsYXNzIEJpbmFyeVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgZm9yayBzdGF0ZXMuXG4gICAgICovXG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMudGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlciAhPT0gbnVsbCAmJiB0ZXh0RW5jb2RlciAhPT0gdm9pZCAwID8gdGV4dEVuY29kZXIgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuYnVmID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgbGV0IGxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICogb3IgYSBwYWNrZWQgcmVwZWF0ZWQgZmllbGQuXG4gICAqXG4gICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAqL1xuICBmb3JrKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICBjaHVua3M6IHRoaXMuY2h1bmtzLFxuICAgICAgYnVmOiB0aGlzLmJ1ZlxuICAgIH0pO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5idWYgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogSm9pbiB0aGUgbGFzdCBmb3JrLiBXcml0ZSBpdHMgbGVuZ3RoIGFuZCBieXRlcywgdGhlblxuICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgKi9cbiAgam9pbigpIHtcbiAgICAvLyBnZXQgY2h1bmsgb2YgZm9ya1xuICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgLy8gcmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxuICAgIGxldCBwcmV2ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBpZiAoIXByZXYpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUsIGZvcmsgc3RhY2sgZW1wdHlcIik7XG4gICAgdGhpcy5jaHVua3MgPSBwcmV2LmNodW5rcztcbiAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgIC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgdWludDMyKCAoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDAgKWAuXG4gICAqXG4gICAqIEdlbmVyYXRlZCBjb2RlIHNob3VsZCBjb21wdXRlIHRoZSB0YWcgYWhlYWQgb2YgdGltZSBhbmQgY2FsbCBgdWludDMyKClgLlxuICAgKi9cbiAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAqL1xuICByYXcoY2h1bmspIHtcbiAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7XG4gICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIHVpbnQzMih2YWx1ZSkge1xuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxuICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgIH1cbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgKi9cbiAgaW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgKi9cbiAgYm9vbCh2YWx1ZSkge1xuICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKHZhbHVlKSB7XG4gICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmbG9hdGAgdmFsdWUsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBmbG9hdCh2YWx1ZSkge1xuICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGRvdWJsZSh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGZpeGVkMzJgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQzMih2YWx1ZSkge1xuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQzMih2YWx1ZSkge1xuICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgLy8gemlnemFnIGVuY29kZVxuICAgIHZhbHVlID0gKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDA7XG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDY0KHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksXG4gICAgICB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSxcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSxcbiAgICAgIHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQ2NCh2YWx1ZSkge1xuICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksXG4gICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICBzaWduID0gdGMuaGkgPj4gMzEsXG4gICAgICBsbyA9IHRjLmxvIDw8IDEgXiBzaWduLFxuICAgICAgaGkgPSAodGMuaGkgPDwgMSB8IHRjLmxvID4+PiAzMSkgXiBzaWduO1xuICAgIHZhcmludDY0d3JpdGUobG8sIGhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHVpbnQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xuICAgIHZhcmludDY0d3JpdGUodGMubG8sIHRjLmhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNsYXNzIEJpbmFyeVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcbiAgICB0aGlzLnZhcmludDY0ID0gdmFyaW50NjRyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2BcbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxuICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIHRoaXMubGVuID0gYnVmLmxlbmd0aDtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy50ZXh0RGVjb2RlciA9IHRleHREZWNvZGVyICE9PSBudWxsICYmIHRleHREZWNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RGVjb2RlciA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgKi9cbiAgdGFnKCkge1xuICAgIGxldCB0YWcgPSB0aGlzLnVpbnQzMigpLFxuICAgICAgZmllbGRObyA9IHRhZyA+Pj4gMyxcbiAgICAgIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICBpZiAoZmllbGRObyA8PSAwIHx8IHdpcmVUeXBlIDwgMCB8fCB3aXJlVHlwZSA+IDUpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdGFnOiBmaWVsZCBubyBcIiArIGZpZWxkTm8gKyBcIiB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gIH1cbiAgLyoqXG4gICAqIFNraXAgb25lIGVsZW1lbnQgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgKlxuICAgKiBXaGVuIHNraXBwaW5nIFN0YXJ0R3JvdXAsIHByb3ZpZGUgdGhlIHRhZ3MgZmllbGQgbnVtYmVyIHRvIGNoZWNrIGZvclxuICAgKiBtYXRjaGluZyBmaWVsZCBudW1iZXIgaW4gdGhlIEVuZEdyb3VwIHRhZy5cbiAgICovXG4gIHNraXAod2lyZVR5cGUsIGZpZWxkTm8pIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0NjQ6XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdpcmVUeXBlLlN0YXJ0R3JvdXA6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBjb25zdCBbZm4sIHd0XSA9IHRoaXMudGFnKCk7XG4gICAgICAgICAgaWYgKHd0ID09PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkTm8gIT09IHVuZGVmaW5lZCAmJiBmbiAhPT0gZmllbGRObykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZCBncm91cCB0YWdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5za2lwKHd0LCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIH1cbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAqL1xuICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIoKSB7XG4gICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgLy8gZGVjb2RlIHppZ3phZ1xuICAgIHJldHVybiB6emUgPj4+IDEgXiAtKHp6ZSAmIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGludDY0YCBmaWVsZCwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIGludDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHVpbnQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQ2NCgpIHtcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICBsZXQgcyA9IC0obG8gJiAxKTtcbiAgICBsbyA9IChsbyA+Pj4gMSB8IChoaSAmIDEpIDw8IDMxKSBeIHM7XG4gICAgaGkgPSBoaSA+Pj4gMSBeIHM7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKGxvLCBoaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2woKSB7XG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDMyYCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGZsb2F0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDY0KCh0aGlzLnBvcyArPSA4KSAtIDgsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGJ5dGVzYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKCkge1xuICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLFxuICAgICAgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVuc2lvbiB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZUV4dGVuc2lvbihydW50aW1lLCB0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XG4gIGxldCBmaTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlTmFtZSxcbiAgICBleHRlbmRlZSxcbiAgICBnZXQgZmllbGQoKSB7XG4gICAgICBpZiAoIWZpKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0eXBlb2YgZmllbGQgPT0gXCJmdW5jdGlvblwiID8gZmllbGQoKSA6IGZpZWxkO1xuICAgICAgICBpLm5hbWUgPSB0eXBlTmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICAgIGkuanNvbk5hbWUgPSBcIltcIi5jb25jYXQodHlwZU5hbWUsIFwiXVwiKTtcbiAgICAgICAgZmkgPSBydW50aW1lLnV0aWwubmV3RmllbGRMaXN0KFtpXSkubGlzdCgpWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpO1xuICAgIH0sXG4gICAgcnVudGltZVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb250YWluZXIgdGhhdCBhbGxvd3MgdXMgdG8gcmVhZCBleHRlbnNpb24gZmllbGRzIGludG8gaXQgd2l0aCB0aGVcbiAqIHNhbWUgbG9naWMgYXMgcmVndWxhciBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHRlbnNpb24pIHtcbiAgY29uc3QgbG9jYWxOYW1lID0gZXh0ZW5zaW9uLmZpZWxkLmxvY2FsTmFtZTtcbiAgY29uc3QgY29udGFpbmVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29udGFpbmVyW2xvY2FsTmFtZV0gPSBpbml0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uKTtcbiAgcmV0dXJuIFtjb250YWluZXIsICgpID0+IGNvbnRhaW5lcltsb2NhbE5hbWVdXTtcbn1cbmZ1bmN0aW9uIGluaXRFeHRlbnNpb25GaWVsZChleHQpIHtcbiAgY29uc3QgZmllbGQgPSBleHQuZmllbGQ7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoZmllbGQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZpZWxkLmRlZmF1bHQ7XG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHJldHVybiBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlQsIGZpZWxkLkwpO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgIGNvbnN0IFQgPSBmaWVsZC5ULFxuICAgICAgICB2YWx1ZSA9IG5ldyBUKCk7XG4gICAgICByZXR1cm4gVC5maWVsZFdyYXBwZXIgPyBULmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjYXNlIFwibWFwXCI6XG4gICAgICB0aHJvdyBcIm1hcCBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGV4dGVuc2lvbnNcIjtcbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZmlsdGVyIHVua25vd24gZmllbGRzLCBvcHRpbWl6ZWQgYmFzZWQgb24gZmllbGQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyVW5rbm93bkZpZWxkcyh1bmtub3duRmllbGRzLCBmaWVsZCkge1xuICBpZiAoIWZpZWxkLnJlcGVhdGVkICYmIChmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikpIHtcbiAgICAvLyBzaW5ndWxhciBzY2FsYXIgZmllbGRzIGRvIG5vdCBtZXJnZSwgd2UgcGljayB0aGUgbGFzdFxuICAgIGZvciAobGV0IGkgPSB1bmtub3duRmllbGRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodW5rbm93bkZpZWxkc1tpXS5ubyA9PSBmaWVsZC5ubykge1xuICAgICAgICByZXR1cm4gW3Vua25vd25GaWVsZHNbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVua25vd25GaWVsZHMuZmlsdGVyKHVmID0+IHVmLm5vID09PSBmaWVsZC5ubyk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKykgZGVjVGFibGVbZW5jVGFibGVbaV0uY2hhckNvZGVBdCgwKV0gPSBpO1xuLy8gc3VwcG9ydCBiYXNlNjR1cmwgdmFyaWFudHNcbmRlY1RhYmxlW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIitcIik7XG5kZWNUYWJsZVtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIvXCIpO1xuY29uc3QgcHJvdG9CYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXG4gICAqXG4gICAqIC0gaWdub3JlcyB3aGl0ZS1zcGFjZSwgaW5jbHVkaW5nIGxpbmUgYnJlYWtzIGFuZCB0YWJzXG4gICAqIC0gYWxsb3dzIGlubmVyIHBhZGRpbmcgKGNhbiBkZWNvZGUgY29uY2F0ZW5hdGVkIGJhc2U2NCBzdHJpbmdzKVxuICAgKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICAgKiAtIHVuZGVyc3RhbmRzIGJhc2U2NHVybCBlbmNvZGluZzpcbiAgICogICBcIi1cIiBpbnN0ZWFkIG9mIFwiK1wiLFxuICAgKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gICAqICAgbm8gcGFkZGluZ1xuICAgKi9cbiAgZGVjKGJhc2U2NFN0cikge1xuICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcbiAgICBsZXQgZXMgPSBiYXNlNjRTdHIubGVuZ3RoICogMyAvIDQ7XG4gICAgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMl0gPT0gXCI9XCIpIGVzIC09IDI7ZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSBcIj1cIikgZXMgLT0gMTtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksXG4gICAgICBieXRlUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXlcbiAgICAgIGdyb3VwUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgYixcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgcCA9IDA7IC8vIHByZXZpb3VzIGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChiYXNlNjRTdHJbaV0pIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgY2FzZSBcIlxcdFwiOlxuICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAvLyBza2lwIHdoaXRlLXNwYWNlLCBhbmQgcGFkZGluZ1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSBwIDw8IDIgfCAoYiAmIDQ4KSA+PiA0O1xuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDE1KSA8PCA0IHwgKGIgJiA2MCkgPj4gMjtcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAzKSA8PCA2IHwgYjtcbiAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncm91cFBvcyA9PSAxKSB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIGJ5dGVQb3MpO1xuICB9LFxuICAvKipcbiAgICogRW5jb2RlIGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gICAqL1xuICBlbmMoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gXCJcIixcbiAgICAgIGdyb3VwUG9zID0gMCxcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxuICAgICAgYixcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYiA9IGJ5dGVzW2ldO1xuICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgPj4gMl07XG4gICAgICAgICAgcCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNF07XG4gICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDZdO1xuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiICYgNjNdO1xuICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXG4gICAgaWYgKGdyb3VwUG9zKSB7XG4gICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcF07XG4gICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgYmFzZTY0ICs9IFwiPVwiO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9XG59O1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXRyaWV2ZSBhbiBleHRlbnNpb24gdmFsdWUgZnJvbSBhIG1lc3NhZ2UuXG4gKlxuICogVGhlIGZ1bmN0aW9uIG5ldmVyIHJldHVybnMgdW5kZWZpbmVkLiBVc2UgaGFzRXh0ZW5zaW9uKCkgdG8gY2hlY2sgd2hldGhlciBhblxuICogZXh0ZW5zaW9uIGlzIHNldC4gSWYgdGhlIGV4dGVuc2lvbiBpcyBub3Qgc2V0LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gKiBkZWZhdWx0IHZhbHVlIChpZiBvbmUgd2FzIHNwZWNpZmllZCBpbiB0aGUgcHJvdG9idWYgc291cmNlKSwgb3IgdGhlIHplcm8gdmFsdWVcbiAqIChmb3IgZXhhbXBsZSBgMGAgZm9yIG51bWVyaWMgdHlwZXMsIGBbXWAgZm9yIHJlcGVhdGVkIGV4dGVuc2lvbiBmaWVsZHMsIGFuZFxuICogYW4gZW1wdHkgbWVzc2FnZSBpbnN0YW5jZSBmb3IgbWVzc2FnZSBmaWVsZHMpLlxuICpcbiAqIEV4dGVuc2lvbnMgYXJlIHN0b3JlZCBhcyB1bmtub3duIGZpZWxkcyBvbiBhIG1lc3NhZ2UuIFRvIG11dGF0ZSBhbiBleHRlbnNpb25cbiAqIHZhbHVlLCBtYWtlIHN1cmUgdG8gc3RvcmUgdGhlIG5ldyB2YWx1ZSB3aXRoIHNldEV4dGVuc2lvbigpIGFmdGVyIG11dGF0aW5nLlxuICpcbiAqIElmIHRoZSBleHRlbnNpb24gZG9lcyBub3QgZXh0ZW5kIHRoZSBnaXZlbiBtZXNzYWdlLCBhbiBlcnJvciBpcyByYWlzZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24sIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RXh0ZW5kZWUoZXh0ZW5zaW9uLCBtZXNzYWdlKTtcbiAgY29uc3Qgb3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgdWZzID0gZmlsdGVyVW5rbm93bkZpZWxkcyhtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSwgZXh0ZW5zaW9uLmZpZWxkKTtcbiAgY29uc3QgW2NvbnRhaW5lciwgZ2V0XSA9IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHRlbnNpb24pO1xuICBmb3IgKGNvbnN0IHVmIG9mIHVmcykge1xuICAgIGV4dGVuc2lvbi5ydW50aW1lLmJpbi5yZWFkRmllbGQoY29udGFpbmVyLCBvcHQucmVhZGVyRmFjdG9yeSh1Zi5kYXRhKSwgZXh0ZW5zaW9uLmZpZWxkLCB1Zi53aXJlVHlwZSwgb3B0KTtcbiAgfVxuICByZXR1cm4gZ2V0KCk7XG59XG4vKipcbiAqIFNldCBhbiBleHRlbnNpb24gdmFsdWUgb24gYSBtZXNzYWdlLiBJZiB0aGUgbWVzc2FnZSBhbHJlYWR5IGhhcyBhIHZhbHVlIGZvclxuICogdGhpcyBleHRlbnNpb24sIHRoZSB2YWx1ZSBpcyByZXBsYWNlZC5cbiAqXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICovXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uLCB2YWx1ZSwgb3B0aW9ucykge1xuICBhc3NlcnRFeHRlbmRlZShleHRlbnNpb24sIG1lc3NhZ2UpO1xuICBjb25zdCByZWFkT3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3Qgd3JpdGVPcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgaWYgKGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pKSB7XG4gICAgY29uc3QgdWZzID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkuZmlsdGVyKHVmID0+IHVmLm5vICE9IGV4dGVuc2lvbi5maWVsZC5ubyk7XG4gICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4uZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSk7XG4gICAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcbiAgICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIHVmLm5vLCB1Zi53aXJlVHlwZSwgdWYuZGF0YSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdyaXRlciA9IHdyaXRlT3B0LndyaXRlckZhY3RvcnkoKTtcbiAgbGV0IGYgPSBleHRlbnNpb24uZmllbGQ7XG4gIC8vIEltcGxpY2l0IHByZXNlbmNlIGRvZXMgbm90IGFwcGx5IHRvIGV4dGVuc2lvbnMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2lzc3Vlcy84MjM0XG4gIC8vIFdlIHBhdGNoIHRoZSBmaWVsZCBpbmZvIHRvIHVzZSBleHBsaWNpdCBwcmVzZW5jZTpcbiAgaWYgKCFmLm9wdCAmJiAhZi5yZXBlYXRlZCAmJiAoZi5raW5kID09IFwiZW51bVwiIHx8IGYua2luZCA9PSBcInNjYWxhclwiKSkge1xuICAgIGYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbi5maWVsZCksIHtcbiAgICAgIG9wdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGV4dGVuc2lvbi5ydW50aW1lLmJpbi53cml0ZUZpZWxkKGYsIHZhbHVlLCB3cml0ZXIsIHdyaXRlT3B0KTtcbiAgY29uc3QgcmVhZGVyID0gcmVhZE9wdC5yZWFkZXJGYWN0b3J5KHdyaXRlci5maW5pc2goKSk7XG4gIHdoaWxlIChyZWFkZXIucG9zIDwgcmVhZGVyLmxlbikge1xuICAgIGNvbnN0IFtubywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSwgbm8pO1xuICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSk7XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBleHRlbnNpb24gaXMgc2V0IG9uIGEgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xuICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICByZXR1cm4gZXh0ZW5zaW9uLmV4dGVuZGVlLnR5cGVOYW1lID09PSBtZXNzYWdlVHlwZS50eXBlTmFtZSAmJiAhIW1lc3NhZ2VUeXBlLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLmZpbmQodWYgPT4gdWYubm8gPT0gZXh0ZW5zaW9uLmZpZWxkLm5vKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSkge1xuICBhc3NlcnQoZXh0ZW5zaW9uLmV4dGVuZGVlLnR5cGVOYW1lID09IG1lc3NhZ2UuZ2V0VHlwZSgpLnR5cGVOYW1lLCBcImV4dGVuc2lvbiBcIi5jb25jYXQoZXh0ZW5zaW9uLnR5cGVOYW1lLCBcIiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIG1lc3NhZ2UgXCIpLmNvbmNhdChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUpKTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWVsZCBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGlzRmllbGRTZXQoZmllbGQsIHRhcmdldCkge1xuICBjb25zdCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXS5sZW5ndGggPiAwO1xuICB9XG4gIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHJldHVybiB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXS5jYXNlID09PSBsb2NhbE5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xuICAgICAgICAvLyBleHBsaWNpdCBwcmVzZW5jZVxuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIC8vIGltcGxpY2l0IHByZXNlbmNlXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcImVudW1cIikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IGZpZWxkLlQudmFsdWVzWzBdLm5vO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFpc1NjYWxhclplcm9WYWx1ZShmaWVsZC5ULCB0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXRbbG9jYWxOYW1lXSkubGVuZ3RoID4gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgfVxufVxuLyoqXG4gKiBSZXNldHMgdGhlIGZpZWxkLCBzbyB0aGF0IGlzRmllbGRTZXQoKSB3aWxsIHJldHVybiBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgY29uc3QgaW1wbGljaXRQcmVzZW5jZSA9ICFmaWVsZC5vcHQgJiYgIWZpZWxkLnJlcTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBbXTtcbiAgfSBlbHNlIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ge1xuICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBmaWVsZC5ULnZhbHVlc1swXS5ubyA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gaW1wbGljaXRQcmVzZW5jZSA/IHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhbnkgc3VidHlwZSBvZiBNZXNzYWdlIG9yIGlzIGEgc3BlY2lmaWNcbiAqIE1lc3NhZ2UgYnkgcGFzc2luZyB0aGUgdHlwZS5cbiAqXG4gKiBKdXN0IGxpa2UgYGluc3RhbmNlb2ZgLCBgaXNNZXNzYWdlYCBuYXJyb3dzIHRoZSB0eXBlLiBUaGUgYWR2YW50YWdlIG9mXG4gKiBgaXNNZXNzYWdlYCBpcyB0aGF0IGl0IGNvbXBhcmVzIGlkZW50aXR5IGJ5IHRoZSBtZXNzYWdlIHR5cGUgbmFtZSwgbm90IGJ5XG4gKiBjbGFzcyBpZGVudGl0eS4gVGhpcyBtYWtlcyBpdCByb2J1c3QgYWdhaW5zdCB0aGUgZHVhbCBwYWNrYWdlIGhhemFyZCBhbmRcbiAqIHNpbWlsYXIgc2l0dWF0aW9ucywgd2hlcmUgdGhlIHNhbWUgbWVzc2FnZSBpcyBkdXBsaWNhdGVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgX21vc3RseV8gZXF1aXZhbGVudCB0byB0aGUgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLiBGb3JcbiAqIGV4YW1wbGUsIGBpc01lc3NhZ2UoZm9vLCBNeU1lc3NhZ2UpYCBpcyB0aGUgc2FtZSBhcyBgZm9vIGluc3RhbmNlb2YgTXlNZXNzYWdlYCxcbiAqIGFuZCBgaXNNZXNzYWdlKGZvbylgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNZXNzYWdlYC4gSW4gbW9zdCBjYXNlcyxcbiAqIGBpc01lc3NhZ2VgIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBgaW5zdGFuY2VvZmAuXG4gKlxuICogSG93ZXZlciwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgYGlzTWVzc2FnZWAgZG9lcyBub3QgdXNlIGNsYXNzIGlkZW50aXR5LCB0aGVyZVxuICogYXJlIHN1YnRsZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgZnVuY3Rpb24gYW5kIGBpbnN0YW5jZW9mYC4gTm90YWJseSxcbiAqIGNhbGxpbmcgYGlzTWVzc2FnZWAgb24gYW4gZXhwbGljaXQgdHlwZSBvZiBNZXNzYWdlIHdpbGwgcmV0dXJuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBpc01lc3NhZ2UoYXJnLCB0eXBlKSB7XG4gIGlmIChhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyAhPSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWVzc2FnZS5wcm90b3R5cGUpLmV2ZXJ5KG0gPT4gbSBpbiBhcmcgJiYgdHlwZW9mIGFyZ1ttXSA9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFjdHVhbFR5cGUgPSBhcmcuZ2V0VHlwZSgpO1xuICBpZiAoYWN0dWFsVHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsVHlwZSAhPSBcImZ1bmN0aW9uXCIgfHwgIShcInR5cGVOYW1lXCIgaW4gYWN0dWFsVHlwZSkgfHwgdHlwZW9mIGFjdHVhbFR5cGUudHlwZU5hbWUgIT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFjdHVhbFR5cGUudHlwZU5hbWUgPT0gdHlwZS50eXBlTmFtZTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZnVuY3Rpb24gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gIGlmIChpc01lc3NhZ2UodmFsdWUpIHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdHlwZS5maWVsZFdyYXBwZXIud3JhcEZpZWxkKHZhbHVlKTtcbn1cbih7XG4gIFwiZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlXCI6IFNjYWxhclR5cGUuRE9VQkxFLFxuICBcImdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlXCI6IFNjYWxhclR5cGUuRkxPQVQsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5JTlQ2NCxcbiAgXCJnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UNjQsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5JTlQzMixcbiAgXCJnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UMzIsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZVwiOiBTY2FsYXJUeXBlLkJPT0wsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlXCI6IFNjYWxhclR5cGUuU1RSSU5HLFxuICBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCI6IFNjYWxhclR5cGUuQllURVNcbn0pO1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gIGVudW1Bc0ludGVnZXI6IGZhbHNlLFxuICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gIHByZXR0eVNwYWNlczogMFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyQxKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zJDEob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuY29uc3QgdG9rZW5OdWxsID0gU3ltYm9sKCk7XG5jb25zdCB0b2tlbklnbm9yZWRVbmtub3duRW51bSA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXQoKSB7XG4gIHJldHVybiB7XG4gICAgbWFrZVJlYWRPcHRpb25zOiBtYWtlUmVhZE9wdGlvbnMkMSxcbiAgICBtYWtlV3JpdGVPcHRpb25zOiBtYWtlV3JpdGVPcHRpb25zJDEsXG4gICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbikpKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgY29uc3Qgb25lb2ZTZWVuID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcbiAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kSnNvbk5hbWUoanNvbktleSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgICAgLy8gc2VlIGNvbmZvcm1hbmNlIHRlc3QgUmVxdWlyZWQuUHJvdG8zLkpzb25JbnB1dC5PbmVvZkZpZWxkTnVsbHtGaXJzdCxTZWNvbmR9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2Vlbi5nZXQoZmllbGQub25lb2YpO1xuICAgICAgICAgICAgaWYgKHNlZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogbXVsdGlwbGUga2V5cyBmb3Igb25lb2YgXFxcIlwiKS5jb25jYXQoZmllbGQub25lb2YubmFtZSwgXCJcXFwiIHByZXNlbnQ6IFxcXCJcIikuY29uY2F0KHNlZW4sIFwiXFxcIiwgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZW9mU2Vlbi5zZXQoZmllbGQub25lb2YsIGpzb25LZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkRmllbGQkMShtZXNzYWdlLCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCB0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKSAmJiBqc29uS2V5LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGpzb25LZXkuZW5kc1dpdGgoXCJdXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKGpzb25LZXkuc3Vic3RyaW5nKDEsIGpzb25LZXkubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgaWYgKGV4dCAmJiBleHQuZXh0ZW5kZWUudHlwZU5hbWUgPT0gdHlwZS50eXBlTmFtZSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0KTtcbiAgICAgICAgICAgICAgcmVhZEZpZWxkJDEoY29udGFpbmVyLCBqc29uVmFsdWUsIGV4dC5maWVsZCwgb3B0aW9ucywgZXh0KTtcbiAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucy9CaW5hcnlXcml0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgIC8vIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93biBiaW5hcnkgcmVhZGVyIGFuZCB3cml0ZXIgZmFjdG9yaWVzXG4gICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgc2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCwgZ2V0KCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBrZXkgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiIGlzIHVua25vd25cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgbGV0IGZpZWxkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XG4gICAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgICB0aHJvdyBcInJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuRW1pdEZpZWxkRGVmYXVsdFZhbHVlKGZpZWxkKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZiA/IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXS52YWx1ZSA6IG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXTtcbiAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XG4gICAgICAgIGlmIChyZWdpc3RyeSA9PT0gbnVsbCB8fCByZWdpc3RyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcikge1xuICAgICAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgY29uc3QgZXh0ID0gcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcih0eXBlLnR5cGVOYW1lLCB1Zi5ubyk7XG4gICAgICAgICAgICBpZiAoZXh0ICYmIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHQpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHBhc3Mgb24gdGhlIG9wdGlvbnMgYXMgQmluYXJ5UmVhZE9wdGlvbnMsIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93blxuICAgICAgICAgICAgICAvLyBiaW5hcnkgcmVhZGVyIGZhY3RvcnkgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZXh0LmZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGpzb25bZXh0LmZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBtID0gZmllbGQgPyBcImNhbm5vdCBlbmNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgdG8gSlNPTlwiKSA6IFwiY2Fubm90IGVuY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiB0byBKU09OXCIpO1xuICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBcIjogXCIuY29uY2F0KHIpIDogXCJcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlKSB7XG4gICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZC4gRm9yIGJhY2t3YXJkcy1cbiAgICAgIC8vIGNvbXBhdGliaWxpdHksIHdlIHN1cHBvcnQgdGhlIG9sZCBmb3JtIHRoYXQgaXMgcGFydCBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgLy8gdGhyb3VnaCB0aGUgaW50ZXJmYWNlIEpzb25Gb3JtYXQuXG4gICAgICByZXR1cm4gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlICE9PSBudWxsICYmIGxvbmdUeXBlICE9PSB2b2lkIDAgPyBsb25nVHlwZSA6IExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgfSxcbiAgICB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSwgZW1pdERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxuICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZW1pdERlZmF1bHRWYWx1ZXMgfHwgaXNTY2FsYXJaZXJvVmFsdWUodHlwZSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogXCJcXFwiXCIuY29uY2F0KGpzb24uc3BsaXQoJ1wiJykuam9pbignXFxcXFwiJyksIFwiXFxcIlwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyhqc29uKTtcbiAgfVxufVxuLy8gUmVhZCBhIEpTT04gdmFsdWUgZm9yIGEgZmllbGQuXG4vLyBUaGUgXCJwYXJlbnRUeXBlXCIgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIHByb3ZpZGUgY29udGV4dCBpbiBlcnJvcnMuXG5mdW5jdGlvbiByZWFkRmllbGQkMSh0YXJnZXQsIGpzb25WYWx1ZSwgZmllbGQsIG9wdGlvbnMsIHBhcmVudFR5cGUpIHtcbiAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgYXNzZXJ0KGZpZWxkLmtpbmQgIT0gXCJtYXBcIik7XG4gICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICBpZiAoanNvbkl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKGZpZWxkLlQuZnJvbUpzb24oanNvbkl0ZW0sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB0b2tlbklnbm9yZWRVbmtub3duRW51bSkge1xuICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChlbnVtVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKHJlYWRTY2FsYXIkMShmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCwgdHJ1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uSXRlbSkpO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbFwiKSk7XG4gICAgICB9XG4gICAgICBsZXQga2V5O1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5ID0gcmVhZE1hcEtleShmaWVsZC5LLCBqc29uTWFwS2V5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xuICAgICAgICAgIGlmIChlbnVtVmFsdWUgIT09IHRva2VuSWdub3JlZFVua25vd25FbnVtKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFyZ2V0TWFwW2tleV0gPSByZWFkU2NhbGFyJDEoZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcbiAgICAgICAgY2FzZTogbG9jYWxOYW1lXG4gICAgICB9O1xuICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBtZXNzYWdlVHlwZS50eXBlTmFtZSAhPSBcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKGlzTWVzc2FnZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFZhbHVlLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBjdXJyZW50VmFsdWUgPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCBmYWxzZSk7XG4gICAgICAgIHN3aXRjaCAoZW51bVZhbHVlKSB7XG4gICAgICAgICAgY2FzZSB0b2tlbk51bGw6XG4gICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0b2tlbklnbm9yZWRVbmtub3duRW51bTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNjYWxhclZhbHVlID0gcmVhZFNjYWxhciQxKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCwgZmFsc2UpO1xuICAgICAgICAgIHN3aXRjaCAoc2NhbGFyVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gc2NhbGFyVmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZE1hcEtleSh0eXBlLCBqc29uKSB7XG4gIGlmICh0eXBlID09PSBTY2FsYXJUeXBlLkJPT0wpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAoanNvbikge1xuICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAganNvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgIGpzb24gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWFkU2NhbGFyJDEodHlwZSwganNvbiwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICBpZiAobnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuTnVsbDtcbiAgfVxuICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgLy8gdGhyb3VnaCBpcyByZWdhcmRlZCBhcyBhIGZhaWx1cmUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuRkxPQVQpIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGxldCBpbnQzMjtcbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKSBpbnQzMiA9IGpzb247ZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGludDMyID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIgfHwgdHlwZSA9PSBTY2FsYXJUeXBlLkZJWEVEMzIpIGFzc2VydFVJbnQzMihpbnQzMik7ZWxzZSBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICByZXR1cm4gaW50MzI7XG4gICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpIGJyZWFrO1xuICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIGNvbnN0IHVMb25nID0gcHJvdG9JbnQ2NC51UGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpIGJyZWFrO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgLy8gc3RyaW5nOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXG4gICAgICAvLyBXZSB2YWxpZGF0ZSB3aXRoIGVuY29kZVVSSUNvbXBvbmVudCwgd2hpY2ggYXBwZWFycyB0byBiZSB0aGUgZmFzdGVzdCB3aWRlbHkgYXZhaWxhYmxlIG9wdGlvbi5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBVVEY4XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICBpZiAoanNvbiA9PT0gXCJcIikgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiByZWFkRW51bSh0eXBlLCBqc29uLCBpZ25vcmVVbmtub3duRmllbGRzLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgICAgcmV0dXJuIDA7IC8vIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUuTlVMTF9WQUxVRSA9IDBcbiAgICB9XG4gICAgcmV0dXJuIG51bGxBc1plcm9WYWx1ZSA/IHR5cGUudmFsdWVzWzBdLm5vIDogdG9rZW5OdWxsO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5ubztcbiAgICAgIH1cbiAgICAgIGlmIChpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0b2tlbklnbm9yZWRVbmtub3duRW51bTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZW51bSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XG59XG4vLyBEZWNpZGUgd2hldGhlciBhbiB1bnNldCBmaWVsZCBzaG91bGQgYmUgZW1pdHRlZCB3aXRoIEpTT04gd3JpdGUgb3B0aW9uIGBlbWl0RGVmYXVsdFZhbHVlc2BcbmZ1bmN0aW9uIGNhbkVtaXRGaWVsZERlZmF1bHRWYWx1ZShmaWVsZCkge1xuICBpZiAoZmllbGQucmVwZWF0ZWQgfHwgZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgLy8gbWFwcyBhcmUge30sIHJlcGVhdGVkIGZpZWxkcyBhcmUgW11cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAvLyBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIGVtaXR0ZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpIHtcbiAgICAvLyBzaW5ndWxhciBtZXNzYWdlIGZpZWxkIGFyZSBhbGxvd2VkIHRvIGVtaXQgSlNPTiBudWxsLCBidXQgd2UgZG8gbm90XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgaWYgKGZpZWxkLm9wdCB8fCBmaWVsZC5yZXEpIHtcbiAgICAvLyB0aGUgZmllbGQgdXNlcyBleHBsaWNpdCBwcmVzZW5jZSwgc28gd2UgY2Fubm90IGVtaXQgYSB6ZXJvIHZhbHVlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gd3JpdGVGaWVsZCQxKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlU2NhbGFyJDEoZmllbGQuVi5ULCBlbnRyeVZhbHVlKTsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGVudHJpZXMubGVuZ3RoID4gMCA/IGpzb25PYmogOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVTY2FsYXIkMShmaWVsZC5ULCB2YWx1ZVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh2YWx1ZVtpXS50b0pzb24ob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDAgPyBqc29uQXJyIDogdW5kZWZpbmVkO1xuICB9XG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKGZpZWxkLlQsIHZhbHVlKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgcmV0dXJuIHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVudW1Bc0ludGVnZXIpIHtcbiAgdmFyIF9hO1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiAoX2EgPSB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWwubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWU7IC8vIGlmIHdlIGRvbid0IGtub3cgdGhlIGVudW0gdmFsdWUsIGp1c3QgcmV0dXJuIHRoZSBudW1iZXJcbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyJDEodHlwZSwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgLy8gYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkgcmV0dXJuIFwiTmFOXCI7XG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgICAgcmV0dXJuIHByb3RvQmFzZTY0LmVuYyh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gIHJlYWRVbmtub3duRmllbGRzOiB0cnVlLFxuICByZWFkZXJGYWN0b3J5OiBieXRlcyA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgYmluYXJ5IGRhdGEuXG5jb25zdCB3cml0ZURlZmF1bHRzID0ge1xuICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXG4gIHdyaXRlckZhY3Rvcnk6ICgpID0+IG5ldyBCaW5hcnlXcml0ZXIoKVxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IHJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDogd3JpdGVEZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXQoKSB7XG4gIHJldHVybiB7XG4gICAgbWFrZVJlYWRPcHRpb25zLFxuICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgbGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIH0sXG4gICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgfSxcbiAgICB3cml0ZVVua25vd25GaWVsZHMobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBjb25zdCBtID0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IGMgPSBtW3Vua25vd25GaWVsZHNTeW1ib2xdO1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGMpIHtcbiAgICAgICAgICB3cml0ZXIudGFnKGYubm8sIGYud2lyZVR5cGUpLnJhdyhmLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1bdW5rbm93bkZpZWxkc1N5bWJvbF0pKSB7XG4gICAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0ucHVzaCh7XG4gICAgICAgIG5vLFxuICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfSxcbiAgICByZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGxlbmd0aE9yRW5kVGFnRmllbGRObywgb3B0aW9ucywgZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICBjb25zdCBlbmQgPSBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aE9yRW5kVGFnRmllbGRObztcbiAgICAgIGxldCBmaWVsZE5vLCB3aXJlVHlwZTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgIGlmIChkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgPT09IHRydWUgJiYgd2lyZVR5cGUgPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmQoZmllbGRObyk7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUsIGZpZWxkTm8pO1xuICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZEZpZWxkKG1lc3NhZ2UsIHJlYWRlciwgZmllbGQsIHdpcmVUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgJiYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIHdpcmVUeXBlICE9IFdpcmVUeXBlLkVuZEdyb3VwIHx8IGZpZWxkTm8gIT09IGxlbmd0aE9yRW5kVGFnRmllbGRObykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmQgZ3JvdXAgdGFnXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVhZEZpZWxkLFxuICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xuICAgICAgICBpZiAoIWlzRmllbGRTZXQoZmllbGQsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBiaW5hcnk6IHJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLm9uZW9mID8gbWVzc2FnZVtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdLnZhbHVlIDogbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdO1xuICAgICAgICB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcykge1xuICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgIC8vIFRoZSBiZWhhdmlvciBvZiBvdXIgaW50ZXJuYWwgZnVuY3Rpb24gaGFzIGNoYW5nZWQsIGl0IGRvZXMgbm8gbG9uZ2VyXG4gICAgICAvLyBhY2NlcHQgYHVuZGVmaW5lZGAgdmFsdWVzIGZvciBzaW5ndWxhciBzY2FsYXIgYW5kIG1hcC5cbiAgICAgIC8vIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mXG4gICAgICAvLyB0aGUgcHVibGljIEFQSSB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgQmluYXJ5Rm9ybWF0LlxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRGaWVsZCh0YXJnZXQsXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gYGFueWAgaXMgdGhlIGJlc3QgY2hvaWNlIGZvciBkeW5hbWljIGFjY2Vzc1xucmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICByZXBlYXRlZCxcbiAgICBsb2NhbE5hbWVcbiAgfSA9IGZpZWxkO1xuICBpZiAoZmllbGQub25lb2YpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICBpZiAodGFyZ2V0LmNhc2UgIT0gbG9jYWxOYW1lKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0LnZhbHVlO1xuICAgIH1cbiAgICB0YXJnZXQuY2FzZSA9IGxvY2FsTmFtZTtcbiAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcInNjYWxhclwiOlxuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICBjb25zdCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgbGV0IHJlYWQgPSByZWFkU2NhbGFyO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XG4gICAgICAgIHJlYWQgPSByZWFkU2NhbGFyTFRTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGlzUGFja2VkID0gd2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTO1xuICAgICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKSB7XG4gICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5wdXNoKHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc01lc3NhZ2UodGFyZ2V0W2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIHRhcmdldFtsb2NhbE5hbWVdLCBvcHRpb25zLCBmaWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMsIGZpZWxkKTtcbiAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZiAmJiAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICB0YXJnZXRbbG9jYWxOYW1lXVttYXBLZXldID0gbWFwVmFsO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxuZnVuY3Rpb24gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMsIGZpZWxkKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICBjb25zdCBkZWxpbWl0ZWQgPSBmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuZGVsaW1pdGVkO1xuICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBkZWxpbWl0ZWQgPyBmaWVsZC5ubyA6IHJlYWRlci51aW50MzIoKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgb3B0aW9ucywgZGVsaW1pdGVkKTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vLyBSZWFkIGEgbWFwIGZpZWxkLCBleHBlY3Rpbmcga2V5IGZpZWxkID0gMSwgdmFsdWUgZmllbGQgPSAyXG5mdW5jdGlvbiByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucykge1xuICBjb25zdCBsZW5ndGggPSByZWFkZXIudWludDMyKCksXG4gICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgbGV0IGtleSwgdmFsO1xuICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgIGNvbnN0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuVi5UKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICB2YWwgPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IGZpZWxkLlYuVCgpLCBvcHRpb25zLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIGtleSA9IHNjYWxhclplcm9WYWx1ZShmaWVsZC5LLCBMb25nVHlwZS5CSUdJTlQpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPSBcIm51bWJlclwiKSB7XG4gICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgdmFsID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlYuVCwgTG9uZ1R5cGUuQklHSU5UKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICB2YWwgPSBmaWVsZC5WLlQudmFsdWVzWzBdLm5vO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIHZhbCA9IG5ldyBmaWVsZC5WLlQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBba2V5LCB2YWxdO1xufVxuLy8gUmVhZCBhIHNjYWxhciB2YWx1ZSwgYnV0IHJldHVybiA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4vLyBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KSBhcyBzdHJpbmcgaW5zdGVhZCBvZiBiaWdpbnQuXG5mdW5jdGlvbiByZWFkU2NhbGFyTFRTdHJpbmcocmVhZGVyLCB0eXBlKSB7XG4gIGNvbnN0IHYgPSByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSk7XG4gIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcbn1cbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5mdW5jdGlvbiByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gcmVhZGVyLmRvdWJsZSgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5pbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50MzIoKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gIGNvbnN0IHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQ7XG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgbGV0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCkge1xuICAgICAgICAgIHdyaXRlUGFja2VkKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1hcFwiOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcbiAgd3JpdGVyLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKTtcbiAgd3JpdGVyLmZvcmsoKTtcbiAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAvLyB3ZSBjb252ZXJ0IGZyb20gb3VyIHJlcHJlc2VudGF0aW9uIHRvIHRoZSBwcm90b2J1ZiB0eXBlXG4gIGxldCBrZXlWYWx1ZSA9IGtleTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICBzd2l0Y2ggKGZpZWxkLkspIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgIGtleVZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGFzc2VydChrZXkgPT0gXCJ0cnVlXCIgfHwga2V5ID09IFwiZmFsc2VcIik7XG4gICAgICBrZXlWYWx1ZSA9IGtleSA9PSBcInRydWVcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuSywgMSwga2V5VmFsdWUpO1xuICAvLyB3cml0ZSB2YWx1ZSwgZXhwZWN0aW5nIHZhbHVlIGZpZWxkIG51bWJlciA9IDJcbiAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIGZpZWxkLlYuVCwgMiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgU2NhbGFyVHlwZS5JTlQzMiwgMiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyh2YWx1ZS50b0JpbmFyeShvcHRpb25zKSk7XG4gICAgICBicmVhaztcbiAgfVxuICB3cml0ZXIuam9pbigpO1xufVxuLy8gVmFsdWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkXG5mdW5jdGlvbiB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCB2YWx1ZSkge1xuICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICBpZiAoZmllbGQuZGVsaW1pdGVkKSB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5TdGFydEdyb3VwKS5yYXcobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSkudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5FbmRHcm91cCk7ZWxzZSB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmJ5dGVzKG1lc3NhZ2UudG9CaW5hcnkob3B0aW9ucykpO1xufVxuZnVuY3Rpb24gd3JpdGVTY2FsYXIod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSkge1xuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gIGxldCBbd2lyZVR5cGUsIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSlbbWV0aG9kXSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB3cml0ZVBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gIGxldCBbLCBtZXRob2RdID0gc2NhbGFyVHlwZUluZm8odHlwZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gIH1cbiAgd3JpdGVyLmpvaW4oKTtcbn1cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXG4gKiBbMV06IG5hbWUgb2YgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBvZiBJQmluYXJ5V3JpdGVyXG4gKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvdG8zIHNlbWFudGljc1xuICpcbiAqIElmIGFyZ3VtZW50IGB2YWx1ZWAgaXMgb21pdHRlZCwgWzJdIGlzIGFsd2F5cyBmYWxzZS5cbiAqL1xuLy8gVE9ETyByZXBsYWNlIGNhbGwtc2l0ZXMgd3JpdGVTY2FsYXIoKSBhbmQgd3JpdGVQYWNrZWQoKSwgdGhlbiByZW1vdmVcbmZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUpIHtcbiAgbGV0IHdpcmVUeXBlID0gV2lyZVR5cGUuVmFyaW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFt3aXJlVHlwZSwgbWV0aG9kXTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5mdW5jdGlvbiBtYWtlVXRpbENvbW1vbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzZXRFbnVtVHlwZSxcbiAgICBpbml0UGFydGlhbChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQuZ2V0VHlwZSgpO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxuICAgICAgICAgIHQgPSB0YXJnZXQsXG4gICAgICAgICAgcyA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHNbbG9jYWxOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETyBpZiBzb3VyY2UgaXMgYSBNZXNzYWdlIGluc3RhbmNlLCB3ZSBzaG91bGQgdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgY29uc3Qgc2sgPSBzW2xvY2FsTmFtZV0uY2FzZTtcbiAgICAgICAgICAgIGlmIChzayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBtZW1iZXIuZmluZEZpZWxkKHNrKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV0udmFsdWU7XG4gICAgICAgICAgICBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIiAmJiAhaXNNZXNzYWdlKHZhbCwgc291cmNlRmllbGQuVCkpIHtcbiAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PT0gXCJzY2FsYXJcIiAmJiBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHtcbiAgICAgICAgICAgICAgY2FzZTogc2ssXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIGNvcHkgPSBtZW1iZXIucmVwZWF0ZWQgPyBjb3B5Lm1hcCh0b1U4QXJyKSA6IHRvVThBcnIoY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlYuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRbbG9jYWxOYW1lXSwgc1tsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdW2tdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB0YWtlIHBhcnRpYWwgaW5wdXQgZm9yIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhIHdyYXBwZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBtZXNzYWdlVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBjb25zdCBtdCA9IG1lbWJlci5UO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBzW2xvY2FsTmFtZV0ubWFwKHZhbCA9PiBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgIGlmIChtdC5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIEJ5dGVzVmFsdWUudHlwZU5hbWUgYXMgdGhhdCB3aWxsIGNyZWF0ZSBhIGNpcmN1bGFyIGltcG9ydFxuICAgICAgICAgICAgICAgIG10LnR5cGVOYW1lID09PSBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgZXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpLmV2ZXJ5KG0gPT4ge1xuICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xuICAgICAgICBjb25zdCB2YiA9IGJbbS5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAobS5yZXBlYXRlZCkge1xuICAgICAgICAgIGlmICh2YS5sZW5ndGggIT09IHZiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSByZXBlYXRlZCBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBtLlQuZXF1YWxzKGEsIHZiW2ldKSk7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcGVhdGVkIGNhbm5vdCBjb250YWluIFwiLmNvbmNhdChtLmtpbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gbS5ULmVxdWFscyh2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICBpZiAodmEuY2FzZSAhPT0gdmIuY2FzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gb25lb2YgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICBzd2l0Y2ggKHMua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzLlQuZXF1YWxzKHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhzLlQsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmVvZiBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQocy5raW5kKSk7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhKS5jb25jYXQoT2JqZWN0LmtleXModmIpKTtcbiAgICAgICAgICAgIHN3aXRjaCAobS5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gbWVzc2FnZVR5cGUuZXF1YWxzKHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gc2NhbGFyRXF1YWxzKHNjYWxhclR5cGUsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gVE9ETyB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcbiAgICBjbG9uZShtZXNzYWdlKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCksXG4gICAgICAgIHRhcmdldCA9IG5ldyB0eXBlKCksXG4gICAgICAgIGFueSA9IHRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbWVzc2FnZVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICBjb3B5ID0gc291cmNlLm1hcChjbG9uZVNpbmd1bGFyRmllbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICBjb3B5ID0gYW55W21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVTaW5ndWxhckZpZWxkKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICBjb25zdCBmID0gbWVtYmVyLmZpbmRGaWVsZChzb3VyY2UuY2FzZSk7XG4gICAgICAgICAgY29weSA9IGYgPyB7XG4gICAgICAgICAgICBjYXNlOiBzb3VyY2UuY2FzZSxcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlLnZhbHVlKVxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHkgPSBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBhbnlbbWVtYmVyLmxvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB1ZiBvZiB0eXBlLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpKSB7XG4gICAgICAgIHR5cGUucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQoYW55LCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH07XG59XG4vLyBjbG9uZSBhIHNpbmdsZSBmaWVsZCB2YWx1ZSAtIGkuZS4gdGhlIGVsZW1lbnQgdHlwZSBvZiByZXBlYXRlZCBmaWVsZHMsIHRoZSB2YWx1ZSB0eXBlIG9mIG1hcHNcbmZ1bmN0aW9uIGNsb25lU2luZ3VsYXJGaWVsZCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNNZXNzYWdlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgYy5zZXQodmFsdWUpO1xuICAgIHJldHVybiBjO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGlucHV0IDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIG5ld0ZpZWxkTGlzdCwgaW5pdEZpZWxkcykge1xuICByZXR1cm4ge1xuICAgIHN5bnRheCxcbiAgICBqc29uOiBtYWtlSnNvbkZvcm1hdCgpLFxuICAgIGJpbjogbWFrZUJpbmFyeUZvcm1hdCgpLFxuICAgIHV0aWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZVV0aWxDb21tb24oKSksIHtcbiAgICAgIG5ld0ZpZWxkTGlzdCxcbiAgICAgIGluaXRGaWVsZHNcbiAgICB9KSxcbiAgICBtYWtlTWVzc2FnZVR5cGUodHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gICAgICByZXR1cm4gbWFrZU1lc3NhZ2VUeXBlKHRoaXMsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCk7XG4gICAgfSxcbiAgICBtYWtlRW51bSxcbiAgICBtYWtlRW51bVR5cGUsXG4gICAgZ2V0RW51bVR5cGUsXG4gICAgbWFrZUV4dGVuc2lvbih0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XG4gICAgICByZXR1cm4gbWFrZUV4dGVuc2lvbih0aGlzLCB0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jbGFzcyBJbnRlcm5hbEZpZWxkTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xuICAgIHRoaXMuX2ZpZWxkcyA9IGZpZWxkcztcbiAgICB0aGlzLl9ub3JtYWxpemVyID0gbm9ybWFsaXplcjtcbiAgfVxuICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcbiAgICBpZiAoIXRoaXMuanNvbk5hbWVzKSB7XG4gICAgICBjb25zdCB0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgdFtmLmpzb25OYW1lXSA9IHRbZi5uYW1lXSA9IGY7XG4gICAgICB9XG4gICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmpzb25OYW1lc1tqc29uTmFtZV07XG4gIH1cbiAgZmluZChmaWVsZE5vKSB7XG4gICAgaWYgKCF0aGlzLm51bWJlcnMpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICB0W2Yubm9dID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMubnVtYmVycyA9IHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm51bWJlcnNbZmllbGROb107XG4gIH1cbiAgbGlzdCgpIHtcbiAgICBpZiAoIXRoaXMuYWxsKSB7XG4gICAgICB0aGlzLmFsbCA9IHRoaXMuX25vcm1hbGl6ZXIodGhpcy5fZmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsO1xuICB9XG4gIGJ5TnVtYmVyKCkge1xuICAgIGlmICghdGhpcy5udW1iZXJzQXNjKSB7XG4gICAgICB0aGlzLm51bWJlcnNBc2MgPSB0aGlzLmxpc3QoKS5jb25jYXQoKS5zb3J0KChhLCBiKSA9PiBhLm5vIC0gYi5ubyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm51bWJlcnNBc2M7XG4gIH1cbiAgYnlNZW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcbiAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcbiAgICAgIGxldCBvO1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIGlmIChmLm9uZW9mKSB7XG4gICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcbiAgICAgICAgICAgIG8gPSBmLm9uZW9mO1xuICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVtYmVycztcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgcHJvdG9idWYgZWxlbWVudCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBGaWVsZCBuYW1lcyAtIGluY2x1ZGluZyBvbmVvZnMgLSBhcmUgY29udmVydGVkIHRvIGxvd2VyQ2FtZWxDYXNlLiBGb3JcbiAqIG1lc3NhZ2VzLCBlbnVtZXJhdGlvbnMgYW5kIHNlcnZpY2VzLCB0aGUgcGFja2FnZSBuYW1lIGlzIHN0cmlwcGVkIGZyb21cbiAqIHRoZSB0eXBlIG5hbWUuIEZvciBuZXN0ZWQgbWVzc2FnZXMgYW5kIGVudW1lcmF0aW9ucywgdGhlIG5hbWVzIGFyZSBqb2luZWRcbiAqIHdpdGggYW4gdW5kZXJzY29yZS4gRm9yIG1ldGhvZHMsIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbWFkZSBsb3dlcmNhc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZpZWxkIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGluT25lb2YpIHtcbiAgY29uc3QgbmFtZSA9IHByb3RvQ2FtZWxDYXNlKHByb3RvTmFtZSk7XG4gIGlmIChpbk9uZW9mKSB7XG4gICAgLy8gb25lb2YgbWVtYmVyIG5hbWVzIGFyZSBub3QgcHJvcGVydGllcywgYnV0IHZhbHVlcyBvZiB0aGUgYGNhc2VgIHByb3BlcnR5LlxuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkoc2FmZU1lc3NhZ2VQcm9wZXJ0eShuYW1lKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBvbmVvZiBncm91cCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxPbmVvZk5hbWUocHJvdG9OYW1lKSB7XG4gIHJldHVybiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBuYW1lIGZvciBhIHByb3RvYnVmIGZpZWxkLCBleGFjdGx5IGxpa2UgcHJvdG9jIGRvZXMuXG4gKi9cbmNvbnN0IGZpZWxkSnNvbk5hbWUgPSBwcm90b0NhbWVsQ2FzZTtcbi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBwcm90b0NhbWVsQ2FzZSBhY2NvcmRpbmcgdG8gdGhlIGNvbnZlbnRpb25cbiAqIHVzZWQgYnkgcHJvdG9jIHRvIGNvbnZlcnQgYSBmaWVsZCBuYW1lIHRvIGEgSlNPTiBuYW1lLlxuICovXG5mdW5jdGlvbiBwcm90b0NhbWVsQ2FzZShzbmFrZUNhc2UpIHtcbiAgbGV0IGNhcE5leHQgPSBmYWxzZTtcbiAgY29uc3QgYiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYWtlQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjID0gc25ha2VDYXNlLmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgXCJfXCI6XG4gICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6XG4gICAgICBjYXNlIFwiMVwiOlxuICAgICAgY2FzZSBcIjJcIjpcbiAgICAgIGNhc2UgXCIzXCI6XG4gICAgICBjYXNlIFwiNFwiOlxuICAgICAgY2FzZSBcIjVcIjpcbiAgICAgIGNhc2UgXCI2XCI6XG4gICAgICBjYXNlIFwiN1wiOlxuICAgICAgY2FzZSBcIjhcIjpcbiAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjYXBOZXh0KSB7XG4gICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGIuam9pbihcIlwiKTtcbn1cbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCByZXNlcnZlZE9iamVjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IEphdmFTY3JpcHRcblwiY29uc3RydWN0b3JcIiwgXCJ0b1N0cmluZ1wiLCBcInRvSlNPTlwiLCBcInZhbHVlT2ZcIl0pO1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSB0aGUgcnVudGltZS5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcyA9IG5ldyBTZXQoW1xuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWVcblwiZ2V0VHlwZVwiLCBcImNsb25lXCIsIFwiZXF1YWxzXCIsIFwiZnJvbUJpbmFyeVwiLCBcImZyb21Kc29uXCIsIFwiZnJvbUpzb25TdHJpbmdcIiwgXCJ0b0JpbmFyeVwiLCBcInRvSnNvblwiLCBcInRvSnNvblN0cmluZ1wiLFxuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWUgZm9yIHRoZSBmdXR1cmVcblwidG9PYmplY3RcIl0pO1xuY29uc3QgZmFsbGJhY2sgPSBuYW1lID0+IFwiXCIuY29uY2F0KG5hbWUsIFwiJFwiKTtcbi8qKlxuICogV2lsbCB3cmFwIG5hbWVzIHRoYXQgYXJlIE9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllcyBvciBuYW1lcyByZXNlcnZlZFxuICogZm9yIGBNZXNzYWdlYHMuXG4gKi9cbmNvbnN0IHNhZmVNZXNzYWdlUHJvcGVydHkgPSBuYW1lID0+IHtcbiAgaWYgKHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCBzYWZlT2JqZWN0UHJvcGVydHkgPSBuYW1lID0+IHtcbiAgaWYgKHJlc2VydmVkT2JqZWN0UHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgdGhpcy5raW5kID0gXCJvbmVvZlwiO1xuICAgIHRoaXMucmVwZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0ID0gZmFsc2U7XG4gICAgdGhpcy5yZXEgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XG4gIH1cbiAgYWRkRmllbGQoZmllbGQpIHtcbiAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIFwiZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG5vdCBvbmUgb2YgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgfVxuICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9sb29rdXApIHtcbiAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2xvb2t1cFt0aGlzLmZpZWxkc1tpXS5sb2NhbE5hbWVdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDb252ZXJ0IGEgY29sbGVjdGlvbiBvZiBmaWVsZCBpbmZvIHRvIGFuIGFycmF5IG9mIG5vcm1hbGl6ZWQgRmllbGRJbmZvLlxuICpcbiAqIFRoZSBhcmd1bWVudCBgcGFja2VkQnlEZWZhdWx0YCBzcGVjaWZpZXMgd2hldGhlciBmaWVsZHMgdGhhdCBkbyBub3Qgc3BlY2lmeVxuICogYHBhY2tlZGAgc2hvdWxkIGJlIHBhY2tlZCAocHJvdG8zKSBvciB1bnBhY2tlZCAocHJvdG8yKS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvcyhmaWVsZEluZm9zLCBwYWNrZWRCeURlZmF1bHQpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gIGNvbnN0IHIgPSBbXTtcbiAgbGV0IG87XG4gIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZW9mIGZpZWxkSW5mb3MgPT0gXCJmdW5jdGlvblwiID8gZmllbGRJbmZvcygpIDogZmllbGRJbmZvcykge1xuICAgIGNvbnN0IGYgPSBmaWVsZDtcbiAgICBmLmxvY2FsTmFtZSA9IGxvY2FsRmllbGROYW1lKGZpZWxkLm5hbWUsIGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpO1xuICAgIGYuanNvbk5hbWUgPSAoX2EgPSBmaWVsZC5qc29uTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmllbGRKc29uTmFtZShmaWVsZC5uYW1lKTtcbiAgICBmLnJlcGVhdGVkID0gKF9iID0gZmllbGQucmVwZWF0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgIGYuTCA9IChfYyA9IGZpZWxkLkwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IExvbmdUeXBlLkJJR0lOVDtcbiAgICB9XG4gICAgZi5kZWxpbWl0ZWQgPSAoX2QgPSBmaWVsZC5kZWxpbWl0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgIGYucmVxID0gKF9lID0gZmllbGQucmVxKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZTtcbiAgICBmLm9wdCA9IChfZiA9IGZpZWxkLm9wdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XG4gICAgaWYgKGZpZWxkLnBhY2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGYucGFja2VkID0gZmllbGQua2luZCA9PSBcImVudW1cIiB8fCBmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5TVFJJTkc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gZi5vcHRpb25zID0gZmllbGQub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0O1xuICAgIGlmIChmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBvb25hbWUgPSB0eXBlb2YgZmllbGQub25lb2YgPT0gXCJzdHJpbmdcIiA/IGZpZWxkLm9uZW9mIDogZmllbGQub25lb2YubmFtZTtcbiAgICAgIGlmICghbyB8fCBvLm5hbWUgIT0gb29uYW1lKSB7XG4gICAgICAgIG8gPSBuZXcgSW50ZXJuYWxPbmVvZkluZm8ob29uYW1lKTtcbiAgICAgIH1cbiAgICAgIGYub25lb2YgPSBvO1xuICAgICAgby5hZGRGaWVsZChmKTtcbiAgICB9XG4gICAgci5wdXNoKGYpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtZXNzYWdlcyBkZWZpbmVkIHdpdGggdGhlIHByb3RvMyBzeW50YXguXG4gKi9cbmNvbnN0IHByb3RvMyA9IG1ha2VQcm90b1J1bnRpbWUoXCJwcm90bzNcIiwgZmllbGRzID0+IHtcbiAgcmV0dXJuIG5ldyBJbnRlcm5hbEZpZWxkTGlzdChmaWVsZHMsIHNvdXJjZSA9PiBub3JtYWxpemVGaWVsZEluZm9zKHNvdXJjZSkpO1xufSxcbi8vIFRPRE8gbWVyZ2Ugd2l0aCBwcm90bzIgYW5kIGluaXRFeHRlbnNpb25GaWVsZCwgYWxzbyBzZWUgaW5pdFBhcnRpYWwsIGVxdWFscywgY2xvbmVcbnRhcmdldCA9PiB7XG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIHRhcmdldC5nZXRUeXBlKCkuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICBpZiAobWVtYmVyLm9wdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxuICAgICAgdCA9IHRhcmdldDtcbiAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICB0W25hbWVdID0gW107XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgIHRbbmFtZV0gPSB7XG4gICAgICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgdFtuYW1lXSA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB0W25hbWVdID0gc2NhbGFyWmVyb1ZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cbiAqXG4gKiAgICAgSW5zdGFudCBub3cgPSBJbnN0YW50Lm5vdygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cbiAqICAgICAgICAgVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG5vdy5nZXRFcG9jaFNlY29uZCgpKVxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA2OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIGN1cnJlbnQgdGltZSBpbiBQeXRob24uXG4gKlxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXG4gKiAgICAgdGltZXN0YW1wLkdldEN1cnJlbnRUaW1lKClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxuICogZm9ybWF0IGlzIFwie3llYXJ9LXttb250aH0te2RheX1Ue2hvdXJ9OnttaW59OntzZWN9Wy57ZnJhY19zZWN9XVpcIlxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcbiAqIHNlY29uZHMsIHdoaWNoIGNhbiBnbyB1cCB0byA5IGRpZ2l0cyAoaS5lLiB1cCB0byAxIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiksXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxuICogXCJaXCIpIHdoZW4gcHJpbnRpbmcgdGhlIFRpbWVzdGFtcCB0eXBlIGFuZCBhIHByb3RvMyBKU09OIHBhcnNlciBzaG91bGQgYmVcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxuICpcbiAqIEZvciBleGFtcGxlLCBcIjIwMTctMDEtMTVUMDE6MzA6MTUuMDFaXCIgZW5jb2RlcyAxNS4wMSBzZWNvbmRzIHBhc3RcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxuICpcbiAqIEluIEphdmFTY3JpcHQsIG9uZSBjYW4gY29udmVydCBhIERhdGUgb2JqZWN0IHRvIHRoaXMgZm9ybWF0IHVzaW5nIHRoZVxuICogc3RhbmRhcmRcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxuICogbWV0aG9kLiBJbiBQeXRob24sIGEgc3RhbmRhcmQgYGRhdGV0aW1lLmRhdGV0aW1lYCBvYmplY3QgY2FuIGJlIGNvbnZlcnRlZFxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcbiAqIHRoZSB0aW1lIGZvcm1hdCBzcGVjICclWS0lbS0lZFQlSDolTTolUy4lZlonLiBMaWtld2lzZSwgaW4gSmF2YSwgb25lIGNhbiB1c2VcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogTm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uIE5lZ2F0aXZlXG4gICAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAqIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IFwiLmNvbmNhdChwcm90bzMuanNvbi5kZWJ1Zyhqc29uKSkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XG4gICAgfVxuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQucGFyc2UobXMgLyAxMDAwKTtcbiAgICB0aGlzLm5hbm9zID0gMDtcbiAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgdGhpcy5uYW5vcyA9IHBhcnNlSW50KFwiMVwiICsgbWF0Y2hlc1s3XSArIFwiMFwiLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtIDEwMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmFub3MgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGxldCB6ID0gXCJaXCI7XG4gICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XG4gICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSBcIjAwMDAwMFwiKSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xuICAgICAgfSBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgXCJaXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICB9XG4gIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XG4gIH1cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7XG4gICAgICBzZWNvbmRzOiBwcm90b0ludDY0LnBhcnNlKE1hdGguZmxvb3IobXMgLyAxMDAwKSksXG4gICAgICBuYW5vczogbXMgJSAxMDAwICogMTAwMDAwMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRpbWVzdGFtcCwgYSwgYik7XG4gIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNlY29uZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuXG5jb25zdCBNZXRyaWNzQmF0Y2ggPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NZXRyaWNzQmF0Y2hcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub3JtYWxpemVkX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0cl9kYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRpbWVfc2VyaWVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lU2VyaWVzTWV0cmljLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJldmVudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEV2ZW50TWV0cmljLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVGltZVNlcmllc01ldHJpYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRpbWVTZXJpZXNNZXRyaWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibGFiZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNhbXBsZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE1ldHJpY1NhbXBsZSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicmlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBNZXRyaWNTYW1wbGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NZXRyaWNTYW1wbGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub3JtYWxpemVkX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInZhbHVlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufV0pO1xuY29uc3QgRXZlbnRNZXRyaWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5FdmVudE1ldHJpY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYWJlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic3RhcnRfdGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJlbmRfdGltZXN0YW1wX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJub3JtYWxpemVkX3N0YXJ0X3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfZW5kX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wLFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJyaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IEJhY2t1cENvZGVjUG9saWN5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkJhY2t1cENvZGVjUG9saWN5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBSRUZFUl9SRUdSRVNTSU9OXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiU0lNVUxDQVNUXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUkVHUkVTU0lPTlwiXG59XSk7XG5jb25zdCBUcmFja1R5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlRyYWNrVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJBVURJT1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlZJREVPXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiREFUQVwiXG59XSk7XG5jb25zdCBUcmFja1NvdXJjZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVHJhY2tTb3VyY2VcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNBTUVSQVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk1JQ1JPUEhPTkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIlxufV0pO1xuY29uc3QgVmlkZW9RdWFsaXR5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJMT1dcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJNRURJVU1cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJISUdIXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiT0ZGXCJcbn1dKTtcbmNvbnN0IENvbm5lY3Rpb25RdWFsaXR5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBPT1JcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHT09EXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRVhDRUxMRU5UXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTE9TVFwiXG59XSk7XG5jb25zdCBDbGllbnRDb25maWdTZXR0aW5nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOU0VUXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiRElTQUJMRURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJFTkFCTEVEXCJcbn1dKTtcbmNvbnN0IERpc2Nvbm5lY3RSZWFzb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTl9SRUFTT05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJDTElFTlRfSU5JVElBVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRFVQTElDQVRFX0lERU5USVRZXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiU0VSVkVSX1NIVVRET1dOXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiUEFSVElDSVBBTlRfUkVNT1ZFRFwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIlJPT01fREVMRVRFRFwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlNUQVRFX01JU01BVENIXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiSk9JTl9GQUlMVVJFXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiTUlHUkFUSU9OXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiU0lHTkFMX0NMT1NFXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIlJPT01fQ0xPU0VEXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIlVTRVJfVU5BVkFJTEFCTEVcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwiVVNFUl9SRUpFQ1RFRFwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJTSVBfVFJVTktfRkFJTFVSRVwiXG59XSk7XG5jb25zdCBSZWNvbm5lY3RSZWFzb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlJlY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSUl9VTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlJSX1BVQkxJU0hFUl9GQUlMRURcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIlxufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uRXJyb3IgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlNFX1VOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNFX1RSQUNLX05PVEZPVU5EXCJcbn1dKTtcbmNvbnN0IEF1ZGlvVHJhY2tGZWF0dXJlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5BdWRpb1RyYWNrRmVhdHVyZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJURl9TVEVSRU9cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJURl9OT19EVFhcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJURl9BVVRPX0dBSU5fQ09OVFJPTFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlRGX0VDSE9fQ0FOQ0VMTEFUSU9OXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiVEZfTk9JU0VfU1VQUFJFU1NJT05cIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJURl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT05cIlxufV0pO1xuY29uc3QgUm9vbSQxID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUm9vbVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZW1wdHlfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiZGVwYXJ0dXJlX3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibWF4X3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJjcmVhdGlvbl90aW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiY3JlYXRpb25fdGltZV9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwidHVybl9wYXNzd29yZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImVuYWJsZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJudW1fcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJudW1fcHVibGlzaGVyc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiYWN0aXZlX3JlY29yZGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZWRWZXJzaW9uXG59XSk7XG5jb25zdCBDb2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNvZGVjXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm1pbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJmbXRwX2xpbmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgUGFydGljaXBhbnRQZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hfZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9zb3VyY2VzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJoaWRkZW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicmVjb3JkZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImNhbl91cGRhdGVfbWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcImFnZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJjYW5fc3Vic2NyaWJlX21ldHJpY3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50SW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJpZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0YXRlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ0cmFja3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJqb2luZWRfYXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJqb2luZWRfYXRfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwicGVybWlzc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRQZXJtaXNzaW9uXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiaXNfcHVibGlzaGVyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJraW5kXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX0tpbmQpXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXG4gIGtpbmQ6IFwibWFwXCIsXG4gIEs6IDksXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDlcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICB9XG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJkaXNjb25uZWN0X3JlYXNvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJraW5kX2RldGFpbHNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fS2luZERldGFpbCksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudEluZm9fU3RhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJKT0lOSU5HXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSk9JTkVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQUNUSVZFXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiRElTQ09OTkVDVEVEXCJcbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50SW5mb19LaW5kID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uS2luZFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJTVEFOREFSRFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIklOR1JFU1NcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJFR1JFU1NcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTSVBcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJBR0VOVFwiXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudEluZm9fS2luZERldGFpbCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmREZXRhaWxcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiQ0xPVURfQUdFTlRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJGT1JXQVJERURcIlxufV0pO1xuY29uc3QgRW5jcnlwdGlvbl9UeXBlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGVcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiTk9ORVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkdDTVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkNVU1RPTVwiXG59XSk7XG5jb25zdCBTaW11bGNhc3RDb2RlY0luZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibWlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVHJhY2tJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwic2ltdWxjYXN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInNvdXJjZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcIm1pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJjb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsY2FzdENvZGVjSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInN0ZXJlb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcImVuY3J5cHRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJzdHJlYW1cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZWRWZXJzaW9uXG59LCB7XG4gIG5vOiAxOSxcbiAgbmFtZTogXCJhdWRpb19mZWF0dXJlc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIwLFxuICBuYW1lOiBcImJhY2t1cF9jb2RlY19wb2xpY3lcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShCYWNrdXBDb2RlY1BvbGljeSQxKVxufV0pO1xuY29uc3QgVmlkZW9MYXllciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlZpZGVvTGF5ZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYml0cmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJzc3JjXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBEYXRhUGFja2V0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVBhY2tldFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJraW5kXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImRlc3RpbmF0aW9uX2lkZW50aXRpZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidXNlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXNlclBhY2tldCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzcGVha2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBY3RpdmVTcGVha2VyVXBkYXRlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInNpcF9kdG1mXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaXBEVE1GLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInRyYW5zY3JpcHRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYW5zY3JpcHRpb24sXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWV0cmljc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTWV0cmljc0JhdGNoLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNoYXRfbWVzc2FnZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2hhdE1lc3NhZ2UsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInJwY19yZXF1ZXN0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNSZXF1ZXN0LFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJycGNfYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNBY2ssXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInJwY19yZXNwb25zZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjUmVzcG9uc2UsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInN0cmVhbV9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fSGVhZGVyLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJzdHJlYW1fY2h1bmtcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fQ2h1bmssXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN0cmVhbV90cmFpbGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX1RyYWlsZXIsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn1dKTtcbmNvbnN0IERhdGFQYWNrZXRfS2luZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGF0YVBhY2tldC5LaW5kXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlJFTElBQkxFXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiTE9TU1lcIlxufV0pO1xuY29uc3QgQWN0aXZlU3BlYWtlclVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkFjdGl2ZVNwZWFrZXJVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3BlYWtlckluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TcGVha2VySW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJsZXZlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAyXG4gIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYWN0aXZlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBVc2VyUGFja2V0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXNlclBhY2tldFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBheWxvYWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRlc3RpbmF0aW9uX2lkZW50aXRpZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidG9waWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJzdGFydF90aW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiZW5kX3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJub25jZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59XSk7XG5jb25zdCBTaXBEVE1GID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2lwRFRNRlwiLCAoKSA9PiBbe1xuICBubzogMyxcbiAgbmFtZTogXCJjb2RlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImRpZ2l0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFRyYW5zY3JpcHRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFuc2NyaXB0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYW5zY3JpYmVkX3BhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJhY2tfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZWdtZW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhbnNjcmlwdGlvblNlZ21lbnQsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUcmFuc2NyaXB0aW9uU2VnbWVudCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYW5zY3JpcHRpb25TZWdtZW50XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0YXJ0X3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNFxuICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJlbmRfdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0XG4gIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImZpbmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImxhbmd1YWdlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IENoYXRNZXNzYWdlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ2hhdE1lc3NhZ2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImVkaXRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtZXNzYWdlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZGVsZXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJnZW5lcmF0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFJwY1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNSZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibWV0aG9kXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJlc3BvbnNlX3RpbWVvdXRfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuY29uc3QgUnBjQWNrID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUnBjQWNrXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgUnBjUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNFcnJvciQxLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59XSk7XG5jb25zdCBScGNFcnJvciQxID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUnBjRXJyb3JcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtZXNzYWdlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudFRyYWNrcyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFNlcnZlckluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TZXJ2ZXJJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImVkaXRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTZXJ2ZXJJbmZvX0VkaXRpb24pXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwibm9kZV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRlYnVnX2luZm9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJhZ2VudF9wcm90b2NvbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn1dKTtcbmNvbnN0IFNlcnZlckluZm9fRWRpdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlN0YW5kYXJkXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiQ2xvdWRcIlxufV0pO1xuY29uc3QgQ2xpZW50SW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNsaWVudEluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2RrXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREspXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwib3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJvc192ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGV2aWNlX21vZGVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYnJvd3NlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImJyb3dzZXJfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImFkZHJlc3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwibmV0d29ya1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJvdGhlcl9zZGtzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IENsaWVudEluZm9fU0RLID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5DbGllbnRJbmZvLlNES1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSlNcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJTV0lGVFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIkFORFJPSURcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJGTFVUVEVSXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiR09cIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJVTklUWVwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcIlJFQUNUX05BVElWRVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcIlJVU1RcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJQWVRIT05cIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiQ1BQXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIlVOSVRZX1dFQlwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJOT0RFXCJcbn1dKTtcbmNvbnN0IENsaWVudENvbmZpZ3VyYXRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInZpZGVvXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2NyZWVuXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicmVzdW1lX2Nvbm5lY3Rpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkaXNhYmxlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERpc2FibGVkQ29kZWNzXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImZvcmNlX3JlbGF5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn1dKTtcbmNvbnN0IFZpZGVvQ29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJoYXJkd2FyZV9lbmNvZGVyXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn1dKTtcbmNvbnN0IERpc2FibGVkQ29kZWNzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGlzYWJsZWRDb2RlY3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicHVibGlzaFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUaW1lZFZlcnNpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UaW1lZFZlcnNpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidW5peF9taWNyb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGlja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59XSk7XG5jb25zdCBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRhdGFTdHJlYW0uT3BlcmF0aW9uVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJDUkVBVEVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJVUERBVEVcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJERUxFVEVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJSRUFDVElPTlwiXG59XSk7XG5jb25zdCBEYXRhU3RyZWFtX1RleHRIZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLlRleHRIZWFkZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwib3BlcmF0aW9uX3R5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInJlcGx5X3RvX3N0cmVhbV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImF0dGFjaGVkX3N0cmVhbV9pZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZ2VuZXJhdGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSwge1xuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9UZXh0SGVhZGVyXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9CeXRlSGVhZGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5CeXRlSGVhZGVyXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQnl0ZUhlYWRlclwiXG59KTtcbmNvbnN0IERhdGFTdHJlYW1fSGVhZGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5IZWFkZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0b3BpY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInRvdGFsX2xlbmd0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZW5jcnlwdGlvbl90eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXG4gIGtpbmQ6IFwibWFwXCIsXG4gIEs6IDksXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDlcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICB9XG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInRleHRfaGVhZGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX1RleHRIZWFkZXIsXG4gIG9uZW9mOiBcImNvbnRlbnRfaGVhZGVyXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImJ5dGVfaGVhZGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX0J5dGVIZWFkZXIsXG4gIG9uZW9mOiBcImNvbnRlbnRfaGVhZGVyXCJcbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX0hlYWRlclwiXG59KTtcbmNvbnN0IERhdGFTdHJlYW1fQ2h1bmsgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkNodW5rXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNodW5rX2luZGV4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDRcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY29udGVudFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIml2XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyLFxuICBvcHQ6IHRydWVcbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX0NodW5rXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9UcmFpbGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5UcmFpbGVyXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX1RyYWlsZXJcIlxufSk7XG5jb25zdCBTaWduYWxUYXJnZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlNpZ25hbFRhcmdldFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJQVUJMSVNIRVJcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJTVUJTQ1JJQkVSXCJcbn1dKTtcbmNvbnN0IFN0cmVhbVN0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJBQ1RJVkVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJQQVVTRURcIlxufV0pO1xuY29uc3QgQ2FuZGlkYXRlUHJvdG9jb2wgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVEUFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlRDUFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlRMU1wiXG59XSk7XG5jb25zdCBTaWduYWxSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2lnbmFsUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJvZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYW5zd2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmlja2xlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmlja2xlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImFkZF90cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWRkVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwibXV0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTXV0ZVRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlU3Vic2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwidHJhY2tfc2V0dGluZ1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlVHJhY2tTZXR0aW5ncyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImxlYXZlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBMZWF2ZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwidXBkYXRlX2xheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlVmlkZW9MYXllcnMsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic3luY19zdGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3luY1N0YXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInNpbXVsYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaW11bGF0ZVNjZW5hcmlvLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInBpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJ1cGRhdGVfbWV0YWRhdGFcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwicGluZ19yZXFcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBpbmcsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwidXBkYXRlX2F1ZGlvX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVMb2NhbEF1ZGlvVHJhY2ssXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwidXBkYXRlX3ZpZGVvX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVMb2NhbFZpZGVvVHJhY2ssXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufV0pO1xuY29uc3QgU2lnbmFsUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaWduYWxSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJqb2luXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBKb2luUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ0cmlja2xlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmlja2xlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInVwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJ0cmFja19wdWJsaXNoZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJsZWF2ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTGVhdmVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibXV0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTXV0ZVRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzcGVha2Vyc19jaGFuZ2VkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTcGVha2Vyc0NoYW5nZWQsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwicm9vbV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21VcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwiY29ubmVjdGlvbl9xdWFsaXR5XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzdHJlYW1fc3RhdGVfdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdHJlYW1TdGF0ZVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdHlfdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvbl91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwicmVmcmVzaF90b2tlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInRyYWNrX3VucHVibGlzaGVkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwicG9uZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE5LFxuICBuYW1lOiBcInJlY29ubmVjdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUmVjb25uZWN0UmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjAsXG4gIG5hbWU6IFwicG9uZ19yZXNwXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQb25nLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIxLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9yZXNwb25zZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjIsXG4gIG5hbWU6IFwicmVxdWVzdF9yZXNwb25zZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUmVxdWVzdFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIzLFxuICBuYW1lOiBcInRyYWNrX3N1YnNjcmliZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrU3Vic2NyaWJlZCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59XSk7XG5jb25zdCBTaW11bGNhc3RDb2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVjXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IEFkZFRyYWNrUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInNvdXJjZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzaW11bGNhc3RfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaW11bGNhc3RDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzdGVyZW9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImRpc2FibGVfcmVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJlbmNyeXB0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwic3RyZWFtXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcImJhY2t1cF9jb2RlY19wb2xpY3lcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShCYWNrdXBDb2RlY1BvbGljeSQxKVxufV0pO1xuY29uc3QgVHJpY2tsZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Ucmlja2xlUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5kaWRhdGVJbml0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGFyZ2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJmaW5hbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgTXV0ZVRyYWNrUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibXV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IEpvaW5SZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkpvaW5SZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tJDFcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mb1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJvdGhlcl9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VydmVyX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJpY2Vfc2VydmVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSUNFU2VydmVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpYmVyX3ByaW1hcnlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic2VydmVyX3JlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJwaW5nX3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwaW5nX2ludGVydmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwic2VydmVyX2luZm9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlcnZlckluZm9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInNpZl90cmFpbGVyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImVuYWJsZWRfcHVibGlzaF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiZmFzdF9wdWJsaXNoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBSZWNvbm5lY3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImljZV9zZXJ2ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJQ0VTZXJ2ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDbGllbnRDb25maWd1cmF0aW9uXG59XSk7XG5jb25zdCBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tJbmZvXG59XSk7XG5jb25zdCBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFNlc3Npb25EZXNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2RwXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50VXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfdHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFRyYWNrcyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFVwZGF0ZVRyYWNrU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGlzYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZnBzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInByaW9yaXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBVcGRhdGVMb2NhbEF1ZGlvVHJhY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVMb2NhbEF1ZGlvVHJhY2tcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZmVhdHVyZXNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBVcGRhdGVMb2NhbFZpZGVvVHJhY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVMb2NhbFZpZGVvVHJhY2tcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBMZWF2ZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuX3JlY29ubmVjdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJyZWFzb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhY3Rpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShMZWF2ZVJlcXVlc3RfQWN0aW9uKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZWdpb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWdpb25TZXR0aW5nc1xufV0pO1xuY29uc3QgTGVhdmVSZXF1ZXN0X0FjdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuTGVhdmVSZXF1ZXN0LkFjdGlvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJESVNDT05ORUNUXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUkVTVU1FXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUkVDT05ORUNUXCJcbn1dKTtcbmNvbnN0IFVwZGF0ZVZpZGVvTGF5ZXJzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXBkYXRlVmlkZW9MYXllcnNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBJQ0VTZXJ2ZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5JQ0VTZXJ2ZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXJsc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1c2VybmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNyZWRlbnRpYWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU3BlYWtlcnNDaGFuZ2VkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNwZWFrZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTcGVha2VySW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFJvb21VcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufV0pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDb25uZWN0aW9uUXVhbGl0eSQxKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzY29yZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAyXG4gIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cbn1dKTtcbmNvbnN0IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXBkYXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29ubmVjdGlvblF1YWxpdHlJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3RyZWFtU3RhdGVJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0YXRlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpXG59XSk7XG5jb25zdCBTdHJlYW1TdGF0ZVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN0cmVhbVN0YXRlSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFN1YnNjcmliZWRRdWFsaXR5ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlbmFibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBTdWJzY3JpYmVkQ29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJxdWFsaXRpZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdGllc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN1YnNjcmliZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUcmFja1Blcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja1Blcm1pc3Npb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYWxsX3RyYWNrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFsbF9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfcGVybWlzc2lvbnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrUGVybWlzc2lvbixcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImFsbG93ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFN5bmNTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN5bmNTdGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvblxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvblxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwdWJsaXNoX3RyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZGF0YV9jaGFubmVsc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YUNoYW5uZWxJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJvZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInRyYWNrX3NpZHNfZGlzYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IERhdGFDaGFubmVsSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFDaGFubmVsSW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYWJlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRhcmdldFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldClcbn1dKTtcbmNvbnN0IFNpbXVsYXRlU2NlbmFyaW8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNwZWFrZXJfdXBkYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibm9kZV9mYWlsdXJlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibWlncmF0aW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VydmVyX2xlYXZlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwic3dpdGNoX2NhbmRpZGF0ZV9wcm90b2NvbFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENhbmRpZGF0ZVByb3RvY29sKSxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpYmVyX2JhbmR3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZV9ub19tZXNzYWdlc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImxlYXZlX3JlcXVlc3RfZnVsbF9yZWNvbm5lY3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufV0pO1xuY29uc3QgUGluZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBpbmdcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJydHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG5jb25zdCBQb25nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUG9uZ1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYXN0X3BpbmdfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG5jb25zdCBSZWdpb25TZXR0aW5ncyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlZ2lvblNldHRpbmdzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlZ2lvbnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJlZ2lvbkluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBSZWdpb25JbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVnaW9uSW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkaXN0YW5jZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn1dKTtcbmNvbnN0IFN1YnNjcmlwdGlvblJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaXB0aW9uUmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZXJyXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpXG59XSk7XG5jb25zdCBSZXF1ZXN0UmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZXF1ZXN0UmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJyZWFzb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShSZXF1ZXN0UmVzcG9uc2VfUmVhc29uKVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJtZXNzYWdlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFJlcXVlc3RSZXNwb25zZV9SZWFzb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlJlcXVlc3RSZXNwb25zZS5SZWFzb25cIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiT0tcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJOT1RfRk9VTkRcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJOT1RfQUxMT1dFRFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIkxJTUlUX0VYQ0VFREVEXCJcbn1dKTtcbmNvbnN0IFRyYWNrU3Vic2NyaWJlZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrU3Vic2NyaWJlZFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgbG9nbGV2ZWwkMSA9IHtleHBvcnRzOiB7fX07XG5cbi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbnZhciBsb2dsZXZlbCA9IGxvZ2xldmVsJDEuZXhwb3J0cztcbnZhciBoYXNSZXF1aXJlZExvZ2xldmVsO1xuZnVuY3Rpb24gcmVxdWlyZUxvZ2xldmVsKCkge1xuICBpZiAoaGFzUmVxdWlyZWRMb2dsZXZlbCkgcmV0dXJuIGxvZ2xldmVsJDEuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRMb2dsZXZlbCA9IDE7XG4gIChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG5cbiAgICAgIGlmIChtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgICAgfVxuICAgIH0pKGxvZ2xldmVsLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgICB2YXIgaXNJRSA9IHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUgJiYgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIGxvZ01ldGhvZHMgPSBbXCJ0cmFjZVwiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXTtcbiAgICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBudWxsO1xuXG4gICAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMoKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuZ2V0TGV2ZWwoKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBhY3R1YWwgbWV0aG9kcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSBpIDwgbGV2ZWwgPyBub29wIDogdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG5cbiAgICAgICAgLy8gUmV0dXJuIGFueSBpbXBvcnRhbnQgd2FybmluZ3MuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHRoaXMubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIF9sZXZlbCwgX2xvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHwgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGZhY3RvcnkpIHtcbiAgICAgICAgLy8gUHJpdmF0ZSBpbnN0YW5jZSB2YXJpYWJsZXMuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsZXZlbCBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCBsb2dnZXIgKG9yIGEgZ2xvYmFsIGRlZmF1bHQpLiBXZVxuICAgICAgICAgKiBjYWNoZSB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gZGVsZWdhdGluZyB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgc3RheXNcbiAgICAgICAgICogaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbG9nZ2luZyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBpbnN0YWxsZWQgKHRoZVxuICAgICAgICAgKiBwYXJlbnQgY291bGQgY2hhbmdlIGxldmVscyBidXQgd2UgbWlnaHQgbm90IGhhdmUgcmVidWlsdCB0aGUgbG9nZ2Vyc1xuICAgICAgICAgKiBpbiB0aGlzIGNoaWxkIHlldCkuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaW5oZXJpdGVkTGV2ZWw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBsZXZlbCBmb3IgdGhpcyBsb2dnZXIsIGlmIGFueS4gSWYgc2V0LCB0aGlzIG92ZXJyaWRlc1xuICAgICAgICAgKiBgaW5oZXJpdGVkTGV2ZWxgLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZGVmYXVsdExldmVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB1c2VyLXNwZWNpZmljIGxldmVsIGZvciB0aGlzIGxvZ2dlci4gSWYgc2V0LCB0aGlzIG92ZXJyaWRlc1xuICAgICAgICAgKiBgZGVmYXVsdExldmVsYC5cbiAgICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHVzZXJMZXZlbDtcbiAgICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgdmFyIGNvb2tpZU5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKGNvb2tpZU5hbWUgKyBcIj1cIik7XG4gICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24gKyBjb29raWVOYW1lLmxlbmd0aCArIDEpKVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVMZXZlbChpbnB1dCkge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGlucHV0O1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBpbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICpcbiAgICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG4gICAgICAgIHNlbGYubGV2ZWxzID0ge1xuICAgICAgICAgIFwiVFJBQ0VcIjogMCxcbiAgICAgICAgICBcIkRFQlVHXCI6IDEsXG4gICAgICAgICAgXCJJTkZPXCI6IDIsXG4gICAgICAgICAgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LFxuICAgICAgICAgIFwiU0lMRU5UXCI6IDVcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcbiAgICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodXNlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyTGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0TGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRlZExldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGxldmVsKTtcbiAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUodXNlckxldmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBpbiB2MiwgdGhpcyBzaG91bGQgY2FsbCByZWJ1aWxkKCksIHdoaWNoIHVwZGF0ZXMgY2hpbGRyZW4uXG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGxldmVsKTtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYucmVzZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBudWxsO1xuICAgICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5yZWJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyICE9PSBzZWxmKSB7XG4gICAgICAgICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyID09PSBzZWxmKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjaGlsZE5hbWUgaW4gX2xvZ2dlcnNCeU5hbWUpIHtcbiAgICAgICAgICAgICAgX2xvZ2dlcnNCeU5hbWVbY2hpbGROYW1lXS5yZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIHRoZSBpbnRlcm5hbCBsZXZlbHMuXG4gICAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoZGVmYXVsdExvZ2dlciA/IGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSA6IFwiV0FSTlwiKTtcbiAgICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICAgIGlmIChpbml0aWFsTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGluaXRpYWxMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogVG9wLWxldmVsIEFQSVxuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuICAgICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIobmFtZSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgICAgfTtcblxuICAgICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICB2YXIgX2xvZyA9IHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgICB9O1xuICAgICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgICAgfTtcblxuICAgICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcbiAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH0pO1xuICB9KShsb2dsZXZlbCQxKTtcbiAgcmV0dXJuIGxvZ2xldmVsJDEuZXhwb3J0cztcbn1cblxudmFyIGxvZ2xldmVsRXhwb3J0cyA9IHJlcXVpcmVMb2dsZXZlbCgpO1xuXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1widHJhY2VcIl0gPSAwXSA9IFwidHJhY2VcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJkZWJ1Z1wiXSA9IDFdID0gXCJkZWJ1Z1wiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImluZm9cIl0gPSAyXSA9IFwiaW5mb1wiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcIndhcm5cIl0gPSAzXSA9IFwid2FyblwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImVycm9yXCJdID0gNF0gPSBcImVycm9yXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wic2lsZW50XCJdID0gNV0gPSBcInNpbGVudFwiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbnZhciBMb2dnZXJOYW1lcztcbihmdW5jdGlvbiAoTG9nZ2VyTmFtZXMpIHtcbiAgTG9nZ2VyTmFtZXNbXCJEZWZhdWx0XCJdID0gXCJsaXZla2l0XCI7XG4gIExvZ2dlck5hbWVzW1wiUm9vbVwiXSA9IFwibGl2ZWtpdC1yb29tXCI7XG4gIExvZ2dlck5hbWVzW1wiUGFydGljaXBhbnRcIl0gPSBcImxpdmVraXQtcGFydGljaXBhbnRcIjtcbiAgTG9nZ2VyTmFtZXNbXCJUcmFja1wiXSA9IFwibGl2ZWtpdC10cmFja1wiO1xuICBMb2dnZXJOYW1lc1tcIlB1YmxpY2F0aW9uXCJdID0gXCJsaXZla2l0LXRyYWNrLXB1YmxpY2F0aW9uXCI7XG4gIExvZ2dlck5hbWVzW1wiRW5naW5lXCJdID0gXCJsaXZla2l0LWVuZ2luZVwiO1xuICBMb2dnZXJOYW1lc1tcIlNpZ25hbFwiXSA9IFwibGl2ZWtpdC1zaWduYWxcIjtcbiAgTG9nZ2VyTmFtZXNbXCJQQ01hbmFnZXJcIl0gPSBcImxpdmVraXQtcGMtbWFuYWdlclwiO1xuICBMb2dnZXJOYW1lc1tcIlBDVHJhbnNwb3J0XCJdID0gXCJsaXZla2l0LXBjLXRyYW5zcG9ydFwiO1xuICBMb2dnZXJOYW1lc1tcIkUyRUVcIl0gPSBcImxrLWUyZWVcIjtcbn0pKExvZ2dlck5hbWVzIHx8IChMb2dnZXJOYW1lcyA9IHt9KSk7XG5sZXQgbGl2ZWtpdExvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIoJ2xpdmVraXQnKTtcbmNvbnN0IGxpdmVraXRMb2dnZXJzID0gT2JqZWN0LnZhbHVlcyhMb2dnZXJOYW1lcykubWFwKG5hbWUgPT4gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKSk7XG5saXZla2l0TG9nZ2VyLnNldERlZmF1bHRMZXZlbChMb2dMZXZlbC5pbmZvKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIobmFtZSk7XG4gIGxvZ2dlci5zZXREZWZhdWx0TGV2ZWwobGl2ZWtpdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn1cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gIGlmIChsb2dnZXJOYW1lKSB7XG4gICAgbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihsb2dnZXJOYW1lKS5zZXRMZXZlbChsZXZlbCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBsb2dnZXIgb2YgbGl2ZWtpdExvZ2dlcnMpIHtcbiAgICAgIGxvZ2dlci5zZXRMZXZlbChsZXZlbCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIHVzZSB0aGlzIHRvIGhvb2sgaW50byB0aGUgbG9nZ2luZyBmdW5jdGlvbiB0byBhbGxvdyBzZW5kaW5nIGludGVybmFsIGxpdmVraXQgbG9ncyB0byB0aGlyZCBwYXJ0eSBzZXJ2aWNlc1xuICogaWYgc2V0LCB0aGUgYnJvd3NlciBsb2dzIHdpbGwgbG9zZSB0aGVpciBzdGFja3RyYWNlIGluZm9ybWF0aW9uIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsI3dyaXRpbmctcGx1Z2lucylcbiAqL1xuZnVuY3Rpb24gc2V0TG9nRXh0ZW5zaW9uKGV4dGVuc2lvbiwgbG9nZ2VyKSB7XG4gIGNvbnN0IGxvZ2dlcnMgPSBsb2dnZXIgPyBbbG9nZ2VyXSA6IGxpdmVraXRMb2dnZXJzO1xuICBsb2dnZXJzLmZvckVhY2gobG9nUiA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbG9nUi5tZXRob2RGYWN0b3J5O1xuICAgIGxvZ1IubWV0aG9kRmFjdG9yeSA9IChtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmF3TWV0aG9kID0gb3JpZ2luYWxGYWN0b3J5KG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgIGNvbnN0IGxvZ0xldmVsID0gTG9nTGV2ZWxbbWV0aG9kTmFtZV07XG4gICAgICBjb25zdCBuZWVkTG9nID0gbG9nTGV2ZWwgPj0gY29uZmlnTGV2ZWwgJiYgbG9nTGV2ZWwgPCBMb2dMZXZlbC5zaWxlbnQ7XG4gICAgICByZXR1cm4gKG1zZywgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dCkgcmF3TWV0aG9kKG1zZywgY29udGV4dCk7ZWxzZSByYXdNZXRob2QobXNnKTtcbiAgICAgICAgaWYgKG5lZWRMb2cpIHtcbiAgICAgICAgICBleHRlbnNpb24obG9nTGV2ZWwsIG1zZywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBsb2dSLnNldExldmVsKGxvZ1IuZ2V0TGV2ZWwoKSk7XG4gIH0pO1xufVxuY29uc3Qgd29ya2VyTG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcignbGstZTJlZScpO1xuXG5jb25zdCBtYXhSZXRyeURlbGF5ID0gNzAwMDtcbmNvbnN0IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TID0gWzAsIDMwMCwgMiAqIDIgKiAzMDAsIDMgKiAzICogMzAwLCA0ICogNCAqIDMwMCwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheV07XG5jbGFzcyBEZWZhdWx0UmVjb25uZWN0UG9saWN5IHtcbiAgY29uc3RydWN0b3IocmV0cnlEZWxheXMpIHtcbiAgICB0aGlzLl9yZXRyeURlbGF5cyA9IHJldHJ5RGVsYXlzICE9PSB1bmRlZmluZWQgPyBbLi4ucmV0cnlEZWxheXNdIDogREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVM7XG4gIH1cbiAgbmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50ID49IHRoaXMuX3JldHJ5RGVsYXlzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IHRoaXMuX3JldHJ5RGVsYXlzW2NvbnRleHQucmV0cnlDb3VudF07XG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA8PSAxKSByZXR1cm4gcmV0cnlEZWxheTtcbiAgICByZXR1cm4gcmV0cnlEZWxheSArIE1hdGgucmFuZG9tKCkgKiAxMDAwO1xuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBldmVudHMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRFdmVudHM7XG5mdW5jdGlvbiByZXF1aXJlRXZlbnRzKCkge1xuICBpZiAoaGFzUmVxdWlyZWRFdmVudHMpIHJldHVybiBldmVudHMuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRFdmVudHMgPSAxO1xuICB2YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsO1xuICB2YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJyA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfTtcbiAgdmFyIFJlZmxlY3RPd25LZXlzO1xuICBpZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXM7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG4gIH1cbiAgdmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfTtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG4gIH1cbiAgZXZlbnRzLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIGV2ZW50cy5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4gIC8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4gIC8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuICAvLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuICB2YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuICBmdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xuICBFdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcbiAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgICB9XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gICAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgdmFyIGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtlbHNlIGlmICghZG9FcnJvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICB2YXIgZXI7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSBlciA9IGFyZ3NbMF07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgICB2YXIgbTtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBleGlzdGluZztcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gICAgfVxuICAgIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgKyBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICsgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICsgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICB9O1xuICBmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBmaXJlZDogZmFsc2UsXG4gICAgICB3cmFwRm46IHVuZGVmaW5lZCxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgIH07XG4gICAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgICByZXR1cm4gd3JhcHBlZDtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBvc2l0aW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAocG9zaXRpb24gPT09IDApIGxpc3Quc2hpZnQoKTtlbHNlIHtcbiAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuXG4gICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBmdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcbiAgICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICAgIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xuICB9O1xuICBFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gICAgfVxuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuICBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbiAgfTtcbiAgZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgY29weVtpXSA9IGFycltpXTtcbiAgICByZXR1cm4gY29weTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICAgIGxpc3QucG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcihhcmcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudHMuZXhwb3J0cztcbn1cblxudmFyIGV2ZW50c0V4cG9ydHMgPSByZXF1aXJlRXZlbnRzKCk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmxldCBsb2dEaXNhYmxlZF8gPSB0cnVlO1xubGV0IGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcblxuLyoqXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFZlcnNpb24odWFzdHJpbmcsIGV4cHIsIHBvcykge1xuICBjb25zdCBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUludChtYXRjaFtwb3NdLCAxMCk7XG59XG5cbi8vIFdyYXBzIHRoZSBwZWVyY29ubmVjdGlvbiBldmVudCBldmVudE5hbWVUb1dyYXAgaW4gYSBmdW5jdGlvblxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XG4vLyB0aGUgZXZlbnQpLlxuZnVuY3Rpb24gd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCBldmVudE5hbWVUb1dyYXAsIHdyYXBwZXIpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBjb25zdCBuYXRpdmVBZGRFdmVudExpc3RlbmVyID0gcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xuICAgICAgaWYgKG1vZGlmaWVkRXZlbnQpIHtcbiAgICAgICAgaWYgKGNiLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgY2IuaGFuZGxlRXZlbnQobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50TWFwID0gdGhpcy5fZXZlbnRNYXAgfHwge307XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNldChjYiwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB3cmFwcGVkQ2FsbGJhY2tdKTtcbiAgfTtcbiAgY29uc3QgbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCB8fCAhdGhpcy5fZXZlbnRNYXAgfHwgIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5oYXMoY2IpKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB1bndyYXBwZWRDYiA9IHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZ2V0KGNiKTtcbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmRlbGV0ZShjYik7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2l6ZSA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9ldmVudE1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXA7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsIHVud3JhcHBlZENiXSk7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uJyArIGV2ZW50TmFtZVRvV3JhcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBkaXNhYmxlTG9nKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBsb2dEaXNhYmxlZF8gPSBib29sO1xuICByZXR1cm4gYm9vbCA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDogJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcbn1cblxuLyoqXG4gKiBEaXNhYmxlIG9yIGVuYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5nc1xuICogQHBhcmFtIHshYm9vbGVhbn0gYm9vbCBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHdhcm5pbmdzLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlV2FybmluZ3MoYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZ3NfID0gIWJvb2w7XG4gIHJldHVybiAnYWRhcHRlci5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyAnICsgKGJvb2wgPyAnZGlzYWJsZWQnIDogJ2VuYWJsZWQnKTtcbn1cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGxvZ0Rpc2FibGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgc3VnZ2VzdGluZyB0aGUgbW9kZXJuIGFuZCBzcGVjLWNvbXBhdGlibGUgQVBJLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKG9sZE1ldGhvZCwgbmV3TWV0aG9kKSB7XG4gIGlmICghZGVwcmVjYXRpb25XYXJuaW5nc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG9sZE1ldGhvZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgbmV3TWV0aG9kICsgJyBpbnN0ZWFkLicpO1xufVxuXG4vKipcbiAqIEJyb3dzZXIgZGV0ZWN0b3IuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSByZXN1bHQgY29udGFpbmluZyBicm93c2VyIGFuZCB2ZXJzaW9uXG4gKiAgICAgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpIHtcbiAgLy8gUmV0dXJuZWQgcmVzdWx0IG9iamVjdC5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGJyb3dzZXI6IG51bGwsXG4gICAgdmVyc2lvbjogbnVsbFxuICB9O1xuXG4gIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHtcbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yXG4gIH0gPSB3aW5kb3c7XG5cbiAgLy8gUHJlZmVyIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLlxuICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzKSB7XG4gICAgY29uc3QgY2hyb21pdW0gPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHMuZmluZChicmFuZCA9PiB7XG4gICAgICByZXR1cm4gYnJhbmQuYnJhbmQgPT09ICdDaHJvbWl1bSc7XG4gICAgfSk7XG4gICAgaWYgKGNocm9taXVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBicm93c2VyOiAnY2hyb21lJyxcbiAgICAgICAgdmVyc2lvbjogcGFyc2VJbnQoY2hyb21pdW0udmVyc2lvbiwgMTApXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgIC8vIEZpcmVmb3guXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgd2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEuXG4gICAgLy8gVmVyc2lvbiBtYXRjaGVzIENocm9tZS9XZWJSVEMgdmVyc2lvbi5cbiAgICAvLyBDaHJvbWUgNzQgcmVtb3ZlZCB3ZWJraXRHZXRVc2VyTWVkaWEgb24gaHR0cCBhcyB3ZWxsIHNvIHdlIG5lZWQgdGhlXG4gICAgLy8gbW9yZSBjb21wbGljYXRlZCBmYWxsYmFjayB0byB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0Nocm9tKGV8aXVtKVxcLyhcXGQrKVxcLi8sIDIpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XG4gICAgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKTtcbiAgICByZXN1bHQuc3VwcG9ydHNVbmlmaWVkUGxhbiA9IHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciAmJiAnY3VycmVudERpcmVjdGlvbicgaW4gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBzb21ldGhpbmcgeW91IHdhbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwga2V5KSB7XG4gICAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xuICAgIGNvbnN0IHZhbHVlID0gaXNPYmogPyBjb21wYWN0T2JqZWN0KGRhdGFba2V5XSkgOiBkYXRhW2tleV07XG4gICAgY29uc3QgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIHtcbiAgICAgIFtrZXldOiB2YWx1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG59XG5cbi8qIGl0ZXJhdGVzIHRoZSBzdGF0cyBncmFwaCByZWN1cnNpdmVseS4gKi9cbmZ1bmN0aW9uIHdhbGtTdGF0cyhzdGF0cywgYmFzZSwgcmVzdWx0U2V0KSB7XG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkJykpIHtcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcbiAgICAgIGJhc2VbbmFtZV0uZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXG5mdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xuICBjb25zdCBzdHJlYW1TdGF0c1R5cGUgPSBvdXRib3VuZCA/ICdvdXRib3VuZC1ydHAnIDogJ2luYm91bmQtcnRwJztcbiAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgfVxuICBjb25zdCB0cmFja1N0YXRzID0gW107XG4gIHJlc3VsdC5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJiB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRyYWNrU3RhdHMuZm9yRWFjaCh0cmFja1N0YXQgPT4ge1xuICAgIHJlc3VsdC5mb3JFYWNoKHN0YXRzID0+IHtcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5jb25zdCBsb2dnaW5nID0gbG9nO1xuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByID0gdHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcgPyBjW2tleV0gOiB7XG4gICAgICAgIGlkZWFsOiBjW2tleV1cbiAgICAgIH07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24gKHByZWZpeCwgbmFtZSkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lID09PSAnZGV2aWNlSWQnID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICBsZXQgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG4gIGNvbnN0IHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MSkge1xuICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbiAob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcgPyBmYWNlIDoge1xuICAgICAgICBpZGVhbDogZmFjZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcbiAgICAgIGlmIChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykgJiYgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlICYmICFnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcykpIHtcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICBpZiAoZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnYmFjaycsICdyZWFyJ107XG4gICAgICAgIH0gZWxzZSBpZiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2Zyb250J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAvLyBMb29rIGZvciBtYXRjaGVzIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gZm9yIGJhY2sgKHR5cGljYWwpLlxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuICAgICAgICAgICAgbGV0IGRldiA9IGRldmljZXMuZmluZChkID0+IG1hdGNoZXMuc29tZShtYXRjaCA9PiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpKSk7XG4gICAgICAgICAgICBpZiAoIWRldiAmJiBkZXZpY2VzLmxlbmd0aCAmJiBtYXRjaGVzLmluY2x1ZGVzKCdiYWNrJykpIHtcbiAgICAgICAgICAgICAgZGV2ID0gZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdOyAvLyBtb3JlIGxpa2VseSB0aGUgYmFjayBjYW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXYpIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge1xuICAgICAgICAgICAgICAgIGV4YWN0OiBkZXYuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBpZGVhbDogZGV2LmRldmljZUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcbiAgY29uc3Qgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBJbnZhbGlkU3RhdGVFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcbiAgICAgICAgVHJhY2tTdGFydEVycm9yOiAnTm90UmVhZGFibGVFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgVGFiQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGMgPT4ge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGUgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXy5iaW5kKG5hdmlnYXRvcik7XG5cbiAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxuICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgLy8gY29uc3RyYWludHMuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIGNvbnN0IG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgYyA9PiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fCBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cbmZ1bmN0aW9uIHNoaW1PblRyYWNrJDEod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29udHJhY2snLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9vbnRyYWNrcG9seSkge1xuICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IGUgPT4ge1xuICAgICAgICAgIC8vIG9uYWRkc3RyZWFtIGRvZXMgbm90IGZpcmUgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpLmZpbmQociA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRlLnRyYWNrLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0ge1xuICAgICAgICAgICAgICAgIHRyYWNrOiB0ZS50cmFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xuICAgICAgICAgICAgICByZWNlaXZlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2tcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZXZlbiBpZiBSVENSdHBUcmFuc2NlaXZlciBpcyBpbiB3aW5kb3csIGl0IGlzIG9ubHkgdXNlZCBhbmRcbiAgICAvLyBlbWl0dGVkIGluIHVuaWZpZWQtcGxhbi4gVW5mb3J0dW5hdGVseSB0aGlzIG1lYW5zIHdlIG5lZWRcbiAgICAvLyB0byB1bmNvbmRpdGlvbmFsbHkgd3JhcCB0aGUgZXZlbnQuXG4gICAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICAgIGlmICghZS50cmFuc2NlaXZlcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICByZWNlaXZlcjogZS5yZWNlaXZlclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24gKHBjLCB0cmFjaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIGdldCBkdG1mKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBwYy5jcmVhdGVEVE1GU2VuZGVyKHRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgICAgfSxcbiAgICAgICAgX3BjOiBwY1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYXVnbWVudCBhZGRUcmFjayB3aGVuIGdldFNlbmRlcnMgaXMgbm90IGF2YWlsYWJsZS5cbiAgICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kZXJzLnNsaWNlKCk7IC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlLlxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgICBsZXQgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgc2VuZGVyID0gc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKTtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuX3NlbmRlcnMuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgIC8vIHJlbW92ZSBzZW5kZXJcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgISgnZHRtZicgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PlxuICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxuICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcbiAgICAgICAqICAgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGlkZW50aWZ5IHRoZSBSVENSdHBTZW5kZXIuXG4gICAgICAgKi9cbiAgICAgIGZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHNoaW0gcmVjZWl2ZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gICAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHJlY2VpdmVyLnRyYWNrLCBmYWxzZSkpO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh0cmFjaykuXG4gIGNvbnN0IG9yaWdHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGV0IHNlbmRlcjtcbiAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgIGxldCBlcnI7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHMgPT4ge1xuICAgICAgICBpZiAocy50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFJlY2VpdmVycygpLmZvckVhY2gociA9PiB7XG4gICAgICAgIGlmIChyLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjZWl2ZXIgPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIgfHwgc2VuZGVyICYmIHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgfSBlbHNlIGlmIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBpcyBubyBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XG4gIC8vIHNoaW0gYWRkVHJhY2svcmVtb3ZlVHJhY2sgd2l0aCBuYXRpdmUgdmFyaWFudHMgaW4gb3JkZXIgdG8gbWFrZVxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLm1hcChzdHJlYW1JZCA9PiB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXVswXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW0sIHNlbmRlcl07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0uaW5kZXhPZihzZW5kZXIpID09PSAtMSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbmRlcjtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbHRlcihuZXdTZW5kZXIgPT4gZXhpc3RpbmdTZW5kZXJzLmluZGV4T2YobmV3U2VuZGVyKSA9PT0gLTEpO1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW1dLmNvbmNhdChuZXdTZW5kZXJzKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBpZiAoc2VuZGVyKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKHN0cmVhbUlkID0+IHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNoaW0gYWRkVHJhY2sgYW5kIHJlbW92ZVRyYWNrLlxuICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY1KSB7XG4gICAgcmV0dXJuIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpO1xuICB9XG5cbiAgLy8gYWxzbyBzaGltIHBjLmdldExvY2FsU3RyZWFtcyB3aGVuIGFkZFRyYWNrIGlzIHNoaW1tZWRcbiAgLy8gdG8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJlYW1zLlxuICBjb25zdCBvcmlnR2V0TG9jYWxTdHJlYW1zID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgIGNvbnN0IG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKHN0cmVhbSA9PiB0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxuICAgIGlmICghdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFt0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gfHwgc3RyZWFtXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JldmVyc2VTdHJlYW1zW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXS5pZCA6IHN0cmVhbS5pZF07XG4gICAgZGVsZXRlIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCAhPT0gMSB8fCAhc3RyZWFtc1swXS5nZXRUcmFja3MoKS5maW5kKHQgPT4gdCA9PT0gdHJhY2spKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAvLyBbW2Fzc29jaWF0ZWQgTWVkaWFTdHJlYW1zXV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBhZGFwdGVyLmpzIGFkZFRyYWNrIHBvbHlmaWxsIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgJyArICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsICdOb3RTdXBwb3J0ZWRFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIGNvbnN0IG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICBpZiAob2xkU3RyZWFtKSB7XG4gICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcbiAgICAgIC8vIE5vdGU6IHdlIHJlbHkgb24gdGhlIGhpZ2gtbGV2ZWwgYWRkVHJhY2svZHRtZiBzaGltIHRvXG4gICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXG4gICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAvLyBUcmlnZ2VyIE9OTiBhc3luYy5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHRoaXMuYWRkU3RyZWFtKG5ld1N0cmVhbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICB9O1xuXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXG4gIC8vIHZpY2UgdmVyc2EuXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoaW50ZXJuYWxTdHJlYW0uaWQsICdnJyksIGV4dGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChleHRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY29uc3QgaXNMZWdhY3lDYWxsID0gYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoaXNMZWdhY3lDYWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzYyA9IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NdKTtcbiAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3VtZW50c1syXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGRlc2NyaXB0aW9uID0+IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgfSk7XG4gIGNvbnN0IG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCAhYXJndW1lbnRzWzBdLnR5cGUpIHtcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhcmd1bWVudHNbMF0gPSByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIFRPRE86IG1hbmdsZSBnZXRTdGF0czogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y21lZGlhc3RyZWFtc3RhdHMtc3RyZWFtaWRlbnRpZmllclxuXG4gIGNvbnN0IG9yaWdMb2NhbERlc2NyaXB0aW9uID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBvcmlnTG9jYWxEZXNjcmlwdGlvbi5nZXQuYXBwbHkodGhpcyk7XG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9XG4gICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgIC8vIHNpbmNlIHdlIHNoaW0gUlRQU2VuZGVyLiBTbyB3ZSBjaGVjayBpZiBzZW5kZXIuX3BjIGlzIHNldC5cbiAgICBpZiAoIXNlbmRlci5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nLCAnVHlwZUVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzTG9jYWwgPSBzZW5kZXIuX3BjID09PSB0aGlzO1xuICAgIGlmICghaXNMb2NhbCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5hdGl2ZSBzdHJlYW0gdGhlIHNlbmRlcnMgdHJhY2sgYmVsb25ncyB0by5cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICBsZXQgc3RyZWFtO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0cmVhbXMpLmZvckVhY2goc3RyZWFtaWQgPT4ge1xuICAgICAgY29uc3QgaGFzVHJhY2sgPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXS5nZXRUcmFja3MoKS5maW5kKHRyYWNrID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGhhc1RyYWNrKSB7XG4gICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcbiAgICAgICAgLy8gdGFrZXMgY2FyZSBvZiBhbnkgc2hpbW1lZCBfc2VuZGVycy5cbiAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBzYW1lIG9kZCBjaHJvbWUgYmVoYXZpb3VyIGFzIGFib3ZlLlxuICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICAgIFttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIEF0dGVtcHQgdG8gZml4IE9OTiBpbiBwbGFuLWIgbW9kZS5cbmZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBlID0+IHtcbiAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgcGMuZ2V0Q29uZmlndXJhdGlvbiAmJiBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxudmFyIGNocm9tZVNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZml4TmVnb3RpYXRpb25OZWVkZWQ6IGZpeE5lZ290aWF0aW9uTmVlZGVkLFxuICBzaGltQWRkVHJhY2tSZW1vdmVUcmFjazogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2ssXG4gIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZTogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlLFxuICBzaGltR2V0U2VuZGVyc1dpdGhEdG1mOiBzaGltR2V0U2VuZGVyc1dpdGhEdG1mLFxuICBzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDIsXG4gIHNoaW1NZWRpYVN0cmVhbTogc2hpbU1lZGlhU3RyZWFtLFxuICBzaGltT25UcmFjazogc2hpbU9uVHJhY2skMSxcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24kMSxcbiAgc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHM6IHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzXG59KTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICBkZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJywgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcbiAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcbiAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vekF1dG9HYWluQ29udHJvbCcsICdhdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPSBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICBpZiAoIShjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbykpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgKyAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XG4gICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgZXJyLmNvZGUgPSA4O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7XG4gICAgICAgIG1lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8ubWVkaWFTb3VyY2UgPSBwcmVmZXJyZWRNZWRpYVNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gIH07XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5mdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgLy8gc2hpbSBhd2F5IG5lZWQgZm9yIG9ic29sZXRlIFJUQ0ljZUNhbmRpZGF0ZS9SVENTZXNzaW9uRGVzY3JpcHRpb24uXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1xuICAgICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScgPyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtb2Rlcm5TdGF0c1R5cGVzID0ge1xuICAgIGluYm91bmRydHA6ICdpbmJvdW5kLXJ0cCcsXG4gICAgb3V0Ym91bmRydHA6ICdvdXRib3VuZC1ydHAnLFxuICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gIH07XG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSkudGhlbihzdGF0cyA9PiB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzICYmICFvblN1Y2MpIHtcbiAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgICBzdGF0LnR5cGUgPSBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSAhPT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEF2b2lkIFR5cGVFcnJvcjogXCJ0eXBlXCIgaXMgcmVhZC1vbmx5LCBpbiBvbGQgdmVyc2lvbnMuIDM0LTQzaXNoXG4gICAgICAgICAgc3RhdHMuZm9yRWFjaCgoc3RhdCwgaSkgPT4ge1xuICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgdHlwZTogbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xuICB9XG4gIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgPyB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKSA6IFByb21pc2UucmVzb2x2ZShuZXcgTWFwKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgfTtcbiAgfVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgZGVwcmVjYXRlZCgncmVtb3ZlU3RyZWFtJywgJ3JlbW92ZVRyYWNrJyk7XG4gICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KSB7XG4gIC8vIHJlbmFtZSBEYXRhQ2hhbm5lbCB0byBSVENEYXRhQ2hhbm5lbCAobmF0aXZlIGZpeCBpbiBGRjYwKTpcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE3Mzg1MVxuICBpZiAod2luZG93LkRhdGFDaGFubmVsICYmICF3aW5kb3cuUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB3aW5kb3cuUlRDRGF0YUNoYW5uZWwgPSB3aW5kb3cuRGF0YUNoYW5uZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlciA9IGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIC8vIFdlYklETCBpbnB1dCBjb2VyY2lvbiBhbmQgdmFsaWRhdGlvblxuICAgICAgbGV0IHNlbmRFbmNvZGluZ3MgPSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnNlbmRFbmNvZGluZ3M7XG4gICAgICBpZiAoc2VuZEVuY29kaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbmRFbmNvZGluZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNlbmRFbmNvZGluZ3MgPSBbLi4uc2VuZEVuY29kaW5nc107XG4gICAgICBjb25zdCBzaG91bGRQZXJmb3JtQ2hlY2sgPSBzZW5kRW5jb2RpbmdzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICBzZW5kRW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmdQYXJhbSA9PiB7XG4gICAgICAgICAgaWYgKCdyaWQnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcbiAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gb3JpZ0FkZFRyYW5zY2VpdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbml0IG9wdGlvbnMgd2VyZSBhcHBsaWVkLiBJZiBub3Qgd2UgZG8gdGhpcyBpbiBhblxuICAgICAgICAvLyBhc3luY2hyb25vdXMgd2F5IGFuZCBzYXZlIHRoZSBwcm9taXNlIHJlZmVyZW5jZSBpbiBhIGdsb2JhbCBvYmplY3QuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gdWdseSBoYWNrLCBidXQgYXQgdGhlIHNhbWUgdGltZSBpcyB3YXkgbW9yZSByb2J1c3QgdGhhblxuICAgICAgICAvLyBjaGVja2luZyB0aGUgc2VuZGVyIHBhcmFtZXRlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3JlYXRlT2ZmZXJcbiAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYWZ0ZXIgdGhlIGNyZWF0ZW9mZmVyIHdlIGFyZSBub3QgMTAwJSBzdXJlIHRoYXRcbiAgICAgICAgLy8gdGhlIHBhcmFtcyB3ZXJlIGFzeW5jaHJvbm91c2x5IGFwcGxpZWQgc28gd2UgbWlnaHQgbWlzcyB0aGVcbiAgICAgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcmVjcmVhdGUgb2ZmZXIuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZW5kZXJcbiAgICAgICAgfSA9IHRyYW5zY2VpdmVyO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XG4gICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDEgJiYgT2JqZWN0LmtleXMocGFyYW1zLmVuY29kaW5nc1swXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFBhcmFtZXRlcnMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRQYXJhbWV0ZXJzID0gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycztcbiAgaWYgKG9yaWdHZXRQYXJhbWV0ZXJzKSB7XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBvcmlnR2V0UGFyYW1ldGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBmaXJlZm94U2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzaGltQWRkVHJhbnNjZWl2ZXI6IHNoaW1BZGRUcmFuc2NlaXZlcixcbiAgc2hpbUNyZWF0ZUFuc3dlcjogc2hpbUNyZWF0ZUFuc3dlcixcbiAgc2hpbUNyZWF0ZU9mZmVyOiBzaGltQ3JlYXRlT2ZmZXIsXG4gIHNoaW1HZXREaXNwbGF5TWVkaWE6IHNoaW1HZXREaXNwbGF5TWVkaWEsXG4gIHNoaW1HZXRQYXJhbWV0ZXJzOiBzaGltR2V0UGFyYW1ldGVycyxcbiAgc2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSQxLFxuICBzaGltT25UcmFjazogc2hpbU9uVHJhY2ssXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogc2hpbVBlZXJDb25uZWN0aW9uLFxuICBzaGltUlRDRGF0YUNoYW5uZWw6IHNoaW1SVENEYXRhQ2hhbm5lbCxcbiAgc2hpbVJlY2VpdmVyR2V0U3RhdHM6IHNoaW1SZWNlaXZlckdldFN0YXRzLFxuICBzaGltUmVtb3ZlU3RyZWFtOiBzaGltUmVtb3ZlU3RyZWFtLFxuICBzaGltU2VuZGVyR2V0U3RhdHM6IHNoaW1TZW5kZXJHZXRTdGF0c1xufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldExvY2FsU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RyZWFtcztcbiAgICB9O1xuICB9XG4gIGlmICghKCdhZGRTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgY29uc3QgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXG4gICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLCBzdHJlYW0pKTtcbiAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xuICAgIH07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbXMpIHtcbiAgICAgICAgc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICBpZiAodHJhY2tzLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0UmVtb3RlU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXMgPyB0aGlzLl9yZW1vdGVTdHJlYW1zIDogW107XG4gICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGUgPT4ge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgY29uc3QgcGMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLl9vbmFkZHN0cmVhbXBvbHkpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghcGMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYy5fcmVtb3RlU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DYWxsYmFja3NBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIGNvbnN0IHNldExvY2FsRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgY29uc3Qgc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIGNvbnN0IGFkZEljZUNhbmRpZGF0ZSA9IHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIHByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBzZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gYWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIFtjYW5kaWRhdGVdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gd2l0aENhbGxiYWNrO1xufVxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBjb25zdHJhaW50cyA9PiB7XG4gICAgICByZXR1cm4gX2dldFVzZXJNZWRpYShzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpKTtcbiAgICB9O1xuICB9XG4gIGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihjYiwgZXJyY2IpO1xuICAgIH0uYmluZChuYXZpZ2F0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMsIHtcbiAgICAgIHZpZGVvOiBjb21wYWN0T2JqZWN0KGNvbnN0cmFpbnRzLnZpZGVvKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xuICBjb25zdCBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcbiAgICAgICAgaWYgKHNlcnZlci51cmxzID09PSB1bmRlZmluZWQgJiYgc2VydmVyLnVybCkge1xuICAgICAgICAgIGRlcHJlY2F0ZWQoJ1JUQ0ljZVNlcnZlci51cmwnLCAnUlRDSWNlU2VydmVyLnVybHMnKTtcbiAgICAgICAgICBzZXJ2ZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlcikpO1xuICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICBkZWxldGUgc2VydmVyLnVybDtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2goc2VydmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gocGNDb25maWcuaWNlU2VydmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBjQ29uZmlnLmljZVNlcnZlcnMgPSBuZXdJY2VTZXJ2ZXJzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gIH07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBPcmlnUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICBpZiAoJ2dlbmVyYXRlQ2VydGlmaWNhdGUnIGluIE9yaWdQZWVyQ29ubmVjdGlvbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gT3JpZ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIEFkZCBldmVudC50cmFuc2NlaXZlciBtZW1iZXIgb3ZlciBkZXByZWNhdGVkIGV2ZW50LnJlY2VpdmVyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpIHtcbiAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xuICAgICAgfVxuICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gZmFsc2UgJiYgYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gdHJ1ZSAmJiAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHtcbiAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlkZW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UgJiYgdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJiAhdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtcbiAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BdWRpb0NvbnRleHQod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCB3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xufVxuXG52YXIgc2FmYXJpU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzaGltQXVkaW9Db250ZXh0OiBzaGltQXVkaW9Db250ZXh0LFxuICBzaGltQ2FsbGJhY2tzQVBJOiBzaGltQ2FsbGJhY2tzQVBJLFxuICBzaGltQ29uc3RyYWludHM6IHNoaW1Db25zdHJhaW50cyxcbiAgc2hpbUNyZWF0ZU9mZmVyTGVnYWN5OiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3ksXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEsXG4gIHNoaW1Mb2NhbFN0cmVhbXNBUEk6IHNoaW1Mb2NhbFN0cmVhbXNBUEksXG4gIHNoaW1SVENJY2VTZXJ2ZXJVcmxzOiBzaGltUlRDSWNlU2VydmVyVXJscyxcbiAgc2hpbVJlbW90ZVN0cmVhbXNBUEk6IHNoaW1SZW1vdGVTdHJlYW1zQVBJLFxuICBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyOiBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyXG59KTtcblxudmFyIHNkcCQxID0ge2V4cG9ydHM6IHt9fTtcblxuLyogZXNsaW50LWVudiBub2RlICovXG52YXIgaGFzUmVxdWlyZWRTZHA7XG5mdW5jdGlvbiByZXF1aXJlU2RwKCkge1xuICBpZiAoaGFzUmVxdWlyZWRTZHApIHJldHVybiBzZHAkMS5leHBvcnRzO1xuICBoYXNSZXF1aXJlZFNkcCA9IDE7XG4gIChmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgICAvLyBTRFAgaGVscGVycy5cbiAgICBjb25zdCBTRFBVdGlscyA9IHt9O1xuXG4gICAgLy8gR2VuZXJhdGUgYW4gYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIGNuYW1lIG9yIG1pZHMuXG4gICAgLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbiAgICBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbiAgICB9O1xuXG4gICAgLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG4gICAgU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4gICAgLy8gU3BsaXRzIFNEUCBpbnRvIGxpbmVzLCBkZWFsaW5nIHdpdGggYm90aCBDUkxGIGFuZCBMRi5cbiAgICBTRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICAgIH07XG4gICAgLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG4gICAgU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gICAgICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbicpO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uLlxuICAgIFNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgICAgIHJldHVybiBzZWN0aW9ucyAmJiBzZWN0aW9uc1swXTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBtZWRpYSBzZWN0aW9ucy5cbiAgICBTRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gc2VjdGlvbnM7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXG4gICAgU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbiAoYmxvYiwgcHJlZml4KSB7XG4gICAgICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMCk7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44LjhcbiAgICAvLyBycG9ydCA1NTk5NlwiXG4gICAgLy8gSW5wdXQgY2FuIGJlIHByZWZpeGVkIHdpdGggYT0uXG4gICAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgbGV0IHBhcnRzO1xuICAgICAgLy8gUGFyc2UgYm90aCB2YXJpYW50cy5cbiAgICAgIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTIpLnNwbGl0KCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuZGlkYXRlID0ge1xuICAgICAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICAgICAgY29tcG9uZW50OiB7XG4gICAgICAgICAgMTogJ3J0cCcsXG4gICAgICAgICAgMjogJ3J0Y3AnXG4gICAgICAgIH1bcGFydHNbMV1dIHx8IHBhcnRzWzFdLFxuICAgICAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgICAgIGlwOiBwYXJ0c1s0XSxcbiAgICAgICAgYWRkcmVzczogcGFydHNbNF0sXG4gICAgICAgIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgICAgICAvLyBza2lwIHBhcnRzWzZdID09ICd0eXAnXG4gICAgICAgIHR5cGU6IHBhcnRzWzddXG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICAgICAgY2FzZSAncmFkZHInOlxuICAgICAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncnBvcnQnOlxuICAgICAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0ID0gcGFyc2VJbnQocGFydHNbaSArIDFdLCAxMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0Y3B0eXBlJzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZS50Y3BUeXBlID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndWZyYWcnOlxuICAgICAgICAgICAgY2FuZGlkYXRlLnVmcmFnID0gcGFydHNbaSArIDFdOyAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjYW5kaWRhdGVbcGFydHNbaV1dID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfTtcblxuICAgIC8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4gICAgLy8gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBhPSBwcmVmaXghXG4gICAgU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUgPSBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgICBjb25zdCBzZHAgPSBbXTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNhbmRpZGF0ZS5jb21wb25lbnQ7XG4gICAgICBpZiAoY29tcG9uZW50ID09PSAncnRwJykge1xuICAgICAgICBzZHAucHVzaCgxKTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50ID09PSAncnRjcCcpIHtcbiAgICAgICAgc2RwLnB1c2goMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZHAucHVzaChjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5hZGRyZXNzIHx8IGNhbmRpZGF0ZS5pcCk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG4gICAgICBjb25zdCB0eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gICAgICBzZHAucHVzaCgndHlwJyk7XG4gICAgICBzZHAucHVzaCh0eXBlKTtcbiAgICAgIGlmICh0eXBlICE9PSAnaG9zdCcgJiYgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzICYmIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCkge1xuICAgICAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUgJiYgY2FuZGlkYXRlLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICd0Y3AnKSB7XG4gICAgICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpIHtcbiAgICAgICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4gICAgLy8gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9aWNlLW9wdGlvbnM6Zm9vIGJhclxuICAgIFNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXG4gICAgU0RQVXRpbHMucGFyc2VSdHBNYXAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSAvLyB3YXM6IGlkXG4gICAgICB9O1xuICAgICAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuICAgICAgcGFyc2VkLm5hbWUgPSBwYXJ0c1swXTtcbiAgICAgIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICAgICAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gICAgICAvLyBsZWdhY3kgYWxpYXMsIGdvdCByZW5hbWVkIGJhY2sgdG8gY2hhbm5lbHMgaW4gT1JUQy5cbiAgICAgIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnNlZC5jaGFubmVscztcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlcyBhIHJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4gICAgLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLndyaXRlUnRwTWFwID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzIHx8IGNvZGVjLm51bUNoYW5uZWxzIHx8IDE7XG4gICAgICByZXR1cm4gJ2E9cnRwbWFwOicgKyBwdCArICcgJyArIGNvZGVjLm5hbWUgKyAnLycgKyBjb2RlYy5jbG9ja1JhdGUgKyAoY2hhbm5lbHMgIT09IDEgPyAnLycgKyBjaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICAgIGRpcmVjdGlvbjogcGFydHNbMF0uaW5kZXhPZignLycpID4gMCA/IHBhcnRzWzBdLnNwbGl0KCcvJylbMV0gOiAnc2VuZHJlY3YnLFxuICAgICAgICB1cmk6IHBhcnRzWzFdLFxuICAgICAgICBhdHRyaWJ1dGVzOiBwYXJ0cy5zbGljZSgyKS5qb2luKCcgJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlcyBhbiBleHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3JcbiAgICAvLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXG4gICAgU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbiAoaGVhZGVyRXh0ZW5zaW9uKSB7XG4gICAgICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgKyAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiA6ICcnKSArICcgJyArIGhlYWRlckV4dGVuc2lvbi51cmkgKyAoaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgPyAnICcgKyBoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA6ICcnKSArICdcXHJcXG4nO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYSBmbXRwIGxpbmUsIHJldHVybnMgZGljdGlvbmFyeS4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4gICAgLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG4gICAgU0RQVXRpbHMucGFyc2VGbXRwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHt9O1xuICAgICAgbGV0IGt2O1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGt2ID0gcGFydHNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZXMgYSBmbXRwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLndyaXRlRm10cCA9IGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgbGV0IGxpbmUgPSAnJztcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxuICAgICAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgbGV0IGxpbmVzID0gJyc7XG4gICAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZiID0+IHtcbiAgICAgICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgKyAoZmIucGFyYW1ldGVyICYmIGZiLnBhcmFtZXRlci5sZW5ndGggPyAnICcgKyBmYi5wYXJhbWV0ZXIgOiAnJykgKyAnXFxyXFxuJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG4gICAgU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgICAgIGNvbnN0IHBhcnRzID0ge1xuICAgICAgICBzc3JjOiBwYXJzZUludChsaW5lLnN1YnN0cmluZyg3LCBzcCksIDEwKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICAgICAgaWYgKGNvbG9uID4gLTEpIHtcbiAgICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxLCBjb2xvbik7XG4gICAgICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlIGEgc3NyYy1ncm91cCBsaW5lIChzZWUgUkZDIDU1NzYpLiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1zc3JjLWdyb3VwOnNlbWFudGljcyAxMiAzNFxuICAgIFNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTMpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgICAgIHNzcmNzOiBwYXJ0cy5tYXAoc3NyYyA9PiBwYXJzZUludChzc3JjLCAxMCkpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4gICAgLy8gUmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG4gICAgU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XG4gICAgICBpZiAobWlkKSB7XG4gICAgICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG4gICAgU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAvLyBhbGdvcml0aG0gaXMgY2FzZS1zZW5zaXRpdmUgaW4gRWRnZS5cbiAgICAgICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCkgLy8gdGhlIGRlZmluaXRpb24gaXMgdXBwZXItY2FzZSBpbiBSRkMgNDU3Mi5cbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuICAgIC8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuICAgIC8vICAgZ2V0IHRoZSBmaW5nZXJwcmludCBsaW5lIGFzIGlucHV0LiBTZWUgYWxzbyBnZXRJY2VQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWZpbmdlcnByaW50OicpO1xuICAgICAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZSBpbiBFZGdlLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ2F1dG8nLFxuICAgICAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuICAgIFNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgICAgIGxldCBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gICAgICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnAgPT4ge1xuICAgICAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZHA7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhPWNyeXB0byBsaW5lcyBpbnRvXG4gICAgLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI2RpY3Rpb25hcnktcnRjc3J0cHNkZXNwYXJhbWV0ZXJzLW1lbWJlcnNcbiAgICBTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAgICAgIGtleVBhcmFtczogcGFydHNbMl0sXG4gICAgICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpXG4gICAgICB9O1xuICAgIH07XG4gICAgU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybiAnYT1jcnlwdG86JyArIHBhcmFtZXRlcnMudGFnICsgJyAnICsgcGFyYW1ldGVycy5jcnlwdG9TdWl0ZSArICcgJyArICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnID8gU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMocGFyYW1ldGVycy5rZXlQYXJhbXMpIDogcGFyYW1ldGVycy5rZXlQYXJhbXMpICsgKHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcyA/ICcgJyArIHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcy5qb2luKCcgJykgOiAnJykgKyAnXFxyXFxuJztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xuICAgIC8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG4gICAgU0RQVXRpbHMucGFyc2VDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbiAoa2V5UGFyYW1zKSB7XG4gICAgICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5TWV0aG9kOiAnaW5saW5lJyxcbiAgICAgICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgICAgIGxpZmVUaW1lOiBwYXJ0c1sxXSxcbiAgICAgICAgbWtpVmFsdWU6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVswXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfTtcbiAgICBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICAgIHJldHVybiBrZXlQYXJhbXMua2V5TWV0aG9kICsgJzonICsga2V5UGFyYW1zLmtleVNhbHQgKyAoa2V5UGFyYW1zLmxpZmVUaW1lID8gJ3wnICsga2V5UGFyYW1zLmxpZmVUaW1lIDogJycpICsgKGtleVBhcmFtcy5ta2lWYWx1ZSAmJiBrZXlQYXJhbXMubWtpTGVuZ3RoID8gJ3wnICsga2V5UGFyYW1zLm1raVZhbHVlICsgJzonICsga2V5UGFyYW1zLm1raUxlbmd0aCA6ICcnKTtcbiAgICB9O1xuXG4gICAgLy8gRXh0cmFjdHMgYWxsIFNERVMgcGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWNyeXB0bzonKTtcbiAgICAgIHJldHVybiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuICAgIC8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuICAgIC8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXG4gICAgU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgICBjb25zdCB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtdWZyYWc6JylbMF07XG4gICAgICBjb25zdCBwd2QgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9aWNlLXB3ZDonKVswXTtcbiAgICAgIGlmICghKHVmcmFnICYmIHB3ZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VybmFtZUZyYWdtZW50OiB1ZnJhZy5zdWJzdHJpbmcoMTIpLFxuICAgICAgICBwYXNzd29yZDogcHdkLnN1YnN0cmluZygxMClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuICAgIFNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIGxldCBzZHAgPSAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgKyAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgICAgIGlmIChwYXJhbXMuaWNlTGl0ZSkge1xuICAgICAgICBzZHAgKz0gJ2E9aWNlLWxpdGVcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICAgICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgICAgIHJ0Y3A6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gICAgICBkZXNjcmlwdGlvbi5wcm9maWxlID0gbWxpbmVbMl07XG4gICAgICBmb3IgKGxldCBpID0gMzsgaSA8IG1saW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICAgICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICAgICAgY29uc3QgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRwbWFwOicgKyBwdCArICcgJylbMF07XG4gICAgICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICAgICAgY29uc3QgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgICAgICBjb25zdCBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xuICAgICAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKS5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cbiAgICAgICAgICBzd2l0Y2ggKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgICAgIGNhc2UgJ1VMUEZFQyc6XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMucHVzaChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgIGRlc2NyaXB0aW9uLmhlYWRlckV4dGVuc2lvbnMucHVzaChTRFBVdGlscy5wYXJzZUV4dG1hcChsaW5lKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHdpbGRjYXJkUnRjcEZiID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOiogJykubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYiA9PiB7XG4gICAgICAgICAgY29uc3QgZHVwbGljYXRlID0gY29kZWMucnRjcEZlZWRiYWNrLmZpbmQoZXhpc3RpbmdGZWVkYmFjayA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdGZWVkYmFjay50eXBlID09PSBmYi50eXBlICYmIGV4aXN0aW5nRmVlZGJhY2sucGFyYW1ldGVyID09PSBmYi5wYXJhbWV0ZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5wdXNoKGZiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBGSVhNRTogcGFyc2UgcnRjcC5cbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xuICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChraW5kLCBjYXBzKSB7XG4gICAgICBsZXQgc2RwID0gJyc7XG5cbiAgICAgIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgICAgIHNkcCArPSAnbT0nICsga2luZCArICcgJztcbiAgICAgIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICAgICAgc2RwICs9ICcgJyArIChjYXBzLnByb2ZpbGUgfHwgJ1VEUC9UTFMvUlRQL1NBVlBGJykgKyAnICc7XG4gICAgICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGNvZGVjID0+IHtcbiAgICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG4gICAgICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICAgICAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgICAgIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxuICAgICAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICAgICAgfSk7XG4gICAgICBsZXQgbWF4cHRpbWUgPSAwO1xuICAgICAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgY2Fwcy5oZWFkZXJFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgICAgIHJldHVybiBzZHA7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICAvLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICBjb25zdCBoYXNSZWQgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1JFRCcpICE9PSAtMTtcbiAgICAgIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gICAgICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gICAgICBjb25zdCBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKS5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSkuZmlsdGVyKHBhcnRzID0+IHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJyk7XG4gICAgICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgICAgIGxldCBzZWNvbmRhcnlTc3JjO1xuICAgICAgY29uc3QgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJykubWFwKGxpbmUgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE3KS5zcGxpdCgnICcpO1xuICAgICAgICByZXR1cm4gcGFydHMubWFwKHBhcnQgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICAgICAgc2Vjb25kYXJ5U3NyYyA9IGZsb3dzWzBdWzFdO1xuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgICAgIGxldCBlbmNQYXJhbSA9IHtcbiAgICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgICAgIGVuY1BhcmFtLnJ0eCA9IHtcbiAgICAgICAgICAgICAgc3NyYzogc2Vjb25kYXJ5U3NyY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xuICAgICAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGggPT09IDAgJiYgcHJpbWFyeVNzcmMpIHtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgICAgIGxldCBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xuICAgICAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDcpLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcbiAgICAgICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg1KSwgMTApICogMTAwMCAqIDAuOTUgLSA1MCAqIDQwICogODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2gocGFyYW1zID0+IHtcbiAgICAgICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgIH07XG5cbiAgICAvLyBwYXJzZXMgaHR0cDovL2RyYWZ0Lm9ydGMub3JnLyNydGNydGNwcGFyYW1ldGVycypcbiAgICBTRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICAgICAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGF0IHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXG4gICAgICAvLyBTU1JDcy5cbiAgICAgIGNvbnN0IHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihvYmogPT4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJylbMF07XG4gICAgICBpZiAocmVtb3RlU3NyYykge1xuICAgICAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgICAgIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgPSByZW1vdGVTc3JjLnNzcmM7XG4gICAgICB9XG5cbiAgICAgIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgICAgIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxuICAgICAgY29uc3QgcnNpemUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtcnNpemUnKTtcbiAgICAgIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgICAgIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gICAgICAvLyBwYXJzZXMgdGhlIHJ0Y3AtbXV4IGF0dHLRlmJ1dGUuXG4gICAgICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgICAgIGNvbnN0IG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcbiAgICAgIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuICAgICAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xuICAgIH07XG4gICAgU0RQVXRpbHMud3JpdGVSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChydGNwUGFyYW1ldGVycykge1xuICAgICAgbGV0IHNkcCA9ICcnO1xuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplKSB7XG4gICAgICAgIHNkcCArPSAnYT1ydGNwLXJzaXplXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChydGNwUGFyYW1ldGVycy5tdXgpIHtcbiAgICAgICAgc2RwICs9ICdhPXJ0Y3AtbXV4XFxyXFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChydGNwUGFyYW1ldGVycy5zc3JjICE9PSB1bmRlZmluZWQgJiYgcnRjcFBhcmFtZXRlcnMuY25hbWUpIHtcbiAgICAgICAgc2RwICs9ICdhPXNzcmM6JyArIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgKyAnIGNuYW1lOicgKyBydGNwUGFyYW1ldGVycy5jbmFtZSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9O1xuXG4gICAgLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuICAgIC8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG4gICAgU0RQVXRpbHMucGFyc2VNc2lkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgbGV0IHBhcnRzO1xuICAgICAgY29uc3Qgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgICAgIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyaW5nKDcpLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyZWFtOiBwYXJ0c1swXSxcbiAgICAgICAgICB0cmFjazogcGFydHNbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIobXNpZFBhcnRzID0+IG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gICAgICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyZWFtOiBwYXJ0c1swXSxcbiAgICAgICAgICB0cmFjazogcGFydHNbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU0NUUFxuICAgIC8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xuICAgIC8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XG4gICAgU0RQVXRpbHMucGFyc2VTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IG1heFNpemVMaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICAgICAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICAgICAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXhTaXplTGluZVswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICAgICAgaWYgKHNjdHBQb3J0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXG4gICAgICAgICAgcHJvdG9jb2w6IG1saW5lLmZtdCxcbiAgICAgICAgICBtYXhNZXNzYWdlU2l6ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2N0cE1hcExpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpO1xuICAgICAgaWYgKHNjdHBNYXBMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gc2N0cE1hcExpbmVzWzBdLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgICAgIHByb3RvY29sOiBwYXJ0c1sxXSxcbiAgICAgICAgICBtYXhNZXNzYWdlU2l6ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTQ1RQXG4gICAgLy8gb3V0cHV0cyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgdmVyc2lvbiB0aGF0IGFsbCBicm93c2Vyc1xuICAgIC8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXG4gICAgLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbiAgICAvLyBwcm90b2NvbCBvZiBEVExTL1NDVFAgLS0gd2l0aG91dCBVRFAvIG9yIFRDUC8pXG4gICAgU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWEsIHNjdHApIHtcbiAgICAgIGxldCBvdXRwdXQgPSBbXTtcbiAgICAgIGlmIChtZWRpYS5wcm90b2NvbCAhPT0gJ0RUTFMvU0NUUCcpIHtcbiAgICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJywgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLCAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IFsnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJywgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLCAnYT1zY3RwbWFwOicgKyBzY3RwLnBvcnQgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJyA2NTUzNVxcclxcbiddO1xuICAgICAgfVxuICAgICAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQucHVzaCgnYT1tYXgtbWVzc2FnZS1zaXplOicgKyBzY3RwLm1heE1lc3NhZ2VTaXplICsgJ1xcclxcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuICAgIC8vIHJlY29tbWVuZHMgdXNpbmcgYSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gK3ZlIDY0LWJpdCB2YWx1ZVxuICAgIC8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuICAgIFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMjIpO1xuICAgIH07XG5cbiAgICAvLyBXcml0ZSBib2lsZXIgcGxhdGUgZm9yIHN0YXJ0IG9mIFNEUFxuICAgIC8vIHNlc3NJZCBhcmd1bWVudCBpcyBvcHRpb25hbCAtIGlmIG5vdCBzdXBwbGllZCBpdCB3aWxsXG4gICAgLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4gICAgLy8gc2Vzc1ZlcnNpb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDJcbiAgICAvLyBzZXNzVXNlciBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RoaXNpc2FkYXB0ZXJvcnRjJ1xuICAgIFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24gKHNlc3NJZCwgc2Vzc1Zlciwgc2Vzc1VzZXIpIHtcbiAgICAgIGxldCBzZXNzaW9uSWQ7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XG4gICAgICBpZiAoc2Vzc0lkKSB7XG4gICAgICAgIHNlc3Npb25JZCA9IHNlc3NJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcbiAgICAgIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICAgICAgcmV0dXJuICd2PTBcXHJcXG4nICsgJ289JyArIHVzZXIgKyAnICcgKyBzZXNzaW9uSWQgKyAnICcgKyB2ZXJzaW9uICsgJyBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArICdzPS1cXHJcXG4nICsgJ3Q9MCAwXFxyXFxuJztcbiAgICB9O1xuXG4gICAgLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG4gICAgU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICAgIC8vIExvb2sgZm9yIHNlbmRyZWN2LCBzZW5kb25seSwgcmVjdm9ubHksIGluYWN0aXZlLCBkZWZhdWx0IHRvIHNlbmRyZWN2LlxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAobGluZXNbaV0pIHtcbiAgICAgICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgICAgICBjYXNlICdhPXJlY3Zvbmx5JzpcbiAgICAgICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgLy8gRklYTUU6IFdoYXQgc2hvdWxkIGhhcHBlbiBoZXJlP1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2Vzc2lvbnBhcnQpIHtcbiAgICAgICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3NlbmRyZWN2JztcbiAgICB9O1xuICAgIFNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBtbGluZVswXS5zdWJzdHJpbmcoMik7XG4gICAgfTtcbiAgICBTRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG4gICAgfTtcbiAgICBTRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogcGFydHNbMF0sXG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICAgIHByb3RvY29sOiBwYXJ0c1syXSxcbiAgICAgICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJylcbiAgICAgIH07XG4gICAgfTtcbiAgICBTRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ289JylbMF07XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VybmFtZTogcGFydHNbMF0sXG4gICAgICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgICAgICBuZXRUeXBlOiBwYXJ0c1szXSxcbiAgICAgICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgICAgICBhZGRyZXNzOiBwYXJ0c1s1XVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuICAgIFNEUFV0aWxzLmlzVmFsaWRTRFAgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lc1tpXS5sZW5ndGggPCAyIHx8IGxpbmVzW2ldLmNoYXJBdCgxKSAhPT0gJz0nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIHRoZSBtb2RpZmllciBhIGJpdCBtb3JlLlxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbiAgICB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xuICAgIH1cbiAgfSkoc2RwJDEpO1xuICByZXR1cm4gc2RwJDEuZXhwb3J0cztcbn1cblxudmFyIHNkcEV4cG9ydHMgPSByZXF1aXJlU2RwKCk7XG52YXIgU0RQVXRpbHMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc2RwRXhwb3J0cyk7XG5cbnZhciBzZHAgPSAvKiNfX1BVUkVfXyovX21lcmdlTmFtZXNwYWNlcyh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdDogU0RQVXRpbHNcbn0sIFtzZHBFeHBvcnRzXSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5mdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdykge1xuICAvLyBmb3VuZGF0aW9uIGlzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBhbiBpbmRpY2F0b3IgZm9yIGZ1bGwgc3VwcG9ydCBmb3JcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1wYy8jcnRjaWNlY2FuZGlkYXRlLWludGVyZmFjZVxuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAnZm91bmRhdGlvbicgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIFJUQ0ljZUNhbmRpZGF0ZShhcmdzKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBhPSB3aGljaCBzaG91bGRuJ3QgYmUgcGFydCBvZiB0aGUgY2FuZGlkYXRlIHN0cmluZy5cbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnICYmIGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmluZGV4T2YoJ2E9JykgPT09IDApIHtcbiAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICAgIGFyZ3MuY2FuZGlkYXRlID0gYXJncy5jYW5kaWRhdGUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICBpZiAoYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUubGVuZ3RoKSB7XG4gICAgICAvLyBBdWdtZW50IHRoZSBuYXRpdmUgY2FuZGlkYXRlIHdpdGggdGhlIHBhcnNlZCBmaWVsZHMuXG4gICAgICBjb25zdCBuYXRpdmVDYW5kaWRhdGUgPSBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoYXJncy5jYW5kaWRhdGUpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyc2VkQ2FuZGlkYXRlKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuYXRpdmVDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNhbmRpZGF0ZSwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VkQ2FuZGlkYXRlW2tleV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPdmVycmlkZSBzZXJpYWxpemVyIHRvIG5vdCBzZXJpYWxpemUgdGhlIGV4dHJhIGF0dHJpYnV0ZXMuXG4gICAgICBuYXRpdmVDYW5kaWRhdGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbmRpZGF0ZTogbmF0aXZlQ2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNaWQ6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNaWQsXG4gICAgICAgICAgc2RwTUxpbmVJbmRleDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogbmF0aXZlQ2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmF0aXZlQ2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgfTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUgPSBOYXRpdmVSVENJY2VDYW5kaWRhdGUucHJvdG90eXBlO1xuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZSA9PiB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2NhbmRpZGF0ZScsIHtcbiAgICAgICAgdmFsdWU6IG5ldyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlKSxcbiAgICAgICAgd3JpdGFibGU6ICdmYWxzZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ3JlbGF5UHJvdG9jb2wnIGluIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlLmNhbmRpZGF0ZSk7XG4gICAgICBpZiAocGFyc2VkQ2FuZGlkYXRlLnR5cGUgPT09ICdyZWxheScpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxpYndlYnJ0Yy1zcGVjaWZpYyBtYXBwaW5nIG9mIGxvY2FsIHR5cGUgcHJlZmVyZW5jZVxuICAgICAgICAvLyB0byByZWxheVByb3RvY29sLlxuICAgICAgICBlLmNhbmRpZGF0ZS5yZWxheVByb3RvY29sID0ge1xuICAgICAgICAgIDA6ICd0bHMnLFxuICAgICAgICAgIDE6ICd0Y3AnLFxuICAgICAgICAgIDI6ICd1ZHAnXG4gICAgICAgIH1bcGFyc2VkQ2FuZGlkYXRlLnByaW9yaXR5ID4+IDI0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ3NjdHAnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdzY3RwJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2N0cEluRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICByZXR1cm4gc2VjdGlvbnMuc29tZShtZWRpYVNlY3Rpb24gPT4ge1xuICAgICAgY29uc3QgbUxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgICByZXR1cm4gbUxpbmUgJiYgbUxpbmUua2luZCA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBtTGluZS5wcm90b2NvbC5pbmRleE9mKCdTQ1RQJykgIT09IC0xO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHNvbHV0aW9uIGZvciBkZXRlY3RpbmcgRmlyZWZveD9cbiAgICBjb25zdCBtYXRjaCA9IGRlc2NyaXB0aW9uLnNkcC5tYXRjaCgvbW96aWxsYS4uLlRISVNfSVNfU0RQQVJUQS0oXFxkKykvKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2gubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAvLyBUZXN0IGZvciBOYU4gKHllcywgdGhpcyBpcyB1Z2x5KVxuICAgIHJldHVybiB2ZXJzaW9uICE9PSB2ZXJzaW9uID8gLTEgOiB2ZXJzaW9uO1xuICB9O1xuICBjb25zdCBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbiAocmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gRXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBjYW4gc2VuZCBhdCBsZWFzdCA2NCBLaUIuXG4gICAgLy8gTm90ZTogQWx0aG91Z2ggQ2hyb21lIGlzIHRlY2huaWNhbGx5IGFibGUgdG8gc2VuZCB1cCB0byAyNTYgS2lCLCB0aGVcbiAgICAvLyAgICAgICBkYXRhIGRvZXMgbm90IHJlYWNoIHRoZSBvdGhlciBwZWVyIHJlbGlhYmx5LlxuICAgIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTg0MTlcbiAgICBsZXQgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94Jykge1xuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Nykge1xuICAgICAgICBpZiAocmVtb3RlSXNGaXJlZm94ID09PSAtMSkge1xuICAgICAgICAgIC8vIEZGIDwgNTcgd2lsbCBzZW5kIGluIDE2IEtpQiBjaHVua3MgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgUFBJRFxuICAgICAgICAgIC8vIGZyYWdtZW50YXRpb24uXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMTYzODQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSG93ZXZlciwgb3RoZXIgRkYgKGFuZCBSQVdSVEMpIGNhbiByZWFzc2VtYmxlIFBQSUQtZnJhZ21lbnRlZFxuICAgICAgICAgIC8vIG1lc3NhZ2VzLiBUaHVzLCBzdXBwb3J0aW5nIH4yIEdpQiB3aGVuIHNlbmRpbmcuXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjApIHtcbiAgICAgICAgLy8gQ3VycmVudGx5LCBhbGwgRkYgPj0gNTcgd2lsbCByZXNldCB0aGUgcmVtb3RlIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICAgIC8vIHRvIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gYSBkYXRhIGNoYW5uZWwgaXMgY3JlYXRlZCBhdCBhIGxhdGVyXG4gICAgICAgIC8vIHN0YWdlLiA6KFxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcgPyA2NTUzNSA6IDY1NTM2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRkYgPj0gNjAgc3VwcG9ydHMgc2VuZGluZyB+MiBHaUJcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNlbmRNYXhNZXNzYWdlU2l6ZTtcbiAgfTtcbiAgY29uc3QgZ2V0TWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIE5vdGU6IDY1NTM2IGJ5dGVzIGlzIHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIFNEUCBzcGVjLiBBbHNvLFxuICAgIC8vICAgICAgIGV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgc3VwcG9ydHMgcmVjZWl2aW5nIDY1NTM2IGJ5dGVzLlxuICAgIGxldCBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuXG4gICAgLy8gRkYgNTcgaGFzIGEgc2xpZ2h0bHkgaW5jb3JyZWN0IGRlZmF1bHQgcmVtb3RlIG1heCBtZXNzYWdlIHNpemUsIHNvXG4gICAgLy8gd2UgbmVlZCB0byBhZGp1c3QgaXQgaGVyZSB0byBhdm9pZCBhIGZhaWx1cmUgd2hlbiBzZW5kaW5nLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNTY5N1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcpIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoZGVzY3JpcHRpb24uc2RwLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiByZW1vdGVJc0ZpcmVmb3ggIT09IC0xKSB7XG4gICAgICAvLyBJZiB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJlbW90ZSBTRFAgYW5kXG4gICAgICAvLyBib3RoIGxvY2FsIGFuZCByZW1vdGUgYXJlIEZpcmVmb3gsIHRoZSByZW1vdGUgcGVlciBjYW4gcmVjZWl2ZVxuICAgICAgLy8gfjIgR2lCLlxuICAgICAgbWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgIH1cbiAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gIH07XG4gIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICB0aGlzLl9zY3RwID0gbnVsbDtcbiAgICAvLyBDaHJvbWUgZGVjaWRlZCB0byBub3QgZXhwb3NlIC5zY3RwIGluIHBsYW4tYiBtb2RlLlxuICAgIC8vIEFzIHVzdWFsLCBhZGFwdGVyLmpzIGhhcyB0byBkbyBhbiAndWdseSB3b3Jha2Fyb3VuZCdcbiAgICAvLyB0byBjb3ZlciB1cCB0aGUgbWVzcy5cbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3Nikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZHBTZW1hbnRpY3NcbiAgICAgIH0gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgIGlmIChzZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2N0cCcsIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjdHBJbkRlc2NyaXB0aW9uKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1vdGUgaXMgRkYuXG4gICAgICBjb25zdCBpc0ZpcmVmb3ggPSBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbihhcmd1bWVudHNbMF0pO1xuXG4gICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIHRoZSBsb2NhbCBwZWVyIGlzIGNhcGFibGUgb2Ygc2VuZGluZ1xuICAgICAgY29uc3QgY2FuU2VuZE1NUyA9IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZShpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIG9mIHRoZSByZW1vdGUgcGVlci5cbiAgICAgIGNvbnN0IHJlbW90ZU1NUyA9IGdldE1heE1lc3NhZ2VTaXplKGFyZ3VtZW50c1swXSwgaXNGaXJlZm94KTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gICAgICBpZiAoY2FuU2VuZE1NUyA9PT0gMCAmJiByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9IGVsc2UgaWYgKGNhblNlbmRNTVMgPT09IDAgfHwgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5tYXgoY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5taW4oY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgUlRDU2N0cFRyYW5zcG9ydCBvYmplY3QgYW5kIHRoZSAnbWF4TWVzc2FnZVNpemUnXG4gICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICBjb25zdCBzY3RwID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2N0cCwgJ21heE1lc3NhZ2VTaXplJywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NjdHAgPSBzY3RwO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2NyZWF0ZURhdGFDaGFubmVsJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE5vdGU6IEFsdGhvdWdoIEZpcmVmb3ggPj0gNTcgaGFzIGEgbmF0aXZlIGltcGxlbWVudGF0aW9uLCB0aGUgbWF4aW11bVxuICAvLyAgICAgICBtZXNzYWdlIHNpemUgY2FuIGJlIHJlc2V0IGZvciBhbGwgZGF0YSBjaGFubmVscyBhdCBhIGxhdGVyIHN0YWdlLlxuICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcblxuICBmdW5jdGlvbiB3cmFwRGNTZW5kKGRjLCBwYykge1xuICAgIGNvbnN0IG9yaWdEYXRhQ2hhbm5lbFNlbmQgPSBkYy5zZW5kO1xuICAgIGRjLnNlbmQgPSBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgY29uc3QgZGF0YSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIHx8IGRhdGEuc2l6ZSB8fCBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAoZGMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmIHBjLnNjdHAgJiYgbGVuZ3RoID4gcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSAoY2FuIHNlbmQgYSBtYXhpbXVtIG9mICcgKyBwYy5zY3RwLm1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnRGF0YUNoYW5uZWxTZW5kLmFwcGx5KGRjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZURhdGFDaGFubmVsID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbDtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIGNyZWF0ZURhdGFDaGFubmVsKCkge1xuICAgIGNvbnN0IGRhdGFDaGFubmVsID0gb3JpZ0NyZWF0ZURhdGFDaGFubmVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgd3JhcERjU2VuZChkYXRhQ2hhbm5lbCwgdGhpcyk7XG4gICAgcmV0dXJuIGRhdGFDaGFubmVsO1xuICB9O1xuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdkYXRhY2hhbm5lbCcsIGUgPT4ge1xuICAgIHdyYXBEY1NlbmQoZS5jaGFubmVsLCBlLnRhcmdldCk7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG4vKiBzaGltcyBSVENDb25uZWN0aW9uU3RhdGUgYnkgcHJldGVuZGluZyBpdCBpcyB0aGUgc2FtZSBhcyBpY2VDb25uZWN0aW9uU3RhdGUuXG4gKiBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTYxNDUjYzEyXG4gKiBmb3Igd2h5IHRoaXMgaXMgYSB2YWxpZCBoYWNrIGluIENocm9tZS4gSW4gRmlyZWZveCBpdCBpcyBzbGlnaHRseSBpbmNvcnJlY3RcbiAqIHNpbmNlIERUTFMgZmFpbHVyZXMgd291bGQgYmUgaGlkZGVuLiBTZWVcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNjU4MjdcbiAqIGZvciB0aGUgRmlyZWZveCB0cmFja2luZyBidWcuXG4gKi9cbmZ1bmN0aW9uIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdjb25uZWN0aW9uU3RhdGUnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25uZWN0aW9uU3RhdGUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGxldGVkOiAnY29ubmVjdGVkJyxcbiAgICAgICAgY2hlY2tpbmc6ICdjb25uZWN0aW5nJ1xuICAgICAgfVt0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZV0gfHwgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIHx8IG51bGw7XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBjYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJ10uZm9yRWFjaChtZXRob2QgPT4ge1xuICAgIGNvbnN0IG9yaWdNZXRob2QgPSBwcm90b1ttZXRob2RdO1xuICAgIHByb3RvW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSA9IGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgICAgICAgaWYgKHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlICE9PSBwYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlID0gcGMuY29ubmVjdGlvblN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgRXZlbnQoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGUpO1xuICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvKiByZW1vdmUgYT1leHRtYXAtYWxsb3ctbWl4ZWQgZm9yIHdlYnJ0Yy5vcmcgPCBNNzEgKi9cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjA1KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZVNSRCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKSB7XG4gICAgaWYgKGRlc2MgJiYgZGVzYy5zZHAgJiYgZGVzYy5zZHAuaW5kZXhPZignXFxuYT1leHRtYXAtYWxsb3ctbWl4ZWQnKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHNkcCA9IGRlc2Muc2RwLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgLy8gU2FmYXJpIGVuZm9yY2VzIHJlYWQtb25seS1uZXNzIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBmaWVsZHMuXG4gICAgICBpZiAod2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAmJiBkZXNjIGluc3RhbmNlb2Ygd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgdHlwZTogZGVzYy50eXBlLFxuICAgICAgICAgIHNkcFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc2Muc2RwID0gc2RwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvLyBTdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgYWRkSWNlQ2FuZGlkYXRlKHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0pXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk3ODU4MlxuICAvLyBOb3RlOiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3RoZXIgcG9seWZpbGxzIHdoaWNoIGNoYW5nZSB0aGUgc2lnbmF0dXJlLlxuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIGlmICghbmF0aXZlQWRkSWNlQ2FuZGlkYXRlIHx8IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XG4gICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyBGaXJlZm94IDY4KyBlbWl0cyBhbmQgcHJvY2Vzc2VzIHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0sIGlnbm9yZVxuICAgIC8vIGluIG9sZGVyIHZlcnNpb25zLlxuICAgIC8vIE5hdGl2ZSBzdXBwb3J0IGZvciBpZ25vcmluZyBleGlzdHMgZm9yIENocm9tZSBNNzcrLlxuICAgIC8vIFNhZmFyaSBpZ25vcmVzIGFzIHdlbGwsIGV4YWN0IHZlcnNpb24gdW5rbm93biBidXQgd29ya3MgaW4gdGhlIHNhbWVcbiAgICAvLyB2ZXJzaW9uIHRoYXQgYWxzbyBpZ25vcmVzIGFkZEljZUNhbmRpZGF0ZShudWxsKS5cbiAgICBpZiAoKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3OCB8fCBicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknKSAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBOb3RlOiBNYWtlIHN1cmUgdG8gY2FsbCB0aGlzIGFoZWFkIG9mIEFQSXMgdGhhdCBtb2RpZnlcbi8vIHNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoXG5mdW5jdGlvbiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgaWYgKCFuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uIHx8IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgbGV0IGRlc2MgPSBhcmd1bWVudHNbMF0gfHwge307XG4gICAgaWYgKHR5cGVvZiBkZXNjICE9PSAnb2JqZWN0JyB8fCBkZXNjLnR5cGUgJiYgZGVzYy5zZHApIHtcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8vIFRoZSByZW1haW5pbmcgc3RlcHMgc2hvdWxkIHRlY2huaWNhbGx5IGhhcHBlbiB3aGVuIFNMRCBjb21lcyBvZmYgdGhlXG4gICAgLy8gUlRDUGVlckNvbm5lY3Rpb24ncyBvcGVyYXRpb25zIGNoYWluIChub3QgYWhlYWQgb2YgZ29pbmcgb24gaXQpLCBidXRcbiAgICAvLyB0aGlzIGlzIHRvbyBkaWZmaWN1bHQgdG8gc2hpbS4gSW5zdGVhZCwgdGhpcyBzaGltIG9ubHkgY292ZXJzIHRoZVxuICAgIC8vIGNvbW1vbiBjYXNlIHdoZXJlIHRoZSBvcGVyYXRpb25zIGNoYWluIGlzIGVtcHR5LiBUaGlzIGlzIGltcGVyZmVjdCwgYnV0XG4gICAgLy8gc2hvdWxkIGNvdmVyIG1hbnkgY2FzZXMuIFJhdGlvbmFsZTogRXZlbiBpZiB3ZSBjYW4ndCByZWR1Y2UgdGhlIGdsYXJlXG4gICAgLy8gd2luZG93IHRvIHplcm8gb24gaW1wZXJmZWN0IGltcGxlbWVudGF0aW9ucywgdGhlcmUncyB2YWx1ZSBpbiB0YXBwaW5nXG4gICAgLy8gaW50byB0aGUgcGVyZmVjdCBuZWdvdGlhdGlvbiBwYXR0ZXJuIHRoYXQgc2V2ZXJhbCBicm93c2VycyBzdXBwb3J0LlxuICAgIGRlc2MgPSB7XG4gICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICBzZHA6IGRlc2Muc2RwXG4gICAgfTtcbiAgICBpZiAoIWRlc2MudHlwZSkge1xuICAgICAgc3dpdGNoICh0aGlzLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgJ3N0YWJsZSc6XG4gICAgICAgIGNhc2UgJ2hhdmUtbG9jYWwtb2ZmZXInOlxuICAgICAgICBjYXNlICdoYXZlLXJlbW90ZS1wcmFuc3dlcic6XG4gICAgICAgICAgZGVzYy50eXBlID0gJ29mZmVyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZXNjLnR5cGUgPSAnYW5zd2VyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlc2Muc2RwIHx8IGRlc2MudHlwZSAhPT0gJ29mZmVyJyAmJiBkZXNjLnR5cGUgIT09ICdhbnN3ZXInKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY10pO1xuICAgIH1cbiAgICBjb25zdCBmdW5jID0gZGVzYy50eXBlID09PSAnb2ZmZXInID8gdGhpcy5jcmVhdGVPZmZlciA6IHRoaXMuY3JlYXRlQW5zd2VyO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMpLnRoZW4oZCA9PiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkXSkpO1xuICB9O1xufVxuXG52YXIgY29tbW9uU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICByZW1vdmVFeHRtYXBBbGxvd01peGVkOiByZW1vdmVFeHRtYXBBbGxvd01peGVkLFxuICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHk6IHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSxcbiAgc2hpbUNvbm5lY3Rpb25TdGF0ZTogc2hpbUNvbm5lY3Rpb25TdGF0ZSxcbiAgc2hpbU1heE1lc3NhZ2VTaXplOiBzaGltTWF4TWVzc2FnZVNpemUsXG4gIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbjogc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uLFxuICBzaGltUlRDSWNlQ2FuZGlkYXRlOiBzaGltUlRDSWNlQ2FuZGlkYXRlLFxuICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbDogc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wsXG4gIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3I6IHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Jcbn0pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG5mdW5jdGlvbiBhZGFwdGVyRmFjdG9yeSgpIHtcbiAgbGV0IHtcbiAgICB3aW5kb3dcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgc2hpbUNocm9tZTogdHJ1ZSxcbiAgICBzaGltRmlyZWZveDogdHJ1ZSxcbiAgICBzaGltU2FmYXJpOiB0cnVlXG4gIH07XG4gIC8vIFV0aWxzLlxuICBjb25zdCBsb2dnaW5nID0gbG9nO1xuICBjb25zdCBicm93c2VyRGV0YWlscyA9IGRldGVjdEJyb3dzZXIod2luZG93KTtcbiAgY29uc3QgYWRhcHRlciA9IHtcbiAgICBicm93c2VyRGV0YWlscyxcbiAgICBjb21tb25TaGltLFxuICAgIGV4dHJhY3RWZXJzaW9uOiBleHRyYWN0VmVyc2lvbixcbiAgICBkaXNhYmxlTG9nOiBkaXNhYmxlTG9nLFxuICAgIGRpc2FibGVXYXJuaW5nczogZGlzYWJsZVdhcm5pbmdzLFxuICAgIC8vIEV4cG9zZSBzZHAgYXMgYSBjb252ZW5pZW5jZS4gRm9yIHByb2R1Y3Rpb24gYXBwcyBpbmNsdWRlIGRpcmVjdGx5LlxuICAgIHNkcFxuICB9O1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhc2hpbVBlZXJDb25uZWN0aW9uJDEgfHwgIW9wdGlvbnMuc2hpbUNocm9tZSkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gY2FuIG5vdCBkZXRlcm1pbmUgdmVyc2lvbiwgbm90IHNoaW1taW5nLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XG4gICAgICBzaGltR2V0VXNlck1lZGlhJDIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltTWVkaWFTdHJlYW0od2luZG93KTtcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU9uVHJhY2skMSh3aW5kb3cpO1xuICAgICAgc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdyk7XG4gICAgICBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpO1xuICAgICAgc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgaWYgKCFmaXJlZm94U2hpbSB8fCAhc2hpbVBlZXJDb25uZWN0aW9uIHx8ICFvcHRpb25zLnNoaW1GaXJlZm94KSB7XG4gICAgICAgIGxvZ2dpbmcoJ0ZpcmVmb3ggc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBmaXJlZm94LicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBmaXJlZm94U2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU9uVHJhY2sod2luZG93KTtcbiAgICAgIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KTtcbiAgICAgIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpO1xuICAgICAgc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdyk7XG4gICAgICBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdyk7XG4gICAgICBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzYWZhcmknOlxuICAgICAgaWYgKCFzYWZhcmlTaGltIHx8ICFvcHRpb25zLnNoaW1TYWZhcmkpIHtcbiAgICAgICAgbG9nZ2luZygnU2FmYXJpIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBzYWZhcmlTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbUNhbGxiYWNrQVBJLlxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdyk7XG4gICAgICBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdyk7XG4gICAgICBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpO1xuICAgICAgc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5hZGFwdGVyRmFjdG9yeSh7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3dcbn0pO1xuXG5jb25zdCBFTkNSWVBUSU9OX0FMR09SSVRITSA9ICdBRVMtR0NNJztcbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcbmNvbnN0IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UgPSAxMDtcbi8vIGZsYWcgc2V0IHRvIGluZGljYXRlIHRoYXQgZTJlZSBoYXMgYmVlbiBzZXR1cCBmb3Igc2VuZGVyL3JlY2VpdmVyO1xuY29uc3QgRTJFRV9GTEFHID0gJ2xrX2UyZWUnO1xuY29uc3QgU0FMVCA9ICdMS0ZyYW1lRW5jcnlwdGlvbktleSc7XG5jb25zdCBLRVlfUFJPVklERVJfREVGQVVMVFMgPSB7XG4gIHNoYXJlZEtleTogZmFsc2UsXG4gIHJhdGNoZXRTYWx0OiBTQUxULFxuICByYXRjaGV0V2luZG93U2l6ZTogOCxcbiAgZmFpbHVyZVRvbGVyYW5jZTogREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSxcbiAga2V5cmluZ1NpemU6IDE2LFxuICBhbGxvd0tleUV4dHJhY3Rpb246IGZhbHNlXG59O1xuXG52YXIgS2V5UHJvdmlkZXJFdmVudDtcbihmdW5jdGlvbiAoS2V5UHJvdmlkZXJFdmVudCkge1xuICBLZXlQcm92aWRlckV2ZW50W1wiU2V0S2V5XCJdID0gXCJzZXRLZXlcIjtcbiAgS2V5UHJvdmlkZXJFdmVudFtcIlJhdGNoZXRSZXF1ZXN0XCJdID0gXCJyYXRjaGV0UmVxdWVzdFwiO1xuICBLZXlQcm92aWRlckV2ZW50W1wiS2V5UmF0Y2hldGVkXCJdID0gXCJrZXlSYXRjaGV0ZWRcIjtcbn0pKEtleVByb3ZpZGVyRXZlbnQgfHwgKEtleVByb3ZpZGVyRXZlbnQgPSB7fSkpO1xudmFyIEtleUhhbmRsZXJFdmVudDtcbihmdW5jdGlvbiAoS2V5SGFuZGxlckV2ZW50KSB7XG4gIEtleUhhbmRsZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XG59KShLZXlIYW5kbGVyRXZlbnQgfHwgKEtleUhhbmRsZXJFdmVudCA9IHt9KSk7XG52YXIgRW5jcnlwdGlvbkV2ZW50O1xuKGZ1bmN0aW9uIChFbmNyeXB0aW9uRXZlbnQpIHtcbiAgRW5jcnlwdGlvbkV2ZW50W1wiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICBFbmNyeXB0aW9uRXZlbnRbXCJFbmNyeXB0aW9uRXJyb3JcIl0gPSBcImVuY3J5cHRpb25FcnJvclwiO1xufSkoRW5jcnlwdGlvbkV2ZW50IHx8IChFbmNyeXB0aW9uRXZlbnQgPSB7fSkpO1xudmFyIENyeXB0b3JFdmVudDtcbihmdW5jdGlvbiAoQ3J5cHRvckV2ZW50KSB7XG4gIENyeXB0b3JFdmVudFtcIkVycm9yXCJdID0gXCJjcnlwdG9yRXJyb3JcIjtcbn0pKENyeXB0b3JFdmVudCB8fCAoQ3J5cHRvckV2ZW50ID0ge30pKTtcblxuZnVuY3Rpb24gaXNFMkVFU3VwcG9ydGVkKCkge1xuICByZXR1cm4gaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkKCkgfHwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKTtcbn1cbmZ1bmN0aW9uIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB0eXBlb2Ygd2luZG93LlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgLy8gQHRzLWlnbm9yZVxuICB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuY3JlYXRlRW5jb2RlZFN0cmVhbXMgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNWaWRlb0ZyYW1lKGZyYW1lKSB7XG4gIHJldHVybiAndHlwZScgaW4gZnJhbWU7XG59XG5mdW5jdGlvbiBpbXBvcnRLZXkoa2V5Qnl0ZXNfMSkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2V5Qnl0ZXMpIHtcbiAgICBsZXQgYWxnb3JpdGhtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITVxuICAgIH07XG4gICAgbGV0IHVzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnZW5jcnlwdCc7XG4gICAgbGV0IGV4dHJhY3RhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vaW1wb3J0S2V5XG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleUJ5dGVzLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICB9KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKHBhc3N3b3JkKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGtleU1hdGVyaWFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGVuYy5lbmNvZGUocGFzc3dvcmQpLCB7XG4gICAgICBuYW1lOiAnUEJLREYyJ1xuICAgIH0sIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xuICAgIHJldHVybiBrZXlNYXRlcmlhbDtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoY3J5cHRvQnVmZmVyKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgY3J5cHRvQnVmZmVyLCAnSEtERicsIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xuICAgIHJldHVybiBrZXlNYXRlcmlhbDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBbGdvT3B0aW9ucyhhbGdvcml0aG1OYW1lLCBzYWx0KSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGVuY29kZWRTYWx0ID0gdGV4dEVuY29kZXIuZW5jb2RlKHNhbHQpO1xuICBzd2l0Y2ggKGFsZ29yaXRobU5hbWUpIHtcbiAgICBjYXNlICdIS0RGJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdIS0RGJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaW5mbzogbmV3IEFycmF5QnVmZmVyKDEyOClcbiAgICAgIH07XG4gICAgY2FzZSAnUEJLREYyJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFsZ29yaXRobSBcIi5jb25jYXQoYWxnb3JpdGhtTmFtZSwgXCIgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkXCIpKTtcbiAgfVxufVxuLyoqXG4gKiBEZXJpdmVzIGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgbWFzdGVyIGtleS5cbiAqIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjFcbiAqL1xuZnVuY3Rpb24gZGVyaXZlS2V5cyhtYXRlcmlhbCwgc2FsdCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVLZXkjSEtERlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ia2RmUGFyYW1zXG4gICAgY29uc3QgZW5jcnlwdGlvbktleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVyaXZlS2V5KGFsZ29yaXRobU9wdGlvbnMsIG1hdGVyaWFsLCB7XG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSxcbiAgICAgIGxlbmd0aDogMTI4XG4gICAgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRlcmlhbCxcbiAgICAgIGVuY3J5cHRpb25LZXlcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUUyRUVLZXkoKSB7XG4gIHJldHVybiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpO1xufVxuLyoqXG4gKiBSYXRjaGV0cyBhIGtleS4gU2VlXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjUuMVxuICovXG5mdW5jdGlvbiByYXRjaGV0KG1hdGVyaWFsLCBzYWx0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUJpdHNcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKGFsZ29yaXRobU9wdGlvbnMsIG1hdGVyaWFsLCAyNTYpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5lZWRzUmJzcFVuZXNjYXBpbmcoZnJhbWVEYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVEYXRhLmxlbmd0aCAtIDM7IGkrKykge1xuICAgIGlmIChmcmFtZURhdGFbaV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDFdID09IDAgJiYgZnJhbWVEYXRhW2kgKyAyXSA9PSAzKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXJzZVJic3Aoc3RyZWFtKSB7XG4gIGNvbnN0IGRhdGFPdXQgPSBbXTtcbiAgdmFyIGxlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLmxlbmd0aDspIHtcbiAgICAvLyBCZSBjYXJlZnVsIGFib3V0IG92ZXIvdW5kZXJmbG93IGhlcmUuIGJ5dGVfbGVuZ3RoXyAtIDMgY2FuIHVuZGVyZmxvdywgYW5kXG4gICAgLy8gaSArIDMgY2FuIG92ZXJmbG93LCBidXQgYnl0ZV9sZW5ndGhfIC0gaSBjYW4ndCwgYmVjYXVzZSBpIDwgYnl0ZV9sZW5ndGhfXG4gICAgLy8gYWJvdmUsIGFuZCB0aGF0IGV4cHJlc3Npb24gd2lsbCBwcm9kdWNlIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCBpblxuICAgIC8vIHRoZSBzdHJlYW0gaW5jbHVkaW5nIHRoZSBieXRlIGF0IGkuXG4gICAgaWYgKGxlbmd0aCAtIGkgPj0gMyAmJiAhc3RyZWFtW2ldICYmICFzdHJlYW1baSArIDFdICYmIHN0cmVhbVtpICsgMl0gPT0gMykge1xuICAgICAgLy8gVHdvIHJic3AgYnl0ZXMuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIC8vIFNraXAgdGhlIGVtdWxhdGlvbiBieXRlLlxuICAgICAgaSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgcmJzcCBieXRlLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuY29uc3Qga1plcm9zSW5TdGFydFNlcXVlbmNlID0gMjtcbmNvbnN0IGtFbXVsYXRpb25CeXRlID0gMztcbmZ1bmN0aW9uIHdyaXRlUmJzcChkYXRhX2luKSB7XG4gIGNvbnN0IGRhdGFPdXQgPSBbXTtcbiAgdmFyIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfaW4ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnl0ZSA9IGRhdGFfaW5baV07XG4gICAgaWYgKGJ5dGUgPD0ga0VtdWxhdGlvbkJ5dGUgJiYgbnVtQ29uc2VjdXRpdmVaZXJvcyA+PSBrWmVyb3NJblN0YXJ0U2VxdWVuY2UpIHtcbiAgICAgIC8vIE5lZWQgdG8gZXNjYXBlLlxuICAgICAgZGF0YU91dC5wdXNoKGtFbXVsYXRpb25CeXRlKTtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgICBkYXRhT3V0LnB1c2goYnl0ZSk7XG4gICAgaWYgKGJ5dGUgPT0gMCkge1xuICAgICAgKytudW1Db25zZWN1dGl2ZVplcm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuY2xhc3MgQmFzZUtleVByb3ZpZGVyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayBiZWluZyBpbnZva2VkIGFmdGVyIGEgcmF0Y2hldCByZXF1ZXN0IGhhcyBiZWVuIHBlcmZvcm1lZCBvbiBhIHBhcnRpY2lwYW50XG4gICAgICogdGhhdCBzdXJmYWNlcyB0aGUgbmV3IGtleSBtYXRlcmlhbC5cbiAgICAgKiBAcGFyYW0gbWF0ZXJpYWxcbiAgICAgKiBAcGFyYW0ga2V5SW5kZXhcbiAgICAgKi9cbiAgICB0aGlzLm9uS2V5UmF0Y2hldGVkID0gKG1hdGVyaWFsLCBrZXlJbmRleCkgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygna2V5IHJhdGNoZXRlZCBldmVudCByZWNlaXZlZCcsIHtcbiAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgIGtleUluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMua2V5SW5mb01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEtFWV9QUk9WSURFUl9ERUZBVUxUUyksIG9wdGlvbnMpO1xuICAgIHRoaXMub24oS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIHRoaXMub25LZXlSYXRjaGV0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBjYWxsYmFjayB0byBpbnZva2Ugb25jZSBhIGtleSBoYXMgYmVlbiBzZXQgZm9yIGEgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gcGFydGljaXBhbnRJZGVudGl0eVxuICAgKiBAcGFyYW0ga2V5SW5kZXhcbiAgICovXG4gIG9uU2V0RW5jcnlwdGlvbktleShrZXksIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgY29uc3Qga2V5SW5mbyA9IHtcbiAgICAgIGtleSxcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICBrZXlJbmRleFxuICAgIH07XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hhcmVkS2V5ICYmICFwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpY2lwYW50IGlkZW50aXR5IG5lZWRzIHRvIGJlIHBhc3NlZCBmb3IgZW5jcnlwdGlvbiBrZXkgaWYgc2hhcmVkS2V5IG9wdGlvbiBpcyBmYWxzZScpO1xuICAgIH1cbiAgICB0aGlzLmtleUluZm9NYXAuc2V0KFwiXCIuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkgIT09IG51bGwgJiYgcGFydGljaXBhbnRJZGVudGl0eSAhPT0gdm9pZCAwID8gcGFydGljaXBhbnRJZGVudGl0eSA6ICdzaGFyZWQnLCBcIi1cIikuY29uY2F0KGtleUluZGV4ICE9PSBudWxsICYmIGtleUluZGV4ICE9PSB2b2lkIDAgPyBrZXlJbmRleCA6IDApLCBrZXlJbmZvKTtcbiAgICB0aGlzLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8pO1xuICB9XG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlJbmZvTWFwLnZhbHVlcygpKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cbiAgcmF0Y2hldEtleShwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCk7XG4gIH1cbn1cbi8qKlxuICogQSBiYXNpYyBLZXlQcm92aWRlciBpbXBsZW1lbnRhdGlvbiBpbnRlbmRlZCBmb3IgYSBzaW5nbGUgc2hhcmVkXG4gKiBwYXNzcGhyYXNlIGJldHdlZW4gYWxsIHBhcnRpY2lwYW50c1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciBleHRlbmRzIEJhc2VLZXlQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgc2hhcmVkS2V5OiB0cnVlLFxuICAgICAgLy8gZm9yIGEgc2hhcmVkIGtleSBwcm92aWRlciBmYWlsaW5nIHRvIGRlY3J5cHQgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnRcbiAgICAgIC8vIHNob3VsZCBub3QgbWFyayB0aGUga2V5IGFzIGludmFsaWQsIHNvIHdlIGFjY2VwdCB3cm9uZyBrZXlzIGZvcmV2ZXJcbiAgICAgIC8vIGFuZCB3b24ndCB0cnkgdG8gYXV0by1yYXRjaGV0XG4gICAgICByYXRjaGV0V2luZG93U2l6ZTogMCxcbiAgICAgIGZhaWx1cmVUb2xlcmFuY2U6IC0xXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhbiBBcnJheSBidWZmZXIgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG51bWJlcnMsIEhLREYgaXMgYmVpbmcgdXNlZC4gKHJlY29tbWVuZGVkKVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBzZXRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHlpZWxkIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhrZXkpIDogeWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGtleSk7XG4gICAgICB0aGlzLm9uU2V0RW5jcnlwdGlvbktleShkZXJpdmVkS2V5KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBMaXZla2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8ICdhbiBlcnJvciBoYXMgb2NjdXJlZCcpO1xuICAgIHRoaXMubmFtZSA9ICdMaXZlS2l0RXJyb3InO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbnZhciBDb25uZWN0aW9uRXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25FcnJvclJlYXNvbikge1xuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiTm90QWxsb3dlZFwiXSA9IDBdID0gXCJOb3RBbGxvd2VkXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJTZXJ2ZXJVbnJlYWNoYWJsZVwiXSA9IDFdID0gXCJTZXJ2ZXJVbnJlYWNoYWJsZVwiO1xuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiSW50ZXJuYWxFcnJvclwiXSA9IDJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJDYW5jZWxsZWRcIl0gPSAzXSA9IFwiQ2FuY2VsbGVkXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJMZWF2ZVJlcXVlc3RcIl0gPSA0XSA9IFwiTGVhdmVSZXF1ZXN0XCI7XG59KShDb25uZWN0aW9uRXJyb3JSZWFzb24gfHwgKENvbm5lY3Rpb25FcnJvclJlYXNvbiA9IHt9KSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24sIHN0YXR1cywgY29udGV4dCkge1xuICAgIHN1cGVyKDEsIG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0aW9uRXJyb3InO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5yZWFzb25OYW1lID0gQ29ubmVjdGlvbkVycm9yUmVhc29uW3JlYXNvbl07XG4gIH1cbn1cbmNsYXNzIERldmljZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjEsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcbiAgICB0aGlzLm5hbWUgPSAnRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcic7XG4gIH1cbn1cbmNsYXNzIFRyYWNrSW52YWxpZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDIwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndHJhY2sgaXMgaW52YWxpZCcpO1xuICAgIHRoaXMubmFtZSA9ICdUcmFja0ludmFsaWRFcnJvcic7XG4gIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5zdXBwb3J0ZWQgc2VydmVyJyk7XG4gICAgdGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkU2VydmVyJztcbiAgfVxufVxuY2xhc3MgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMiwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuZXhwZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZScpO1xuICAgIHRoaXMubmFtZSA9ICdVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlJztcbiAgfVxufVxuY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcbiAgICB0aGlzLm5hbWUgPSAnTmVnb3RpYXRpb25FcnJvcic7XG4gIH1cbn1cbmNsYXNzIFB1Ymxpc2hEYXRhRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTQsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmFibGUgdG8gcHVibGlzaCBkYXRhJyk7XG4gICAgdGhpcy5uYW1lID0gJ1B1Ymxpc2hEYXRhRXJyb3InO1xuICB9XG59XG5jbGFzcyBQdWJsaXNoVHJhY2tFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgIHN1cGVyKDE1LCBtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnUHVibGlzaFRyYWNrRXJyb3InO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICB9XG59XG5jbGFzcyBTaWduYWxSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24pIHtcbiAgICBzdXBlcigxNSwgbWVzc2FnZSk7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5yZWFzb25OYW1lID0gdHlwZW9mIHJlYXNvbiA9PT0gJ3N0cmluZycgPyByZWFzb24gOiBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uW3JlYXNvbl07XG4gIH1cbn1cbnZhciBNZWRpYURldmljZUZhaWx1cmU7XG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xuICAvLyB1c2VyIHJlamVjdGVkIHBlcm1pc3Npb25zXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIlBlcm1pc3Npb25EZW5pZWRcIl0gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiTm90Rm91bmRcIl0gPSBcIk5vdEZvdW5kXCI7XG4gIC8vIGRldmljZSBpcyBpbiB1c2UuIE9uIFdpbmRvd3MsIG9ubHkgYSBzaW5nbGUgdGFiIG1heSBnZXQgYWNjZXNzIHRvIGEgZGV2aWNlIGF0IGEgdGltZS5cbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiRGV2aWNlSW5Vc2VcIl0gPSBcIkRldmljZUluVXNlXCI7XG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIk90aGVyXCJdID0gXCJPdGhlclwiO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xuKGZ1bmN0aW9uIChNZWRpYURldmljZUZhaWx1cmUpIHtcbiAgZnVuY3Rpb24gZ2V0RmFpbHVyZShlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5EZXZpY2VJblVzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XG4gICAgfVxuICB9XG4gIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlID0gZ2V0RmFpbHVyZTtcbn0pKE1lZGlhRGV2aWNlRmFpbHVyZSB8fCAoTWVkaWFEZXZpY2VGYWlsdXJlID0ge30pKTtcblxudmFyIENyeXB0b3JFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoQ3J5cHRvckVycm9yUmVhc29uKSB7XG4gIENyeXB0b3JFcnJvclJlYXNvbltDcnlwdG9yRXJyb3JSZWFzb25bXCJJbnZhbGlkS2V5XCJdID0gMF0gPSBcIkludmFsaWRLZXlcIjtcbiAgQ3J5cHRvckVycm9yUmVhc29uW0NyeXB0b3JFcnJvclJlYXNvbltcIk1pc3NpbmdLZXlcIl0gPSAxXSA9IFwiTWlzc2luZ0tleVwiO1xuICBDcnlwdG9yRXJyb3JSZWFzb25bQ3J5cHRvckVycm9yUmVhc29uW1wiSW50ZXJuYWxFcnJvclwiXSA9IDJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG59KShDcnlwdG9yRXJyb3JSZWFzb24gfHwgKENyeXB0b3JFcnJvclJlYXNvbiA9IHt9KSk7XG5jbGFzcyBDcnlwdG9yRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ3J5cHRvckVycm9yUmVhc29uLkludGVybmFsRXJyb3I7XG4gICAgbGV0IHBhcnRpY2lwYW50SWRlbnRpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcig0MCwgbWVzc2FnZSk7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xudmFyIFJvb21FdmVudDtcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xuICAgKiB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogV2hlbiB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZC4gVGhpcyBpc24ndCBub3RpY2VhYmxlIHRvIHVzZXJzIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqIEl0IHdpbGwgcmVzb2x2ZSB3aXRoIGEgYFJvb21FdmVudC5SZWNvbm5lY3RlZGAgb25jZSB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmUtZXN0YWJsaXNoZWQuXG4gICAqIElmIG1lZGlhIGZhaWxzIGFkZGl0aW9uYWxseSBpdCBhbiBhZGRpdGlvbmFsIGBSb29tRXZlbnQuUmVjb25uZWN0aW5nYCB3aWxsIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaWduYWxSZWNvbm5lY3RpbmdcIl0gPSBcInNpZ25hbFJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIHJlY29ubmVjdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWQuXG4gICAqXG4gICAqIERpc2Nvbm5lY3RSZWFzb24gY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoeSB0aGUgcGFydGljaXBhbnQgd2FzIGRpc2Nvbm5lY3RlZC4gTm90YWJsZSByZWFzb25zIGFyZVxuICAgKiAtIERVUExJQ0FURV9JREVOVElUWTogYW5vdGhlciBjbGllbnQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eSBoYXMgam9pbmVkIHRoZSByb29tXG4gICAqIC0gUEFSVElDSVBBTlRfUkVNT1ZFRDogcGFydGljaXBhbnQgd2FzIHJlbW92ZWQgYnkgUmVtb3ZlUGFydGljaXBhbnQgQVBJXG4gICAqIC0gUk9PTV9ERUxFVEVEOiB0aGUgcm9vbSBoYXMgZW5kZWQgdmlhIERlbGV0ZVJvb20gQVBJXG4gICAqXG4gICAqIGFyZ3M6IChbW0Rpc2Nvbm5lY3RSZWFzb25dXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXG4gICAqXG4gICAqIGFyZ3M6IChbW0Nvbm5lY3Rpb25TdGF0ZV1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiBpbnB1dCBvciBvdXRwdXQgZGV2aWNlcyBvbiB0aGUgbWFjaGluZSBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICBSb29tRXZlbnRbXCJNZWRpYURldmljZXNDaGFuZ2VkXCJdID0gXCJtZWRpYURldmljZXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGpvaW5zICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50LiBJdCB3aWxsIG5vdCBlbWl0IGV2ZW50cyBmb3IgcGFydGljaXBhbnRzIHRoYXQgYXJlIGFscmVhZHlcbiAgICogaW4gdGhlIHJvb21cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50Q29ubmVjdGVkXCJdID0gXCJwYXJ0aWNpcGFudENvbm5lY3RlZFwiO1xuICAvKipcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBsZWF2ZXMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCJdID0gXCJwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZFwiO1xuICAvKipcbiAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLiBJdCB3aWxsIG5vdCBmaXJlIGZvciB0cmFja3MgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQuXG4gICAqXG4gICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcbiAgICogc2ltcGx5IHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogVGhlIFtbTG9jYWxQYXJ0aWNpcGFudF1dIGhhcyBzdWJzY3JpYmVkIHRvIGEgbmV3IHRyYWNrLiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKlxuICAgKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaWJlZFwiXSA9IFwidHJhY2tTdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKHRyYWNrIHNpZCwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCI7XG4gIC8qKlxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrVW5zdWJzY3JpYmVkXCJdID0gXCJ0cmFja1Vuc3Vic2NyaWJlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrTXV0ZWRcIl0gPSBcInRyYWNrTXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgbG9jYWwgYXVkaW8gdHJhY2sgaXMgcHVibGlzaGVkIHRoZSBTREsgY2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgY29tcGxldGUgc2lsZW5jZVxuICAgKiBvbiB0aGF0IHRyYWNrIGFuZCBlbWl0cyB0aGUgTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCBldmVudCBpbiB0aGF0IGNhc2UuXG4gICAqIFRoaXMgYWxsb3dzIGZvciBhcHBsaWNhdGlvbnMgdG8gc2hvdyBVSSBpbmZvcm1pbmcgdXNlcnMgdGhhdCB0aGV5IG1pZ2h0IGhhdmUgdG9cbiAgICogcmVzZXQgdGhlaXIgYXVkaW8gaGFyZHdhcmUgb3IgY2hlY2sgZm9yIHByb3BlciBkZXZpY2UgY29ubmVjdGl2aXR5LlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZFwiXSA9IFwibG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xuICAvKipcbiAgICogQWN0aXZlIHNwZWFrZXJzIGNoYW5nZWQuIExpc3Qgb2Ygc3BlYWtlcnMgYXJlIG9yZGVyZWQgYnkgdGhlaXIgYXVkaW8gbGV2ZWwuXG4gICAqIGxvdWRlc3Qgc3BlYWtlcnMgZmlyc3QuIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBMb2NhbFBhcnRpY2lwYW50IHRvby5cbiAgICpcbiAgICogU3BlYWtlciB1cGRhdGVzIGFyZSBzZW50IG9ubHkgdG8gdGhlIHB1Ymxpc2hpbmcgcGFydGljaXBhbnQgYW5kIHRoZWlyIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBhcmdzOiAoQXJyYXk8W1tQYXJ0aWNpcGFudF1dPilcbiAgICovXG4gIFJvb21FdmVudFtcIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwiYWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCdzIGRpc3BsYXkgbmFtZSBjaGFuZ2VkXG4gICAqXG4gICAqIGFyZ3M6IChuYW1lOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50TmFtZUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TmFtZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IGF0dHJpYnV0ZXMgaXMgYW4gYXBwLXNwZWNpZmljIGtleSB2YWx1ZSBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlcyBhbmQgdGhlIHBhcnRpY2lwYW50XG4gICAqIGFyZ3M6IChjaGFuZ2VkQXR0cmlidXRlczogW1tSZWNvcmQ8c3RyaW5nLCBzdHJpbmddXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFJvb20gbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVSb29tTWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHJvb20ncyBzdGF0ZSxcbiAgICogKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHN0cmluZylcbiAgICovXG4gIFJvb21FdmVudFtcIlJvb21NZXRhZGF0YUNoYW5nZWRcIl0gPSBcInJvb21NZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIERhdGEgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIHBhcnRpY2lwYW50LlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dLCB0b3BpYz86IHN0cmluZylcbiAgICovXG4gIFJvb21FdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBkdG1mOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiU2lwRFRNRlJlY2VpdmVkXCJdID0gXCJzaXBEVE1GUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIFRyYW5zY3JpcHRpb24gcmVjZWl2ZWQgZnJvbSBhIHBhcnRpY2lwYW50J3MgdHJhY2suXG4gICAqIEBiZXRhXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFuc2NyaXB0aW9uUmVjZWl2ZWRcIl0gPSBcInRyYW5zY3JpcHRpb25SZWNlaXZlZFwiO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIl0gPSBcImNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiO1xuICAvKipcbiAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCAocmVtb3RlKSB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXG4gICAqXG4gICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJ0cmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LiBJZiBwZXJtaXNzaW9uIHdhcyByZXZva2VkLCB0aGVuIHRoZSB0cmFjayB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAqIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHN0YXR1cyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCBhdWRpbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYXVkaW8gZWxlbWVudHMuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBgUm9vbS5jYW5QbGF5YmFja0F1ZGlvYCB3aWxsIGluZGljYXRlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIHBlcm1pdHRlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJhdWRpb1BsYXliYWNrQ2hhbmdlZFwiO1xuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIHZpZGVvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhIHZpZGVvIGVsZW1lbnQuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIFZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBDYWxsaW5nIGByb29tLnN0YXJ0VmlkZW8oKWAgaW4gYSB1c2VyIGdlc3R1cmUgZXZlbnQgaGFuZGxlciB3aWxsIHJlc3VtZSB0aGUgdmlkZW8gcGxheWJhY2suXG4gICAqL1xuICBSb29tRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZFwiXSA9IFwidmlkZW9QbGF5YmFja0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHRyYWNrLlxuICAgKiBUaGUgZXJyb3JzIHRha2UgcGxhY2UgaW4gZ2V0VXNlck1lZGlhKCkuXG4gICAqIFVzZSBNZWRpYURldmljZUZhaWx1cmUuZ2V0RmFpbHVyZShlcnJvcikgdG8gZ2V0IHRoZSByZWFzb24gb2YgZmFpbHVyZS5cbiAgICogW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RDYW1lcmFFcnJvcl1dIGFuZCBbW0xvY2FsUGFydGljaXBhbnQubGFzdE1pY3JvcGhvbmVFcnJvcl1dXG4gICAqIHdpbGwgaW5kaWNhdGUgaWYgaXQgaGFkIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhdWRpbyBvciB2aWRlbyB0cmFjayByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIGFyZ3M6IChlcnJvcjogRXJyb3IpXG4gICAqL1xuICBSb29tRXZlbnRbXCJNZWRpYURldmljZXNFcnJvclwiXSA9IFwibWVkaWFEZXZpY2VzRXJyb3JcIjtcbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTaWduYWwgY29ubmVjdGVkLCBjYW4gcHVibGlzaCB0cmFja3MuXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaWduYWxDb25uZWN0ZWRcIl0gPSBcInNpZ25hbENvbm5lY3RlZFwiO1xuICAvKipcbiAgICogUmVjb3JkaW5nIG9mIGEgcm9vbSBoYXMgc3RhcnRlZC9zdG9wcGVkLiBSb29tLmlzUmVjb3JkaW5nIHdpbGwgYmUgdXBkYXRlZCB0b28uXG4gICAqIGFyZ3M6IChpc1JlY29yZGluZzogYm9vbGVhbilcbiAgICovXG4gIFJvb21FdmVudFtcIlJlY29yZGluZ1N0YXR1c0NoYW5nZWRcIl0gPSBcInJlY29yZGluZ1N0YXR1c0NoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICBSb29tRXZlbnRbXCJFbmNyeXB0aW9uRXJyb3JcIl0gPSBcImVuY3J5cHRpb25FcnJvclwiO1xuICAvKipcbiAgICogRW1pdHMgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgYnVmZmVyIHN0YXR1cyBvZiBhIGRhdGEgY2hhbm5lbCBjaGFuZ2VzXG4gICAqIGFyZ3M6IChpc0xvdzogYm9vbGVhbiwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYnkgYSBjYWxsIHRvIHJvb20uc3dpdGNoQWN0aXZlRGV2aWNlXG4gICAqIGFyZ3M6IChraW5kOiBNZWRpYURldmljZUtpbmQsIGRldmljZUlkOiBzdHJpbmcpXG4gICAqL1xuICBSb29tRXZlbnRbXCJBY3RpdmVEZXZpY2VDaGFuZ2VkXCJdID0gXCJhY3RpdmVEZXZpY2VDaGFuZ2VkXCI7XG4gIFJvb21FdmVudFtcIkNoYXRNZXNzYWdlXCJdID0gXCJjaGF0TWVzc2FnZVwiO1xuICAvKipcbiAgICogZmlyZWQgd2hlbiB0aGUgZmlyc3QgcmVtb3RlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIHRoZSBsb2NhbFBhcnRpY2lwYW50J3MgdHJhY2tcbiAgICovXG4gIFJvb21FdmVudFtcIkxvY2FsVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJsb2NhbFRyYWNrU3Vic2NyaWJlZFwiO1xuICAvKipcbiAgICogZmlyZWQgd2hlbiB0aGUgY2xpZW50IHJlY2VpdmVzIGNvbm5lY3Rpb24gbWV0cmljcyBmcm9tIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKi9cbiAgUm9vbUV2ZW50W1wiTWV0cmljc1JlY2VpdmVkXCJdID0gXCJtZXRyaWNzUmVjZWl2ZWRcIjtcbn0pKFJvb21FdmVudCB8fCAoUm9vbUV2ZW50ID0ge30pKTtcbnZhciBQYXJ0aWNpcGFudEV2ZW50O1xuKGZ1bmN0aW9uIChQYXJ0aWNpcGFudEV2ZW50KSB7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1B1Ymxpc2hlZFwiXSA9IFwidHJhY2tQdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFN1Y2Nlc3NmdWxseSBzdWJzY3JpYmVkIHRvIHRoZSBbW1JlbW90ZVBhcnRpY2lwYW50XV0ncyB0cmFjay5cbiAgICogVGhpcyBldmVudCB3aWxsICoqYWx3YXlzKiogZmlyZSBhcyBsb25nIGFzIG5ldyB0cmFja3MgYXJlIHJlYWR5IGZvciB1c2UuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaWJlZFwiXSA9IFwidHJhY2tTdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKHRyYWNrIHNpZClcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1VucHVibGlzaGVkXCJdID0gXCJ0cmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIHN1YnNjcmliZWQgdHJhY2sgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gQ2xpZW50cyBzaG91bGQgbGlzdGVuIHRvIHRoaXNcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5zdWJzY3JpYmVkXCJdID0gXCJ0cmFja1Vuc3Vic2NyaWJlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1VubXV0ZWRcIl0gPSBcInRyYWNrVW5tdXRlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tQdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tQdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxuICAgKiB0aGUgbG9jYWwgdHJhY2sgZnJvbSB5b3VyIFVJLlxuICAgKlxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxuICAgKiB0aGlzIGV2ZW50IHdpbGwgYWxzbyBmaXJlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKiBUbyBhY2Nlc3MgdGhlIGN1cnJlbnQgbWV0YWRhdGEsIHNlZSBbW1BhcnRpY2lwYW50Lm1ldGFkYXRhXV0uXG4gICAqXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZylcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TmFtZUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TmFtZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIERhdGEgcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIHNlbmRlci5cbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXG4gICAqIEFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJEYXRhUmVjZWl2ZWRcIl0gPSBcImRhdGFSZWNlaXZlZFwiO1xuICAvKipcbiAgICogU0lQIERUTUYgdG9uZXMgcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIHNlbmRlci5cbiAgICpcbiAgICogYXJnczogKGR0bWY6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiU2lwRFRNRlJlY2VpdmVkXCJdID0gXCJzaXBEVE1GUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIFRyYW5zY3JpcHRpb24gcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIGRhdGEgc291cmNlLlxuICAgKiBAYmV0YVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBIYXMgc3BlYWtpbmcgc3RhdHVzIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50XG4gICAqXG4gICAqIGFyZ3M6IChzcGVha2luZzogYm9vbGVhbilcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJJc1NwZWFraW5nQ2hhbmdlZFwiXSA9IFwiaXNTcGVha2luZ0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIHJlbW90ZSBwYXJ0aWNpcGFudHMgcHVibGljYXRpb25zIGhhcyBjaGFuZ2VkIGl0cyBzdWJzY3JpcHRpb24gc3RhdHVzLlxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJNZWRpYURldmljZXNFcnJvclwiXSA9IFwibWVkaWFEZXZpY2VzRXJyb3JcIjtcbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkF1ZGlvU3RyZWFtQWNxdWlyZWRcIl0gPSBcImF1ZGlvU3RyZWFtQWNxdWlyZWRcIjtcbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQQ1RyYWNrQWRkZWRcIl0gPSBcInBjVHJhY2tBZGRlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgYXR0cmlidXRlcyBpcyBhbiBhcHAtc3BlY2lmaWMga2V5IHZhbHVlIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gYSBwYXJ0aWNpcGFudCdzIGF0dHJpYnV0ZXMgY2hhbmdlZCwgdGhpcyBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgY2hhbmdlZCBhdHRyaWJ1dGVzXG4gICAqIGFyZ3M6IChjaGFuZ2VkQXR0cmlidXRlczogW1tSZWNvcmQ8c3RyaW5nLCBzdHJpbmddXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJBdHRyaWJ1dGVzQ2hhbmdlZFwiXSA9IFwiYXR0cmlidXRlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIGZpcmVkIG9uIGxvY2FsIHBhcnRpY2lwYW50IG9ubHksIHdoZW4gdGhlIGZpcnN0IHJlbW90ZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byB0aGUgdHJhY2sgc3BlY2lmaWVkIGluIHRoZSBwYXlsb2FkXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIC8qKiBvbmx5IGVtaXR0ZWQgb24gbG9jYWwgcGFydGljaXBhbnQgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkNoYXRNZXNzYWdlXCJdID0gXCJjaGF0TWVzc2FnZVwiO1xufSkoUGFydGljaXBhbnRFdmVudCB8fCAoUGFydGljaXBhbnRFdmVudCA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG52YXIgRW5naW5lRXZlbnQ7XG4oZnVuY3Rpb24gKEVuZ2luZUV2ZW50KSB7XG4gIEVuZ2luZUV2ZW50W1wiVHJhbnNwb3J0c0NyZWF0ZWRcIl0gPSBcInRyYW5zcG9ydHNDcmVhdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtaW5nXCJdID0gXCJyZXN1bWluZ1wiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtZWRcIl0gPSBcInJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0aW5nXCJdID0gXCJyZXN0YXJ0aW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN1bWVkXCJdID0gXCJzaWduYWxSZXN1bWVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdGFydGVkXCJdID0gXCJzaWduYWxSZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiTWVkaWFUcmFja0FkZGVkXCJdID0gXCJtZWRpYVRyYWNrQWRkZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJBY3RpdmVTcGVha2Vyc1VwZGF0ZVwiXSA9IFwiYWN0aXZlU3BlYWtlcnNVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJUUFZpZGVvTWFwVXBkYXRlXCJdID0gXCJydHBWaWRlb01hcFVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUGFydGljaXBhbnRVcGRhdGVcIl0gPSBcInBhcnRpY2lwYW50VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUm9vbVVwZGF0ZVwiXSA9IFwicm9vbVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwic3BlYWtlcnNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJzdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25FcnJvclwiXSA9IFwic3Vic2NyaXB0aW9uRXJyb3JcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVtb3RlTXV0ZVwiXSA9IFwicmVtb3RlTXV0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCJdID0gXCJzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiT2ZmbGluZVwiXSA9IFwib2ZmbGluZVwiO1xuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlcXVlc3RSZXNwb25zZVwiXSA9IFwic2lnbmFsUmVxdWVzdFJlc3BvbnNlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsQ29ubmVjdGVkXCJdID0gXCJzaWduYWxDb25uZWN0ZWRcIjtcbn0pKEVuZ2luZUV2ZW50IHx8IChFbmdpbmVFdmVudCA9IHt9KSk7XG52YXIgVHJhY2tFdmVudDtcbihmdW5jdGlvbiAoVHJhY2tFdmVudCkge1xuICBUcmFja0V2ZW50W1wiTWVzc2FnZVwiXSA9IFwibWVzc2FnZVwiO1xuICBUcmFja0V2ZW50W1wiTXV0ZWRcIl0gPSBcIm11dGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJVbm11dGVkXCJdID0gXCJ1bm11dGVkXCI7XG4gIC8qKlxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgVHJhY2tFdmVudFtcIkVuZGVkXCJdID0gXCJlbmRlZFwiO1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaWJlZFwiXSA9IFwic3Vic2NyaWJlZFwiO1xuICBUcmFja0V2ZW50W1wiVW5zdWJzY3JpYmVkXCJdID0gXCJ1bnN1YnNjcmliZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVXBkYXRlU2V0dGluZ3NcIl0gPSBcInVwZGF0ZVNldHRpbmdzXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVN1YnNjcmlwdGlvblwiXSA9IFwidXBkYXRlU3Vic2NyaXB0aW9uXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvUGxheWJhY2tTdGFydGVkXCJdID0gXCJhdWRpb1BsYXliYWNrU3RhcnRlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrRmFpbGVkXCJdID0gXCJhdWRpb1BsYXliYWNrRmFpbGVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbEF1ZGlvVHJhY2sgaW5zdGFuY2VzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIl0gPSBcImF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlZpc2liaWxpdHlDaGFuZ2VkXCJdID0gXCJ2aXNpYmlsaXR5Q2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkXCJdID0gXCJ2aWRlb0RpbWVuc2lvbnNDaGFuZ2VkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlZpZGVvUGxheWJhY2tTdGFydGVkXCJdID0gXCJ2aWRlb1BsYXliYWNrU3RhcnRlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrRmFpbGVkXCJdID0gXCJ2aWRlb1BsYXliYWNrRmFpbGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkVsZW1lbnRBdHRhY2hlZFwiXSA9IFwiZWxlbWVudEF0dGFjaGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkVsZW1lbnREZXRhY2hlZFwiXSA9IFwiZWxlbWVudERldGFjaGVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIlVwc3RyZWFtUGF1c2VkXCJdID0gXCJ1cHN0cmVhbVBhdXNlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVJlc3VtZWRcIl0gPSBcInVwc3RyZWFtUmVzdW1lZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJzdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlRyYWNrUHJvY2Vzc29yVXBkYXRlXCJdID0gXCJ0cmFja1Byb2Nlc3NvclVwZGF0ZVwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGVcIl0gPSBcImF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlXCI7XG4gIC8qKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVGltZVN5bmNVcGRhdGVcIl0gPSBcInRpbWVTeW5jVXBkYXRlXCI7XG59KShUcmFja0V2ZW50IHx8IChUcmFja0V2ZW50ID0ge30pKTtcblxuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlZENsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfVxufVxuXG4vLyB0aW55LCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2xhbmNlZGlrc29uL2Jvd3Nlci9ibG9iL21hc3Rlci9zcmMvcGFyc2VyLWJyb3dzZXJzLmpzXG4vLyByZWR1Y2VkIHRvIG9ubHkgZGlmZmVyZW50aWF0ZSBDaHJvbWUoaXVtKSBiYXNlZCBicm93c2VycyAvIEZpcmVmb3ggLyBTYWZhcmlcbmNvbnN0IGNvbW1vblZlcnNpb25JZGVudGlmaWVyID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2k7XG5sZXQgYnJvd3NlckRldGFpbHM7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRCcm93c2VyKHVzZXJBZ2VudCkge1xuICBsZXQgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1YSA9ICh1c2VyQWdlbnQgIT09IG51bGwgJiYgdXNlckFnZW50ICE9PSB2b2lkIDAgPyB1c2VyQWdlbnQgOiBuYXZpZ2F0b3IudXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYnJvd3NlckRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBmb3JjZSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBicm93c2Vyc0xpc3QuZmluZChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHRlc3RcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHRlc3QudGVzdCh1YSk7XG4gICAgfSk7XG4gICAgYnJvd3NlckRldGFpbHMgPSBicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIuZGVzY3JpYmUodWEpO1xuICB9XG4gIHJldHVybiBicm93c2VyRGV0YWlscztcbn1cbmNvbnN0IGJyb3dzZXJzTGlzdCA9IFt7XG4gIHRlc3Q6IC9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pLFxuICBkZXNjcmliZSh1YSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSB7XG4gICAgICBuYW1lOiAnRmlyZWZveCcsXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZnhpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkLFxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufSwge1xuICB0ZXN0OiAvY2hyb218Y3Jpb3N8Y3Jtby9pLFxuICBkZXNjcmliZSh1YSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSB7XG4gICAgICBuYW1lOiAnQ2hyb21lJyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpjaHJvbWV8Y2hyb21pdW18Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjcmlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSlcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59LCAvKiBTYWZhcmkgKi9cbntcbiAgdGVzdDogL3NhZmFyaXxhcHBsZXdlYmtpdC9pLFxuICBkZXNjcmliZSh1YSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSB7XG4gICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKGNvbW1vblZlcnNpb25JZGVudGlmaWVyLCB1YSksXG4gICAgICBvczogdWEuaW5jbHVkZXMoJ21vYmlsZS8nKSA/ICdpT1MnIDogJ21hY09TJyxcbiAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKVxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn1dO1xuZnVuY3Rpb24gZ2V0TWF0Y2goZXhwLCB1YSkge1xuICBsZXQgaWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goZXhwKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBpZCAmJiBtYXRjaFtpZF0gfHwgJyc7XG59XG5mdW5jdGlvbiBnZXRPU1ZlcnNpb24odWEpIHtcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKCdtYWMgb3MnKSA/IGdldE1hdGNoKC9cXCguKz8oXFxkK19cXGQrKDo/X1xcZCspPykvLCB1YSwgMSkucmVwbGFjZSgvXy9nLCAnLicpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgdmVyc2lvbiQxID0gXCIyLjExLjNcIjtcblxuY29uc3QgdmVyc2lvbiA9IHZlcnNpb24kMTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbiA9IDE1O1xuXG4vKipcbiAqIFRpbWVycyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zXG4gKiB0aGF0IGVuc3VyZSB0aGF0IHRoZXkgYXJlIGZpcmVkLiBUaGVzZSBzaG91bGQgYmUgdXNlZCB3aGVuIGl0IGlzIGNyaXRpY2FsXG4gKiB0aGF0IHRoZSB0aW1lciBmaXJlcyBvbiB0aW1lLlxuICovXG5jbGFzcyBDcml0aWNhbFRpbWVycyB7fVxuQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2V0SW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2xlYXJJbnRlcnZhbCguLi5hcmd1bWVudHMpO1xufTtcblxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1Ncbi8vIFNhZmFyaSB0cmFja3Mgd2hpY2ggYXVkaW8gZWxlbWVudHMgaGF2ZSBiZWVuIFwiYmxlc3NlZFwiIGJ5IHRoZSB1c2VyLlxuY29uc3QgcmVjeWNsZWRFbGVtZW50cyA9IFtdO1xudmFyIFZpZGVvUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9RdWFsaXR5KSB7XG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJMT1dcIl0gPSAwXSA9IFwiTE9XXCI7XG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJNRURJVU1cIl0gPSAxXSA9IFwiTUVESVVNXCI7XG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJISUdIXCJdID0gMl0gPSBcIkhJR0hcIjtcbn0pKFZpZGVvUXVhbGl0eSB8fCAoVmlkZW9RdWFsaXR5ID0ge30pKTtcbmNsYXNzIFRyYWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBraW5kKSB7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXG4gICAgICogaGFzIGJlZW4gcGF1c2VkIGJ5IGNvbmdlc3Rpb24gY29udHJvbGxlclxuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtU3RhdGUgPSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmU7XG4gICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgLy8gZGVsYXkgYXBwIHZpc2liaWxpdHkgdXBkYXRlIGlmIGl0IGdvZXMgdG8gaGlkZGVuXG4gICAgICAvLyB1cGRhdGUgaW1tZWRpYXRlbHkgaWYgaXQgY29tZXMgYmFjayB0byBmb2N1c1xuICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpLCBCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuVHJhY2spO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBtZWRpYVRyYWNrO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtSUQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcykpO1xuICB9XG4gIC8qKiBjdXJyZW50IHJlY2VpdmUgYml0cyBwZXIgc2Vjb25kICovXG4gIGdldCBjdXJyZW50Qml0cmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdHJhdGU7XG4gIH1cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiB1c2VkIGZvciBrZWVwIG1lZGlhU3RyZWFtJ3MgZmlyc3QgaWQsIHNpbmNlIGl0J3MgaWQgbWlnaHQgY2hhbmdlXG4gICAqIGlmIHdlIGRpc2FibGUvZW5hYmxlIGEgdHJhY2tcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbUlEO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGVsZW1lbnRUeXBlID0gJ2F1ZGlvJztcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICBlbGVtZW50VHlwZSA9ICd2aWRlbyc7XG4gICAgfVxuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwICYmIHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdGhpcy5hZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgIGlmIChlLnBhcmVudEVsZW1lbnQgPT09IG51bGwgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gcG9vbFxuICAgICAgICAgIHJlY3ljbGVkRWxlbWVudHMuc3BsaWNlKHJlY3ljbGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxuICAgIC8vIHRoZSBlbGVtZW50J3Mgc3JjT2JqZWN0IHdhcyBzZXQgdG8gc29tZXRoaW5nIGVsc2Ugb3V0IG9mIGJhbmQuXG4gICAgLy8gd2UnbGwgd2FudCB0byByZS1hdHRhY2ggaXQgaW4gdGhhdCBjYXNlXG4gICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgLy8gaGFuZGxlIGF1dG8gcGxheWJhY2sgZmFpbHVyZXNcbiAgICBjb25zdCBhbGxNZWRpYVN0cmVhbVRyYWNrcyA9IGVsZW1lbnQuc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAnYXVkaW8nKTtcbiAgICAvLyBtYW51YWxseSBwbGF5IG1lZGlhIHRvIGRldGVjdCBhdXRvIHBsYXliYWNrIHN0YXR1c1xuICAgIGVsZW1lbnQucGxheSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgLy8gY29tbW9ubHkgdHJpZ2dlcmVkIGJ5IGFub3RoZXIgYHBsYXlgIHJlcXVlc3QsIG9ubHkgbG9nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIlwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nLCBcIiBwbGF5YmFjayBhYm9ydGVkLCBsaWtlbHkgZHVlIHRvIG5ldyBwbGF5IHJlcXVlc3RcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiY291bGQgbm90IHBsYXliYWNrIFwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nKSwgZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBhdWRpbyBwbGF5YmFjayBpc24ndCBhbGxvd2VkIG1ha2Ugc3VyZSB3ZSBzdGlsbCBwbGF5IGJhY2sgdGhlIHZpZGVvXG4gICAgICBpZiAoaGFzQXVkaW8gJiYgZWxlbWVudCAmJiBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICd2aWRlbycpICYmIGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvLyBjYXRjaCBmb3IgU2FmYXJpLCBleGNlZWRlZCBvcHRpb25zIGF0IHRoaXMgcG9pbnQgdG8gYXV0b21hdGljYWxseSBwbGF5IHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnRBdHRhY2hlZCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gZGV0YWNoIGZyb20gYSBzaW5nbGUgZWxlbWVudFxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXRhY2hlZCA9IFtdO1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxtID0+IHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbG0pO1xuICAgICAgICBkZXRhY2hlZC5wdXNoKGVsbSk7XG4gICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxtKTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbG0pO1xuICAgICAgfSk7XG4gICAgICAvLyByZW1vdmUgYWxsIHRyYWNrc1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgICByZXR1cm4gZGV0YWNoZWQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0b3BNb25pdG9yKCkge1xuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JJbnRlcnZhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRpbWVTeW5jSGFuZGxlKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnRpbWVTeW5jSGFuZGxlKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVMb2dnZXJPcHRpb25zKGxvZ2dlck9wdGlvbnMpIHtcbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSB7XG4gICAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2IpIHtcbiAgICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgfVxuICB9XG4gIHJlY3ljbGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQpIHtcbiAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byByZS11c2UgYSBzaW5nbGUgZWxlbWVudFxuICAgICAgbGV0IHNob3VsZENhY2hlID0gdHJ1ZTtcbiAgICAgIGVsZW1lbnQucGF1c2UoKTtcbiAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgaWYgKCFlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRDYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8qKiBjYXRjaCBjbGF1c2UgbmVjZXNzYXJ5IGZvciBTYWZhcmkgKi9cbiAgICAgICAgfSkpLCAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFRvRWxlbWVudCh0cmFjaywgZWxlbWVudCkge1xuICBsZXQgbWVkaWFTdHJlYW07XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgfSBlbHNlIHtcbiAgICBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICB9XG4gIC8vIGNoZWNrIGlmIHRyYWNrIG1hdGNoZXMgZXhpc3RpbmcgdHJhY2tcbiAgbGV0IGV4aXN0aW5nVHJhY2tzO1xuICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgfSBlbHNlIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gIH1cbiAgaWYgKCFleGlzdGluZ1RyYWNrcy5pbmNsdWRlcyh0cmFjaykpIHtcbiAgICBleGlzdGluZ1RyYWNrcy5mb3JFYWNoKGV0ID0+IHtcbiAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKGV0KTtcbiAgICB9KTtcbiAgICBtZWRpYVN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgaWYgKCFpc1NhZmFyaSgpIHx8ICEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgLy8gd2hlbiBpbiBsb3cgcG93ZXIgbW9kZSAoYXBwbGllcyB0byBib3RoIG1hY09TIGFuZCBpT1MpLCBTYWZhcmkgd2lsbCBzaG93IGEgcGxheS9wYXVzZSBvdmVybGF5XG4gICAgLy8gd2hlbiBhIHZpZGVvIHN0YXJ0cyB0aGF0IGhhcyB0aGUgYGF1dG9wbGF5YCBhdHRyaWJ1dGUgaXMgc2V0LlxuICAgIC8vIHdlIHdvcmsgYXJvdW5kIHRoaXMgYnkgX25vdF8gc2V0dGluZyB0aGUgYXV0b3BsYXkgYXR0cmlidXRlIG9uIHNhZmFyaSBhbmQgaW5zdGVhZCBjYWxsIGBzZXRUaW1lb3V0KCgpID0+IGVsLnBsYXkoKSwwKWAgZnVydGhlciBkb3duXG4gICAgZWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gIH1cbiAgLy8gSW4gY2FzZSB0aGVyZSBhcmUgbm8gYXVkaW8gdHJhY2tzIHByZXNlbnQgb24gdGhlIG1lZGlhc3RyZWFtLCB3ZSBzZXQgdGhlIGVsZW1lbnQgYXMgbXV0ZWQgdG8gZW5zdXJlIGF1dG9wbGF5IHdvcmtzXG4gIGVsZW1lbnQubXV0ZWQgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA9PT0gMDtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgZWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gIH1cbiAgLy8gYXZvaWQgZmxpY2tlclxuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgIT09IG1lZGlhU3RyZWFtKSB7XG4gICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICBpZiAoKGlzU2FmYXJpKCkgfHwgaXNGaXJlRm94KCkpICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAvLyBGaXJlZm94IGFsc28gaGFzIGEgdGltaW5nIGlzc3VlIHdoZXJlIHZpZGVvIGRvZXNuJ3QgYWN0dWFsbHkgZ2V0IGF0dGFjaGVkIHVubGVzc1xuICAgICAgLy8gcGVyZm9ybWVkIG91dC1vZi1iYW5kXG4gICAgICAvLyBTYWZhcmkgMTUgaGFzIGEgYnVnIHdoZXJlIGluIGNlcnRhaW4gbGF5b3V0cywgdmlkZW8gZWxlbWVudCByZW5kZXJzXG4gICAgICAvLyBibGFjayB1bnRpbCB0aGUgcGFnZSBpcyByZXNpemVkIG9yIG90aGVyIGNoYW5nZXMgdGFrZSBwbGFjZS5cbiAgICAgIC8vIFJlc2V0dGluZyB0aGUgc3JjIHRyaWdnZXJzIGl0IHRvIHJlbmRlci5cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb3J1bXMvdGhyZWFkLzY5MDUyM1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgIC8vIFNhZmFyaSAxNSBzb21ldGltZXMgZmFpbHMgdG8gc3RhcnQgYSB2aWRlb1xuICAgICAgICAvLyB3aGVuIHRoZSB3aW5kb3cgaXMgYmFja2dyb3VuZGVkIGJlZm9yZSB0aGUgZmlyc3QgZnJhbWUgaXMgZHJhd25cbiAgICAgICAgLy8gbWFudWFsbHkgY2FsbGluZyBwbGF5IGhlcmUgc2VlbXMgdG8gZml4IHRoYXRcbiAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8qKiBkbyBub3RoaW5nICovXG4gICAgICAgIH0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBkZXRhY2hUcmFjayh0cmFjaywgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIGlmIChtZWRpYVN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG4oZnVuY3Rpb24gKFRyYWNrKSB7XG4gIGxldCBLaW5kO1xuICAoZnVuY3Rpb24gKEtpbmQpIHtcbiAgICBLaW5kW1wiQXVkaW9cIl0gPSBcImF1ZGlvXCI7XG4gICAgS2luZFtcIlZpZGVvXCJdID0gXCJ2aWRlb1wiO1xuICAgIEtpbmRbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKEtpbmQgPSBUcmFjay5LaW5kIHx8IChUcmFjay5LaW5kID0ge30pKTtcbiAgbGV0IFNvdXJjZTtcbiAgKGZ1bmN0aW9uIChTb3VyY2UpIHtcbiAgICBTb3VyY2VbXCJDYW1lcmFcIl0gPSBcImNhbWVyYVwiO1xuICAgIFNvdXJjZVtcIk1pY3JvcGhvbmVcIl0gPSBcIm1pY3JvcGhvbmVcIjtcbiAgICBTb3VyY2VbXCJTY3JlZW5TaGFyZVwiXSA9IFwic2NyZWVuX3NoYXJlXCI7XG4gICAgU291cmNlW1wiU2NyZWVuU2hhcmVBdWRpb1wiXSA9IFwic2NyZWVuX3NoYXJlX2F1ZGlvXCI7XG4gICAgU291cmNlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShTb3VyY2UgPSBUcmFjay5Tb3VyY2UgfHwgKFRyYWNrLlNvdXJjZSA9IHt9KSk7XG4gIGxldCBTdHJlYW1TdGF0ZSQxO1xuICAoZnVuY3Rpb24gKFN0cmVhbVN0YXRlKSB7XG4gICAgU3RyZWFtU3RhdGVbXCJBY3RpdmVcIl0gPSBcImFjdGl2ZVwiO1xuICAgIFN0cmVhbVN0YXRlW1wiUGF1c2VkXCJdID0gXCJwYXVzZWRcIjtcbiAgICBTdHJlYW1TdGF0ZVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoU3RyZWFtU3RhdGUkMSA9IFRyYWNrLlN0cmVhbVN0YXRlIHx8IChUcmFjay5TdHJlYW1TdGF0ZSA9IHt9KSk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24ga2luZFRvUHJvdG8oaykge1xuICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSBLaW5kLkF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xuICAgICAgY2FzZSBLaW5kLlZpZGVvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUUgdGhpcyB3YXMgVU5SRUNPR05JWkVEIGJlZm9yZVxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkRBVEE7XG4gICAgfVxuICB9XG4gIFRyYWNrLmtpbmRUb1Byb3RvID0ga2luZFRvUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24ga2luZEZyb21Qcm90byh0KSB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcbiAgICAgICAgcmV0dXJuIEtpbmQuQXVkaW87XG4gICAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcbiAgICAgICAgcmV0dXJuIEtpbmQuVmlkZW87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gS2luZC5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5raW5kRnJvbVByb3RvID0ga2luZEZyb21Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBzb3VyY2VUb1Byb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgU291cmNlLkNhbWVyYTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLkNBTUVSQTtcbiAgICAgIGNhc2UgU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5NSUNST1BIT05FO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlVOS05PV047XG4gICAgfVxuICB9XG4gIFRyYWNrLnNvdXJjZVRvUHJvdG8gPSBzb3VyY2VUb1Byb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHNvdXJjZUZyb21Qcm90byhzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLkNBTUVSQTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5DYW1lcmE7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuTWljcm9waG9uZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTb3VyY2UuVW5rbm93bjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc291cmNlRnJvbVByb3RvID0gc291cmNlRnJvbVByb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHN0cmVhbVN0YXRlRnJvbVByb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuQUNUSVZFOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5BY3RpdmU7XG4gICAgICBjYXNlIFN0cmVhbVN0YXRlLlBBVVNFRDpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuUGF1c2VkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuVW5rbm93bjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc3RyZWFtU3RhdGVGcm9tUHJvdG8gPSBzdHJlYW1TdGF0ZUZyb21Qcm90bztcbn0pKFRyYWNrIHx8IChUcmFjayA9IHt9KSk7XG5cbmNsYXNzIFZpZGVvUHJlc2V0IHtcbiAgY29uc3RydWN0b3Iod2lkdGhPck9wdGlvbnMsIGhlaWdodCwgbWF4Qml0cmF0ZSwgbWF4RnJhbWVyYXRlLCBwcmlvcml0eSkge1xuICAgIGlmICh0eXBlb2Ygd2lkdGhPck9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGhPck9wdGlvbnMud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHdpZHRoT3JPcHRpb25zLmhlaWdodDtcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB3aWR0aE9yT3B0aW9ucy5hc3BlY3RSYXRpbztcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSB7XG4gICAgICAgIG1heEJpdHJhdGU6IHdpZHRoT3JPcHRpb25zLm1heEJpdHJhdGUsXG4gICAgICAgIG1heEZyYW1lcmF0ZTogd2lkdGhPck9wdGlvbnMubWF4RnJhbWVyYXRlLFxuICAgICAgICBwcmlvcml0eTogd2lkdGhPck9wdGlvbnMucHJpb3JpdHlcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChoZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBtYXhCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aE9yT3B0aW9ucztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHdpZHRoT3JPcHRpb25zIC8gaGVpZ2h0O1xuICAgICAgdGhpcy5lbmNvZGluZyA9IHtcbiAgICAgICAgbWF4Qml0cmF0ZSxcbiAgICAgICAgbWF4RnJhbWVyYXRlLFxuICAgICAgICBwcmlvcml0eVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgb3B0aW9uczogcHJvdmlkZSBhdCBsZWFzdCB3aWR0aCwgaGVpZ2h0IGFuZCBtYXhCaXRyYXRlJyk7XG4gICAgfVxuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBmcmFtZVJhdGU6IHRoaXMuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuYXNwZWN0UmF0aW9cbiAgICB9O1xuICB9XG59XG5jb25zdCBiYWNrdXBDb2RlY3MgPSBbJ3ZwOCcsICdoMjY0J107XG5jb25zdCB2aWRlb0NvZGVjcyA9IFsndnA4JywgJ2gyNjQnLCAndnA5JywgJ2F2MSddO1xuZnVuY3Rpb24gaXNCYWNrdXBDb2RlYyhjb2RlYykge1xuICByZXR1cm4gISFiYWNrdXBDb2RlY3MuZmluZChiYWNrdXAgPT4gYmFja3VwID09PSBjb2RlYyk7XG59XG52YXIgQmFja3VwQ29kZWNQb2xpY3k7XG4oZnVuY3Rpb24gKEJhY2t1cENvZGVjUG9saWN5KSB7XG4gIC8vIGNvZGVjIHJlZ3Jlc3Npb24gaXMgcHJlZmVycmVkLCB0aGUgc2Z1IHdpbGwgdHJ5IHRvIHJlZ3Jlc3MgY29kZWMgaWYgcG9zc2libGUgYnV0IG5vdCBndWFyYW50ZWVkXG4gIEJhY2t1cENvZGVjUG9saWN5W0JhY2t1cENvZGVjUG9saWN5W1wiUFJFRkVSX1JFR1JFU1NJT05cIl0gPSAwXSA9IFwiUFJFRkVSX1JFR1JFU1NJT05cIjtcbiAgLy8gbXVsdGktY29kZWMgc2ltdWxjYXN0LCBwdWJsaXNoIGJvdGggcHJpbWFyeSBhbmQgYmFja3VwIGNvZGVjIGF0IHRoZSBzYW1lIHRpbWVcbiAgQmFja3VwQ29kZWNQb2xpY3lbQmFja3VwQ29kZWNQb2xpY3lbXCJTSU1VTENBU1RcIl0gPSAxXSA9IFwiU0lNVUxDQVNUXCI7XG4gIC8vIGFsd2F5cyB1c2UgYmFja3VwIGNvZGVjIG9ubHlcbiAgQmFja3VwQ29kZWNQb2xpY3lbQmFja3VwQ29kZWNQb2xpY3lbXCJSRUdSRVNTSU9OXCJdID0gMl0gPSBcIlJFR1JFU1NJT05cIjtcbn0pKEJhY2t1cENvZGVjUG9saWN5IHx8IChCYWNrdXBDb2RlY1BvbGljeSA9IHt9KSk7XG52YXIgQXVkaW9QcmVzZXRzO1xuKGZ1bmN0aW9uIChBdWRpb1ByZXNldHMpIHtcbiAgQXVkaW9QcmVzZXRzLnRlbGVwaG9uZSA9IHtcbiAgICBtYXhCaXRyYXRlOiAxMjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMuc3BlZWNoID0ge1xuICAgIG1heEJpdHJhdGU6IDI0MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpYyA9IHtcbiAgICBtYXhCaXRyYXRlOiA0ODAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNTdGVyZW8gPSB7XG4gICAgbWF4Qml0cmF0ZTogNjQwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHkgPSB7XG4gICAgbWF4Qml0cmF0ZTogOTYwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHlTdGVyZW8gPSB7XG4gICAgbWF4Qml0cmF0ZTogMTI4MDAwXG4gIH07XG59KShBdWRpb1ByZXNldHMgfHwgKEF1ZGlvUHJlc2V0cyA9IHt9KSk7XG4vKipcbiAqIFNhbmUgcHJlc2V0cyBmb3IgdmlkZW8gcmVzb2x1dGlvbi9lbmNvZGluZ1xuICovXG5jb25zdCBWaWRlb1ByZXNldHMgPSB7XG4gIGg5MDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgOTAsIDkwMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTYwMDAwLCAyMCksXG4gIGgyMTY6IG5ldyBWaWRlb1ByZXNldCgzODQsIDIxNiwgMTgwMDAwLCAyMCksXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDUwMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDU0MCwgODAwMDAwLCAyNSksXG4gIGg3MjA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDE3MDAwMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAzMDAwMDAwLCAzMCksXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMjU2MCwgMTQ0MCwgNTAwMDAwMCwgMzApLFxuICBoMjE2MDogbmV3IFZpZGVvUHJlc2V0KDM4NDAsIDIxNjAsIDgwMDAwMDAsIDMwKVxufTtcbi8qKlxuICogRm91ciBieSB0aHJlZSBwcmVzZXRzXG4gKi9cbmNvbnN0IFZpZGVvUHJlc2V0czQzID0ge1xuICBoMTIwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCAxMjAsIDcwMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgyNDAsIDE4MCwgMTI1MDAwLCAyMCksXG4gIGgyNDA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDI0MCwgMTQwMDAwLCAyMCksXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg0ODAsIDM2MCwgMzMwMDAwLCAyMCksXG4gIGg0ODA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDQ4MCwgNTAwMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg3MjAsIDU0MCwgNjAwMDAwLCAyNSksXG4gIGg3MjA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDcyMCwgMTMwMDAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE0NDAsIDEwODAsIDIzMDAwMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxNDQwLCAzODAwMDAwLCAzMClcbn07XG5jb25zdCBTY3JlZW5TaGFyZVByZXNldHMgPSB7XG4gIGgzNjBmcHMzOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDIwMDAwMCwgMywgJ21lZGl1bScpLFxuICBoMzYwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgODAwMDAwLCA1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTUwMDAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAyMDAwMDAwLCAzMCwgJ21lZGl1bScpLFxuICBoMTA4MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgMjUwMDAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDUwMDAwMDAsIDMwLCAnbWVkaXVtJyksXG4gIC8vIG9yaWdpbmFsIHJlc29sdXRpb24sIHdpdGhvdXQgcmVzaXppbmdcbiAgb3JpZ2luYWw6IG5ldyBWaWRlb1ByZXNldCgwLCAwLCA3MDAwMDAwLCAzMCwgJ21lZGl1bScpXG59O1xuXG5jb25zdCBzZXBhcmF0b3IgPSAnfCc7XG5jb25zdCBkZEV4dGVuc2lvblVSSSA9ICdodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLXJ0cC1zcGVjLyNkZXBlbmRlbmN5LWRlc2NyaXB0b3ItcnRwLWhlYWRlci1leHRlbnNpb24nO1xuZnVuY3Rpb24gdW5wYWNrU3RyZWFtSWQocGFja2VkKSB7XG4gIGNvbnN0IHBhcnRzID0gcGFja2VkLnNwbGl0KHNlcGFyYXRvcik7XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFtwYXJ0c1swXSwgcGFja2VkLnN1YnN0cihwYXJ0c1swXS5sZW5ndGggKyAxKV07XG4gIH1cbiAgcmV0dXJuIFtwYWNrZWQsICcnXTtcbn1cbmZ1bmN0aW9uIHNsZWVwKGR1cmF0aW9uKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xuICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB7XG4gIHJldHVybiAnYWRkVHJhbnNjZWl2ZXInIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHN1cHBvcnRzQWRkVHJhY2soKSB7XG4gIHJldHVybiAnYWRkVHJhY2snIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzQWRhcHRpdmVTdHJlYW0oKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzRHluYWNhc3QoKSB7XG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCk7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0FWMSgpIHtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIC8vIFNhZmFyaSAxNyBvbiBpUGhvbmUxNCByZXBvcnRzIEFWMSBjYXBhYmlsaXR5LCBidXQgZG9lcyBub3QgYWN0dWFsbHkgc3VwcG9ydCBpdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICBsZXQgaGFzQVYxID0gZmFsc2U7XG4gIGlmIChjYXBhYmlsaXRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZSA9PT0gJ3ZpZGVvL0FWMScpIHtcbiAgICAgICAgaGFzQVYxID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBVjE7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1ZQOSgpIHtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXJlRm94KCkpIHtcbiAgICAvLyB0ZWNobmljYWxseSBzcGVha2luZyBGaXJlRm94IHN1cHBvcnRzIFZQOSwgYnV0IFNWQyBwdWJsaXNoaW5nIGlzIGJyb2tlblxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MzM4NzZcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIGlmICgoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLnZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxNicpIDwgMCkge1xuICAgICAgLy8gU2FmYXJpIDE2IGFuZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IFZQOVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICBsZXQgaGFzVlA5ID0gZmFsc2U7XG4gIGlmIChjYXBhYmlsaXRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZSA9PT0gJ3ZpZGVvL1ZQOScpIHtcbiAgICAgICAgaGFzVlA5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNWUDk7XG59XG5mdW5jdGlvbiBpc1NWQ0NvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBjb2RlYyA9PT0gJ2F2MScgfHwgY29kZWMgPT09ICd2cDknO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNTZXRTaW5rSWQoZWxtKSB7XG4gIGlmICghZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbG0pIHtcbiAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICB9XG4gIHJldHVybiAnc2V0U2lua0lkJyBpbiBlbG07XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkgfHwgc3VwcG9ydHNBZGRUcmFjaygpO1xufVxuZnVuY3Rpb24gaXNGaXJlRm94KCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdGaXJlZm94Jztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdTYWZhcmknO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkxNygpIHtcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcbiAgcmV0dXJuIChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIubmFtZSkgPT09ICdTYWZhcmknICYmIGIudmVyc2lvbi5zdGFydHNXaXRoKCcxNy4nKTtcbn1cbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoIWlzV2ViKCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGB1c2VyQWdlbnREYXRhYCBpcyBub3QgeWV0IHBhcnQgb2YgdHlwZXNjcmlwdFxuICAgIChfYiA9IChfYSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9iaWxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAvVGFibGV0fGlQYWR8TW9iaWxlfEFuZHJvaWR8QmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICApO1xufVxuZnVuY3Rpb24gaXNFMkVFU2ltdWxjYXN0U3VwcG9ydGVkKCkge1xuICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICBjb25zdCBzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uID0gJzE3LjInOyAvLyBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI1NzgwM1xuICBpZiAoYnJvd3Nlcikge1xuICAgIGlmIChicm93c2VyLm5hbWUgIT09ICdTYWZhcmknICYmIGJyb3dzZXIub3MgIT09ICdpT1MnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXIub3MgPT09ICdpT1MnICYmIGJyb3dzZXIub3NWZXJzaW9uICYmIGNvbXBhcmVWZXJzaW9ucyhzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uLCBicm93c2VyLm9zVmVyc2lvbikgPj0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChicm93c2VyLm5hbWUgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uLCBicm93c2VyLnZlcnNpb24pID49IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc1dlYigpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICAvLyBuYXZpZ2F0b3IucHJvZHVjdCBpcyBkZXByZWNhdGVkIG9uIGJyb3dzZXJzLCBidXQgd2lsbCBiZSBzZXQgYXBwcm9wcmlhdGVseSBmb3IgcmVhY3QtbmF0aXZlLlxuICByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3QgPT0gJ1JlYWN0TmF0aXZlJztcbn1cbmZ1bmN0aW9uIGlzQ2xvdWQoc2VydmVyVXJsKSB7XG4gIHJldHVybiBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LmNsb3VkJykgfHwgc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5ydW4nKTtcbn1cbmZ1bmN0aW9uIGdldExLUmVhY3ROYXRpdmVJbmZvKCkge1xuICAvLyBnbG9iYWwgZGVmaW5lZCBvbmx5IGZvciBSZWFjdE5hdGl2ZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWw7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0TmF0aXZlT3MoKSB7XG4gIGlmICghaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gIGlmIChpc1dlYigpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICB9XG4gIHJldHVybiAxO1xufVxuZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHYxLCB2Mikge1xuICBjb25zdCBwYXJ0czEgPSB2MS5zcGxpdCgnLicpO1xuICBjb25zdCBwYXJ0czIgPSB2Mi5zcGxpdCgnLicpO1xuICBjb25zdCBrID0gTWF0aC5taW4ocGFydHMxLmxlbmd0aCwgcGFydHMyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgY29uc3QgcDEgPSBwYXJzZUludChwYXJ0czFbaV0sIDEwKTtcbiAgICBjb25zdCBwMiA9IHBhcnNlSW50KHBhcnRzMltpXSwgMTApO1xuICAgIGlmIChwMSA+IHAyKSByZXR1cm4gMTtcbiAgICBpZiAocDEgPCBwMikgcmV0dXJuIC0xO1xuICAgIGlmIChpID09PSBrIC0gMSAmJiBwMSA9PT0gcDIpIHJldHVybiAwO1xuICB9XG4gIGlmICh2MSA9PT0gJycgJiYgdjIgIT09ICcnKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHYyID09PSAnJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBwYXJ0czEubGVuZ3RoID09IHBhcnRzMi5sZW5ndGggPyAwIDogcGFydHMxLmxlbmd0aCA8IHBhcnRzMi5sZW5ndGggPyAtMSA6IDE7XG59XG5mdW5jdGlvbiByb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlUmVzaXplKGVudHJ5KTtcbiAgfVxufVxuZnVuY3Rpb24gaW9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXMpIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgZW50cnkudGFyZ2V0LmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKGVudHJ5KTtcbiAgfVxufVxubGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbmNvbnN0IGdldFJlc2l6ZU9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIXJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihyb0Rpc3BhdGNoQ2FsbGJhY2spO1xuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59O1xubGV0IGludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbmNvbnN0IGdldEludGVyc2VjdGlvbk9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIWludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW9EaXNwYXRjaENhbGxiYWNrLCB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgcm9vdE1hcmdpbjogJzBweCdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59O1xuZnVuY3Rpb24gZ2V0Q2xpZW50SW5mbygpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBpbmZvID0gbmV3IENsaWVudEluZm8oe1xuICAgIHNkazogQ2xpZW50SW5mb19TREsuSlMsXG4gICAgcHJvdG9jb2w6IHByb3RvY29sVmVyc2lvbixcbiAgICB2ZXJzaW9uXG4gIH0pO1xuICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgaW5mby5vcyA9IChfYSA9IGdldFJlYWN0TmF0aXZlT3MoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5sZXQgZW1wdHlWaWRlb1N0cmVhbVRyYWNrO1xuZnVuY3Rpb24gZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBpZiAoIWVtcHR5VmlkZW9TdHJlYW1UcmFjaykge1xuICAgIGVtcHR5VmlkZW9TdHJlYW1UcmFjayA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygpO1xuICB9XG4gIHJldHVybiBlbXB0eVZpZGVvU3RyZWFtVHJhY2suY2xvbmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygpIHtcbiAgbGV0IHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxNjtcbiAgbGV0IGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XG4gIGxldCBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgbGV0IHBhaW50Q29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAvLyB0aGUgY2FudmFzIHNpemUgaXMgc2V0IHRvIDE2IGJ5IGRlZmF1bHQsIGJlY2F1c2UgZWxlY3Ryb24gYXBwcyBzZWVtIHRvIGZhaWwgd2l0aCBzbWFsbGVyIHZhbHVlc1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBpZiAocGFpbnRDb250ZW50ICYmIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgNTAsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdncmV5JztcbiAgICBjdHguZmlsbCgpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgZHVtbXlTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuICBjb25zdCBbZHVtbXlUcmFja10gPSBkdW1teVN0cmVhbS5nZXRUcmFja3MoKTtcbiAgaWYgKCFkdW1teVRyYWNrKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIHZpZGVvIHRyYWNrJyk7XG4gIH1cbiAgZHVtbXlUcmFjay5lbmFibGVkID0gZW5hYmxlZDtcbiAgcmV0dXJuIGR1bW15VHJhY2s7XG59XG5sZXQgZW1wdHlBdWRpb1N0cmVhbVRyYWNrO1xuZnVuY3Rpb24gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCkge1xuICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgIC8vIGltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbSBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2VicnRjL3dhcm0tdXAtd2l0aC1yZXBsYWNldHJhY2svXG4gICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGNvbnN0IG9zY2lsbGF0b3IgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgIGNvbnN0IGdhaW4gPSBjdHguY3JlYXRlR2FpbigpO1xuICAgIGdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCAwKTtcbiAgICBjb25zdCBkc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgIG9zY2lsbGF0b3IuY29ubmVjdChnYWluKTtcbiAgICBnYWluLmNvbm5lY3QoZHN0KTtcbiAgICBvc2NpbGxhdG9yLnN0YXJ0KCk7XG4gICAgW2VtcHR5QXVkaW9TdHJlYW1UcmFja10gPSBkc3Quc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcbiAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSBhdWRpbyB0cmFjaycpO1xuICAgIH1cbiAgICBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suY2xvbmUoKTtcbn1cbmNsYXNzIEZ1dHVyZSB7XG4gIGNvbnN0cnVjdG9yKGZ1dHVyZUJhc2UsIG9uRmluYWxseSkge1xuICAgIHRoaXMub25GaW5hbGx5ID0gb25GaW5hbGx5O1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIGlmIChmdXR1cmVCYXNlKSB7XG4gICAgICAgIHlpZWxkIGZ1dHVyZUJhc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5vbkZpbmFsbHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYW5hbHlzZXIgd2ViIGF1ZGlvIG5vZGUgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgdHJhY2suXG4gKiBBZGRpdGlvbmFsbHkgcmV0dXJucyBhIGNvbnZlbmllbmNlIG1ldGhvZCBgY2FsY3VsYXRlVm9sdW1lYCB0byBwZXJmb3JtIGluc3RhbnQgdm9sdW1lIHJlYWRpbmdzIG9uIHRoYXQgdHJhY2suXG4gKiBDYWxsIHRoZSByZXR1cm5lZCBgY2xlYW51cGAgZnVuY3Rpb24gdG8gY2xvc2UgdGhlIGF1ZGlvQ29udGV4dCB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgZm9yIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGhlbHBlclxuICovXG5mdW5jdGlvbiBjcmVhdGVBdWRpb0FuYWx5c2VyKHRyYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBjbG9uZVRyYWNrOiBmYWxzZSxcbiAgICBmZnRTaXplOiAyMDQ4LFxuICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC44LFxuICAgIG1pbkRlY2liZWxzOiAtMTAwLFxuICAgIG1heERlY2liZWxzOiAtODBcbiAgfSwgb3B0aW9ucyk7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXVkaW8gQ29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xuICB9XG4gIGNvbnN0IHN0cmVhbVRyYWNrID0gb3B0cy5jbG9uZVRyYWNrID8gdHJhY2subWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpIDogdHJhY2subWVkaWFTdHJlYW1UcmFjaztcbiAgY29uc3QgbWVkaWFTdHJlYW1Tb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFtzdHJlYW1UcmFja10pKTtcbiAgY29uc3QgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgYW5hbHlzZXIubWluRGVjaWJlbHMgPSBvcHRzLm1pbkRlY2liZWxzO1xuICBhbmFseXNlci5tYXhEZWNpYmVscyA9IG9wdHMubWF4RGVjaWJlbHM7XG4gIGFuYWx5c2VyLmZmdFNpemUgPSBvcHRzLmZmdFNpemU7XG4gIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IG9wdHMuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHRyYWNrIGluIHRoZSByYW5nZSBmcm9tIDAgdG8gMVxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlVm9sdW1lID0gKCkgPT4ge1xuICAgIGFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGFBcnJheSk7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChjb25zdCBhbXBsaXR1ZGUgb2YgZGF0YUFycmF5KSB7XG4gICAgICBzdW0gKz0gTWF0aC5wb3coYW1wbGl0dWRlIC8gMjU1LCAyKTtcbiAgICB9XG4gICAgY29uc3Qgdm9sdW1lID0gTWF0aC5zcXJ0KHN1bSAvIGRhdGFBcnJheS5sZW5ndGgpO1xuICAgIHJldHVybiB2b2x1bWU7XG4gIH07XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgaWYgKG9wdHMuY2xvbmVUcmFjaykge1xuICAgICAgc3RyZWFtVHJhY2suc3RvcCgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsY3VsYXRlVm9sdW1lLFxuICAgIGFuYWx5c2VyLFxuICAgIGNsZWFudXBcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW9Db2RlYyhtYXliZUNvZGVjKSB7XG4gIHJldHVybiB2aWRlb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjKTtcbn1cbmZ1bmN0aW9uIHVud3JhcENvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb25zdHJhaW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjb25zdHJhaW50O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5pZGVhbCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbDtcbiAgfVxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XG59XG5mdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14oaHR0cCkvLCAnd3MnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gdG9IdHRwVXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3dzJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14od3MpLywgJ2h0dHAnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zY3JpcHRpb25TZWdtZW50cyh0cmFuc2NyaXB0aW9uLCBmaXJzdFJlY2VpdmVkVGltZXNNYXApIHtcbiAgcmV0dXJuIHRyYW5zY3JpcHRpb24uc2VnbWVudHMubWFwKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICBpZCxcbiAgICAgIHRleHQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBmaW5hbFxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBmaXJzdFJlY2VpdmVkVGltZSA9IChfYSA9IGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5nZXQoaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGxhc3RSZWNlaXZlZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZmlyc3RSZWNlaXZlZFRpbWVzTWFwLmRlbGV0ZShpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5zZXQoaWQsIGZpcnN0UmVjZWl2ZWRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgdGV4dCxcbiAgICAgIHN0YXJ0VGltZTogTnVtYmVyLnBhcnNlSW50KHN0YXJ0VGltZS50b1N0cmluZygpKSxcbiAgICAgIGVuZFRpbWU6IE51bWJlci5wYXJzZUludChlbmRUaW1lLnRvU3RyaW5nKCkpLFxuICAgICAgZmluYWwsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGZpcnN0UmVjZWl2ZWRUaW1lLFxuICAgICAgbGFzdFJlY2VpdmVkVGltZVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZXh0cmFjdENoYXRNZXNzYWdlKG1zZykge1xuICBjb25zdCB7XG4gICAgaWQsXG4gICAgdGltZXN0YW1wLFxuICAgIG1lc3NhZ2UsXG4gICAgZWRpdFRpbWVzdGFtcFxuICB9ID0gbXNnO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHRpbWVzdGFtcDogTnVtYmVyLnBhcnNlSW50KHRpbWVzdGFtcC50b1N0cmluZygpKSxcbiAgICBlZGl0VGltZXN0YW1wOiBlZGl0VGltZXN0YW1wID8gTnVtYmVyLnBhcnNlSW50KGVkaXRUaW1lc3RhbXAudG9TdHJpbmcoKSkgOiB1bmRlZmluZWQsXG4gICAgbWVzc2FnZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IoZSkge1xuICBzd2l0Y2ggKGUucmVhc29uKSB7XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0OlxuICAgICAgcmV0dXJuIGUuY29udGV4dDtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQ6XG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEO1xuICAgIGNhc2UgQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQ6XG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5VU0VSX1JFSkVDVEVEO1xuICAgIGNhc2UgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlOlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uSk9JTl9GQUlMVVJFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5VTktOT1dOX1JFQVNPTjtcbiAgfVxufVxuLyoqIGNvbnZlcnQgYmlnaW50cyB0byBudW1iZXJzIHByZXNlcnZpbmcgdW5kZWZpbmVkIHZhbHVlcyAqL1xuZnVuY3Rpb24gYmlnSW50VG9OdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBOdW1iZXIodmFsdWUpIDogdW5kZWZpbmVkO1xufVxuLyoqIGNvbnZlcnQgbnVtYmVycyB0byBiaWdpbnRzIHByZXNlcnZpbmcgdW5kZWZpbmVkIHZhbHVlcyAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBCaWdJbnQodmFsdWUpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNMb2NhbFRyYWNrKHRyYWNrKSB7XG4gIHJldHVybiAhIXRyYWNrICYmICEodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSAmJiB0cmFjay5pc0xvY2FsO1xufVxuZnVuY3Rpb24gaXNBdWRpb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5BdWRpbztcbn1cbmZ1bmN0aW9uIGlzVmlkZW9UcmFjayh0cmFjaykge1xuICByZXR1cm4gISF0cmFjayAmJiB0cmFjay5raW5kID09IFRyYWNrLktpbmQuVmlkZW87XG59XG5mdW5jdGlvbiBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykge1xuICByZXR1cm4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBpc1ZpZGVvVHJhY2sodHJhY2spO1xufVxuZnVuY3Rpb24gaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuIGlzTG9jYWxUcmFjayh0cmFjaykgJiYgaXNBdWRpb1RyYWNrKHRyYWNrKTtcbn1cbmZ1bmN0aW9uIGlzUmVtb3RlVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuICEhdHJhY2sgJiYgIXRyYWNrLmlzTG9jYWw7XG59XG5mdW5jdGlvbiBpc1JlbW90ZVB1YihwdWIpIHtcbiAgcmV0dXJuICEhcHViICYmICFwdWIuaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIGlzUmVtb3RlVmlkZW9UcmFjayh0cmFjaykge1xuICByZXR1cm4gaXNSZW1vdGVUcmFjayh0cmFjaykgJiYgaXNWaWRlb1RyYWNrKHRyYWNrKTtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxQYXJ0aWNpcGFudChwKSB7XG4gIHJldHVybiBwLmlzTG9jYWw7XG59XG5mdW5jdGlvbiBpc1JlbW90ZVBhcnRpY2lwYW50KHApIHtcbiAgcmV0dXJuICFwLmlzTG9jYWw7XG59XG5mdW5jdGlvbiBzcGxpdFV0Zjgocywgbikge1xuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYwNDM3OTdcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBlbmNvZGVkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xuICB3aGlsZSAoZW5jb2RlZC5sZW5ndGggPiBuKSB7XG4gICAgbGV0IGsgPSBuO1xuICAgIHdoaWxlIChrID4gMCkge1xuICAgICAgY29uc3QgYnl0ZSA9IGVuY29kZWRba107XG4gICAgICBpZiAoYnl0ZSAhPT0gdW5kZWZpbmVkICYmIChieXRlICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBrLS07XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGVuY29kZWQuc2xpY2UoMCwgaykpO1xuICAgIGVuY29kZWQgPSBlbmNvZGVkLnNsaWNlKGspO1xuICB9XG4gIGlmIChlbmNvZGVkLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQucHVzaChlbmNvZGVkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgdmFyIF9jLCBfZDtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yLFxuICAgIGF1ZGlvUHJvY2Vzc29yLFxuICAgIHZpZGVvUHJvY2Vzc29yXG4gIH0gPSBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcbiAgY29uc3QgZGVmYXVsdEF1ZGlvUHJvY2Vzc29yID0gYXVkaW9EZWZhdWx0cyA9PT0gbnVsbCB8fCBhdWRpb0RlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdWRpb0RlZmF1bHRzLnByb2Nlc3NvcjtcbiAgY29uc3QgZGVmYXVsdFZpZGVvUHJvY2Vzc29yID0gdmlkZW9EZWZhdWx0cyA9PT0gbnVsbCB8fCB2aWRlb0RlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0RlZmF1bHRzLnByb2Nlc3NvcjtcbiAgY29uc3QgY2xvbmVkT3B0aW9ucyA9IG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yICE9PSBudWxsICYmIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yICE9PSB2b2lkIDAgPyBvcHRpb25zV2l0aG91dFByb2Nlc3NvciA6IHt9O1xuICBpZiAoY2xvbmVkT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSkgY2xvbmVkT3B0aW9ucy5hdWRpbyA9IHt9O1xuICBpZiAoY2xvbmVkT3B0aW9ucy52aWRlbyA9PT0gdHJ1ZSkgY2xvbmVkT3B0aW9ucy52aWRlbyA9IHt9O1xuICAvLyB1c2UgZGVmYXVsdHNcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhjbG9uZWRPcHRpb25zLmF1ZGlvLCBhdWRpb0RlZmF1bHRzKTtcbiAgICAoX2EgPSAoX2MgPSBjbG9uZWRPcHRpb25zLmF1ZGlvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX2MuZGV2aWNlSWQgPSB7XG4gICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgfTtcbiAgICBpZiAoYXVkaW9Qcm9jZXNzb3IgfHwgZGVmYXVsdEF1ZGlvUHJvY2Vzc29yKSB7XG4gICAgICBjbG9uZWRPcHRpb25zLmF1ZGlvLnByb2Nlc3NvciA9IGF1ZGlvUHJvY2Vzc29yICE9PSBudWxsICYmIGF1ZGlvUHJvY2Vzc29yICE9PSB2b2lkIDAgPyBhdWRpb1Byb2Nlc3NvciA6IGRlZmF1bHRBdWRpb1Byb2Nlc3NvcjtcbiAgICB9XG4gIH1cbiAgaWYgKGNsb25lZE9wdGlvbnMudmlkZW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhjbG9uZWRPcHRpb25zLnZpZGVvLCB2aWRlb0RlZmF1bHRzKTtcbiAgICAoX2IgPSAoX2QgPSBjbG9uZWRPcHRpb25zLnZpZGVvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX2QuZGV2aWNlSWQgPSB7XG4gICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgfTtcbiAgICBpZiAodmlkZW9Qcm9jZXNzb3IgfHwgZGVmYXVsdFZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICBjbG9uZWRPcHRpb25zLnZpZGVvLnByb2Nlc3NvciA9IHZpZGVvUHJvY2Vzc29yICE9PSBudWxsICYmIHZpZGVvUHJvY2Vzc29yICE9PSB2b2lkIDAgPyB2aWRlb1Byb2Nlc3NvciA6IGRlZmF1bHRWaWRlb1Byb2Nlc3NvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhtYWluT2JqZWN0LCBvYmplY3RUb01lcmdlKSB7XG4gIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAobWFpbk9iamVjdFtrZXldID09PSB1bmRlZmluZWQpIG1haW5PYmplY3Rba2V5XSA9IG9iamVjdFRvTWVyZ2Vba2V5XTtcbiAgfSk7XG4gIHJldHVybiBtYWluT2JqZWN0O1xufVxuZnVuY3Rpb24gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgdmFyIF9jLCBfZDtcbiAgY29uc3QgY29uc3RyYWludHMgPSB7fTtcbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAvLyBkZWZhdWx0IHZpZGVvIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCB2aWRlb09wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHZpZGVvT3B0aW9ucztcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMudmlkZW87XG4gICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdyZXNvbHV0aW9uJzpcbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gVmlkZW9SZXNvbHV0aW9uIGZpZWxkc1xuICAgICAgICAgICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcodGFyZ2V0LCBzb3VyY2UucmVzb2x1dGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHZpZGVvT3B0aW9ucztcbiAgICAgIChfYSA9IChfYyA9IGNvbnN0cmFpbnRzLnZpZGVvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX2MuZGV2aWNlSWQgPSB7XG4gICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gb3B0aW9ucy52aWRlbyA/IHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICAgIH1cbiAgICAgIH0gOiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICAgIChfYiA9IChfZCA9IGNvbnN0cmFpbnRzLmF1ZGlvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX2QuZGV2aWNlSWQgPSB7XG4gICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0ge1xuICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyBzaWxlbmNlIG9uIGEgZ2l2ZW4gW1tUcmFja11dIGluc3RhbmNlLlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFjayBzZWVtcyB0byBiZSBlbnRpcmVseSBzaWxlbnQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNpbGVuY2UodHJhY2tfMSkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICBsZXQgdGltZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjAwO1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY3R4ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGNvbnN0IGFuYWx5c2VyID0gY3R4LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIGFuYWx5c2VyLmZmdFNpemUgPSAyMDQ4O1xuICAgICAgICBjb25zdCBidWZmZXJMZW5ndGggPSBhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pKTtcbiAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgICAgICB5aWVsZCBzbGVlcCh0aW1lT2Zmc2V0KTtcbiAgICAgICAgYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGRhdGFBcnJheSk7XG4gICAgICAgIGNvbnN0IHNvbWVOb2lzZSA9IGRhdGFBcnJheS5zb21lKHNhbXBsZSA9PiBzYW1wbGUgIT09IDEyOCAmJiBzYW1wbGUgIT09IDApO1xuICAgICAgICBjdHguY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuICFzb21lTm9pc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSgpO1xuICB9KTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5ld0F1ZGlvQ29udGV4dCgpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBBdWRpb0NvbnRleHQgPVxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICBpZiAoQXVkaW9Db250ZXh0KSB7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICBsYXRlbmN5SGludDogJ2ludGVyYWN0aXZlJ1xuICAgIH0pO1xuICAgIC8vIElmIHRoZSBhdWRpbyBjb250ZXh0IGlzIHN1c3BlbmRlZCwgd2UgbmVlZCB0byByZXN1bWUgaXQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIHBhZ2VcbiAgICBpZiAoYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gd2luZG93LmRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm9keSkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZVJlc3VtZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICB5aWVsZCBhdWRpb0NvbnRleHQucmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciB0cnlpbmcgdG8gYXV0by1yZXN1bWUgYXVkaW8gY29udGV4dCcsIGUpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVSZXN1bWUpO1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XG4gICAgfVxuICAgIHJldHVybiBhdWRpb0NvbnRleHQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHNvdXJjZVRvS2luZChzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpIHtcbiAgICByZXR1cm4gJ2F1ZGlvaW5wdXQnO1xuICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xuICAgIHJldHVybiAndmlkZW9pbnB1dCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCB2aWRlb0NvbnN0cmFpbnRzID0gKF9hID0gb3B0aW9ucy52aWRlbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgLy8gdHJlYXQgMCBhcyB1bmNhcHBlZFxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICYmIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCA+IDAgJiYgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCA+IDApIHtcbiAgICB2aWRlb0NvbnN0cmFpbnRzID0gdHlwZW9mIHZpZGVvQ29uc3RyYWludHMgPT09ICdib29sZWFuJyA/IHt9IDogdmlkZW9Db25zdHJhaW50cztcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9Db25zdHJhaW50cyksIHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9Db25zdHJhaW50cyksIHtcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYXVkaW86IChfYiA9IG9wdGlvbnMuYXVkaW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc3VwcG9ydCBmb3IgZXhwZXJpbWVudGFsIGRpc3BsYXkgbWVkaWEgZmVhdHVyZXNcbiAgICBjb250cm9sbGVyOiBvcHRpb25zLmNvbnRyb2xsZXIsXG4gICAgc2VsZkJyb3dzZXJTdXJmYWNlOiBvcHRpb25zLnNlbGZCcm93c2VyU3VyZmFjZSxcbiAgICBzdXJmYWNlU3dpdGNoaW5nOiBvcHRpb25zLnN1cmZhY2VTd2l0Y2hpbmcsXG4gICAgc3lzdGVtQXVkaW86IG9wdGlvbnMuc3lzdGVtQXVkaW8sXG4gICAgcHJlZmVyQ3VycmVudFRhYjogb3B0aW9ucy5wcmVmZXJDdXJyZW50VGFiXG4gIH07XG59XG5mdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZSkge1xuICByZXR1cm4gbWltZVR5cGUuc3BsaXQoJy8nKVsxXS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8odHJhY2tzKSB7XG4gIGNvbnN0IGluZm9zID0gW107XG4gIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICBpZiAodHJhY2sudHJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5mb3MucHVzaChuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSh7XG4gICAgICAgIGNpZDogdHJhY2sudHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgICAgdHJhY2s6IHRyYWNrLnRyYWNrSW5mb1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbmZvcztcbn1cbmZ1bmN0aW9uIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spIHtcbiAgaWYgKCdtZWRpYVN0cmVhbVRyYWNrJyBpbiB0cmFjaykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja0lEOiB0cmFjay5zaWQsXG4gICAgICBzb3VyY2U6IHRyYWNrLnNvdXJjZSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgZW5hYmxlZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5lbmFibGVkLFxuICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgIHN0cmVhbUlEOiB0cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgc3RyZWFtVHJhY2tJRDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrSUQ6IHRyYWNrLnRyYWNrU2lkLFxuICAgICAgZW5hYmxlZDogdHJhY2suaXNFbmFibGVkLFxuICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICB0cmFja0luZm86IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBtaW1lVHlwZTogdHJhY2subWltZVR5cGUsXG4gICAgICAgIG5hbWU6IHRyYWNrLnRyYWNrTmFtZSxcbiAgICAgICAgZW5jcnlwdGVkOiB0cmFjay5pc0VuY3J5cHRlZCxcbiAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgc291cmNlOiB0cmFjay5zb3VyY2VcbiAgICAgIH0sIHRyYWNrLnRyYWNrID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjay50cmFjaykgOiB7fSlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKSB7XG4gIHJldHVybiB0eXBlb2YgUlRDUnRwUmVjZWl2ZXIgIT09ICd1bmRlZmluZWQnICYmICdnZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzJyBpbiBSVENSdHBSZWNlaXZlcjtcbn1cbmZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKG9sZFZhbHVlcywgbmV3VmFsdWVzKSB7XG4gIHZhciBfYTtcbiAgaWYgKG9sZFZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2xkVmFsdWVzID0ge307XG4gIH1cbiAgaWYgKG5ld1ZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbmV3VmFsdWVzID0ge307XG4gIH1cbiAgY29uc3QgYWxsS2V5cyA9IFsuLi5PYmplY3Qua2V5cyhuZXdWYWx1ZXMpLCAuLi5PYmplY3Qua2V5cyhvbGRWYWx1ZXMpXTtcbiAgY29uc3QgZGlmZiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgaWYgKG9sZFZhbHVlc1trZXldICE9PSBuZXdWYWx1ZXNba2V5XSkge1xuICAgICAgZGlmZltrZXldID0gKF9hID0gbmV3VmFsdWVzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIGxldCBhdWRpb1Byb2Nlc3NvcjtcbiAgbGV0IHZpZGVvUHJvY2Vzc29yO1xuICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmIG5ld09wdGlvbnMuYXVkaW8ucHJvY2Vzc29yKSB7XG4gICAgYXVkaW9Qcm9jZXNzb3IgPSBuZXdPcHRpb25zLmF1ZGlvLnByb2Nlc3NvcjtcbiAgICBuZXdPcHRpb25zLmF1ZGlvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdPcHRpb25zLmF1ZGlvKSwge1xuICAgICAgcHJvY2Vzc29yOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIG5ld09wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnICYmIG5ld09wdGlvbnMudmlkZW8ucHJvY2Vzc29yKSB7XG4gICAgdmlkZW9Qcm9jZXNzb3IgPSBuZXdPcHRpb25zLnZpZGVvLnByb2Nlc3NvcjtcbiAgICBuZXdPcHRpb25zLnZpZGVvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdPcHRpb25zLnZpZGVvKSwge1xuICAgICAgcHJvY2Vzc29yOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGF1ZGlvUHJvY2Vzc29yLFxuICAgIHZpZGVvUHJvY2Vzc29yLFxuICAgIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yOiBjbG9uZURlZXAobmV3T3B0aW9ucylcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRyYWNrU291cmNlRnJvbVByb3RvKHNvdXJjZSkge1xuICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5NSUNST1BIT05FOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBFMkVFTWFuYWdlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vbldvcmtlck1lc3NhZ2UgPSBldiA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3Qge1xuICAgICAgICBraW5kLFxuICAgICAgICBkYXRhXG4gICAgICB9ID0gZXYuZGF0YTtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBkYXRhLmVycm9yKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5pdEFjayc6XG4gICAgICAgICAgaWYgKGRhdGEuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbmFibGUnOlxuICAgICAgICAgIGlmIChkYXRhLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCAhPT0gZGF0YS5lbmFibGVkICYmIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSAoX2IgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiY291bGRuJ3Qgc2V0IGVuY3J5cHRpb24gc3RhdHVzLCBwYXJ0aWNpcGFudCBub3QgZm91bmRcIi5jb25jYXQoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgcGFydGljaXBhbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmF0Y2hldEtleSc6XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5lbWl0KEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBkYXRhLm1hdGVyaWFsLCBkYXRhLmtleUluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25Xb3JrZXJFcnJvciA9IGV2ID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoJ2UyZWUgd29ya2VyIGVuY291bnRlcmVkIGFuIGVycm9yOicsIHtcbiAgICAgICAgZXJyb3I6IGV2LmVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBldi5lcnJvcik7XG4gICAgfTtcbiAgICB0aGlzLmtleVByb3ZpZGVyID0gb3B0aW9ucy5rZXlQcm92aWRlcjtcbiAgICB0aGlzLndvcmtlciA9IG9wdGlvbnMud29ya2VyO1xuICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cChyb29tKSB7XG4gICAgaWYgKCFpc0UyRUVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ3RyaWVkIHRvIHNldHVwIGVuZC10by1lbmQgZW5jcnlwdGlvbiBvbiBhbiB1bnN1cHBvcnRlZCBicm93c2VyJyk7XG4gICAgfVxuICAgIGxpdmVraXRMb2dnZXIuaW5mbygnc2V0dGluZyB1cCBlMmVlJyk7XG4gICAgaWYgKHJvb20gIT09IHRoaXMucm9vbSkge1xuICAgICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCB0aGlzLmtleVByb3ZpZGVyKTtcbiAgICAgIC8vIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcignJyk7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGtleVByb3ZpZGVyT3B0aW9uczogdGhpcy5rZXlQcm92aWRlci5nZXRPcHRpb25zKCksXG4gICAgICAgICAgbG9nbGV2ZWw6IHdvcmtlckxvZ2dlci5nZXRMZXZlbCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiaW5pdGlhbGl6aW5nIHdvcmtlclwiLCB7XG4gICAgICAgICAgd29ya2VyOiB0aGlzLndvcmtlclxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbldvcmtlck1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSB0aGlzLm9uV29ya2VyRXJyb3I7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJzZXQgZTJlZSB0byBcIi5jb25jYXQoZW5hYmxlZCwgXCIgZm9yIHBhcnRpY2lwYW50IFwiKS5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSkpO1xuICAgIHRoaXMucG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRTaWZUcmFpbGVyKHRyYWlsZXIpIHtcbiAgICBpZiAoIXRyYWlsZXIgfHwgdHJhaWxlci5sZW5ndGggPT09IDApIHtcbiAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImlnbm9yaW5nIHNlcnZlciBzZW50IHRyYWlsZXIgYXMgaXQncyBlbXB0eVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3N0U2lmVHJhaWxlcih0cmFpbGVyKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XG4gICAgZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJUUFZpZGVvTWFwVXBkYXRlLCBydHBNYXAgPT4ge1xuICAgICAgdGhpcy5wb3N0UlRQTWFwKHJ0cE1hcCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCBrZXlQcm92aWRlcikge1xuICAgIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAocHViLCBwYXJ0aWNpcGFudCkgPT4gdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KSk7XG4gICAgcm9vbS5vbihSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJvb20ucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4ge1xuICAgICAgICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBfLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAncmVtb3ZlVHJhbnNmb3JtJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLm1lZGlhU3RyZWFtSURcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChfYSA9IHRoaXMud29ya2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UobXNnKTtcbiAgICB9KS5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YiwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFUmVjZWl2ZXIodHJhY2ssIHBhcnRpY2lwYW50LmlkZW50aXR5LCBwdWIudHJhY2tJbmZvKTtcbiAgICB9KS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucm9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0ZWQgcm9vbSB0byBiZSBwcmVzZW50IG9uIHNpZ25hbCBjb25uZWN0XCIpO1xuICAgICAgfVxuICAgICAga2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlzRTJFRUVuYWJsZWQsIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICB9KTtcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRVNlbmRlcihwdWJsaWNhdGlvbi50cmFjaywgcHVibGljYXRpb24udHJhY2suc2VuZGVyKTtcbiAgICB9KSk7XG4gICAga2V5UHJvdmlkZXIub24oS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8gPT4gdGhpcy5wb3N0S2V5KGtleUluZm8pKS5vbihLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCAocGFydGljaXBhbnRJZCwga2V5SW5kZXgpID0+IHRoaXMucG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWQsIGtleUluZGV4LCBrZXlQcm92aWRlci5nZXRPcHRpb25zKCkuYWxsb3dLZXlFeHRyYWN0aW9uKSk7XG4gIH1cbiAgcG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4LCBleHRyYWN0YWJsZSkge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcmF0Y2hldCBrZXksIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdyYXRjaGV0UmVxdWVzdCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGtleUluZGV4LFxuICAgICAgICBleHRyYWN0YWJsZVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBwb3N0S2V5KF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3Qgc2V0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldEtleScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGlzUHVibGlzaGVyOiBwYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSksXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBjb25zdCBlbmFibGVNc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmFibGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShlbmFibGVNc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ZhaWxlZCB0byBlbmFibGUgZTJlZSwgd29ya2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgfVxuICBwb3N0UlRQTWFwKG1hcCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIGxvY2FsIHBhcnRpY2lwYW50IGlkZW50aXR5IGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFJUUE1hcCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcCxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdFNpZlRyYWlsZXIodHJhaWxlcikge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcG9zdCBTSUYgdHJhaWxlciwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFNpZlRyYWlsZXInLFxuICAgICAgZGF0YToge1xuICAgICAgICB0cmFpbGVyXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCByZW1vdGVJZCwgdHJhY2tJbmZvKSB7XG4gICAgaWYgKCF0cmFjay5yZWNlaXZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0cmFja0luZm8gPT09IG51bGwgfHwgdHJhY2tJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0luZm8ubWltZVR5cGUpIHx8IHRyYWNrSW5mby5taW1lVHlwZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pbWVUeXBlIG1pc3NpbmcgZnJvbSB0cmFja0luZm8sIGNhbm5vdCBzZXQgdXAgRTJFRSBjcnlwdG9yJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlUmVjZWl2ZXIodHJhY2sucmVjZWl2ZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHJlbW90ZUlkLCB0cmFjay5raW5kID09PSAndmlkZW8nID8gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodHJhY2tJbmZvLm1pbWVUeXBlKSA6IHVuZGVmaW5lZCk7XG4gIH1cbiAgc2V0dXBFMkVFU2VuZGVyKHRyYWNrLCBzZW5kZXIpIHtcbiAgICBpZiAoIWlzTG9jYWxUcmFjayh0cmFjaykgfHwgIXNlbmRlcikge1xuICAgICAgaWYgKCFzZW5kZXIpIGxpdmVraXRMb2dnZXIud2FybignZWFybHkgcmV0dXJuIGJlY2F1c2Ugc2VuZGVyIGlzIG5vdCByZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVNlbmRlcihzZW5kZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHVuZGVmaW5lZCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBSZWNlaXZlcn0gYnkgY3JlYXRpbmcgYSB7QGNvZGUgVHJhbnNmb3JtU3RyZWFtfSB3aGljaCB3aWxsIGluamVjdFxuICAgKiBhIGZyYW1lIGRlY29kZXIuXG4gICAqXG4gICAqL1xuICBoYW5kbGVSZWNlaXZlcihyZWNlaXZlciwgdHJhY2tJZCwgcGFydGljaXBhbnRJZGVudGl0eSwgY29kZWMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGtpbmQ6ICdkZWNvZGUnLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICBjb2RlY1xuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlY2VpdmVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKEUyRUVfRkxBRyBpbiByZWNlaXZlciAmJiBjb2RlYykge1xuICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIGNvZGVjXG4gICAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgICAga2luZDogJ3VwZGF0ZUNvZGVjJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHdyaXRhYmxlID0gcmVjZWl2ZXIud3JpdGFibGVTdHJlYW07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHJlYWRhYmxlID0gcmVjZWl2ZXIucmVhZGFibGVTdHJlYW07XG4gICAgICAgIGlmICghd3JpdGFibGUgfHwgIXJlYWRhYmxlKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IHJlY2VpdmVyU3RyZWFtcyA9IHJlY2VpdmVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHJlY2VpdmVyLndyaXRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLndyaXRhYmxlO1xuICAgICAgICAgIHdyaXRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLndyaXRhYmxlO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByZWNlaXZlci5yZWFkYWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy5yZWFkYWJsZTtcbiAgICAgICAgICByZWFkYWJsZSA9IHJlY2VpdmVyU3RyZWFtcy5yZWFkYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAga2luZDogJ2RlY29kZScsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcmVhZGFibGVTdHJlYW06IHJlYWRhYmxlLFxuICAgICAgICAgICAgd3JpdGFibGVTdHJlYW06IHdyaXRhYmxlLFxuICAgICAgICAgICAgdHJhY2tJZDogdHJhY2tJZCxcbiAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbcmVhZGFibGUsIHdyaXRhYmxlXSk7XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZWNlaXZlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4ge0Bjb2RlIFJUQ1J0cFNlbmRlcn0gYnkgY3JlYXRpbmcgYSB7QGNvZGUgVHJhbnNmb3JtU3RyZWFtfSB3aGljaCB3aWxsIGluamVjdFxuICAgKiBhIGZyYW1lIGVuY29kZXIuXG4gICAqXG4gICAqL1xuICBoYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFja0lkLCBjb2RlYykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoRTJFRV9GTEFHIGluIHNlbmRlciB8fCAhdGhpcy53b3JrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkgfHwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2xvY2FsIGlkZW50aXR5IG5lZWRzIHRvIGJlIGtub3duIGluIG9yZGVyIHRvIHNldCB1cCBlbmNyeXB0ZWQgc2VuZGVyJyk7XG4gICAgfVxuICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgc2NyaXB0IHRyYW5zZm9ybScpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAga2luZDogJ2VuY29kZScsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICB0cmFja0lkLFxuICAgICAgICBjb2RlY1xuICAgICAgfTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNlbmRlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdpbml0aWFsaXplIGVuY29kZWQgc3RyZWFtcycpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3Qgc2VuZGVyU3RyZWFtcyA9IHNlbmRlci5jcmVhdGVFbmNvZGVkU3RyZWFtcygpO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiBzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLFxuICAgICAgICAgIHdyaXRhYmxlU3RyZWFtOiBzZW5kZXJTdHJlYW1zLndyaXRhYmxlLFxuICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3NlbmRlclN0cmVhbXMucmVhZGFibGUsIHNlbmRlclN0cmVhbXMud3JpdGFibGVdKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNlbmRlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgfVxufVxuXG5jb25zdCBkZWZhdWx0SWQgPSAnZGVmYXVsdCc7XG5jbGFzcyBEZXZpY2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcHJldmlvdXNEZXZpY2VzID0gW107XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuICBnZXQgcHJldmlvdXNEZXZpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RldmljZXM7XG4gIH1cbiAgZ2V0RGV2aWNlcyhraW5kXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpID4gMCkge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2F3YWl0aW5nIGdldFVzZXJNZWRpYSBwcm9taXNlJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChraW5kKSB7XG4gICAgICAgICAgICAgIHlpZWxkIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5nZXQoa2luZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAudmFsdWVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpdmVraXRMb2dnZXIud2FybignZXJyb3Igd2FpdGluZyBmb3IgbWVkaWEgcGVybWlzc29ucycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICBpZiAocmVxdWVzdFBlcm1pc3Npb25zICYmXG4gICAgICAgIC8vIGZvciBzYWZhcmkgd2UgbmVlZCB0byBza2lwIHRoaXMgY2hlY2ssIGFzIG90aGVyd2lzZSBpdCB3aWxsIHJlLWFjcXVpcmUgdXNlciBtZWRpYSBhbmQgZmFpbCBvbiBpT1MgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgICAgICAhKGlzU2FmYXJpKCkgJiYgX3RoaXMuaGFzRGV2aWNlSW5Vc2Uoa2luZCkpKSB7XG4gICAgICAgICAgY29uc3QgaXNEdW1teURldmljZU9yRW1wdHkgPSBkZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0ga2luZCkubGVuZ3RoID09PSAwIHx8IGRldmljZXMuc29tZShkZXZpY2UgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XG4gICAgICAgICAgICBjb25zdCBpc1JlbGV2YW50ID0ga2luZCA/IGRldmljZS5raW5kID09PSBraW5kIDogdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBub0xhYmVsICYmIGlzUmVsZXZhbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzRHVtbXlEZXZpY2VPckVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1RvQWNxdWlyZSA9IHtcbiAgICAgICAgICAgICAgdmlkZW86IGtpbmQgIT09ICdhdWRpb2lucHV0JyAmJiBraW5kICE9PSAnYXVkaW9vdXRwdXQnLFxuICAgICAgICAgICAgICBhdWRpbzoga2luZCAhPT0gJ3ZpZGVvaW5wdXQnICYmIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgICAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHBlcm1pc3Npb25zVG9BY3F1aXJlKTtcbiAgICAgICAgICAgIGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9wcmV2aW91c0RldmljZXMgPSBkZXZpY2VzO1xuICAgICAgICBpZiAoa2luZCkge1xuICAgICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkZXZpY2UgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIG5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChkZXZpY2VJZCAhPT0gZGVmYXVsdElkKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VJZDtcbiAgICAgIH1cbiAgICAgIC8vIHJlc29sdmUgYWN0dWFsIGRldmljZSBpZCBpZiBpdCdzICdkZWZhdWx0JzogQ2hyb21lIHJldHVybnMgaXQgd2hlbiBub1xuICAgICAgLy8gZGV2aWNlIGhhcyBiZWVuIGNob3NlblxuICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMuZ2V0RGV2aWNlcyhraW5kKTtcbiAgICAgIGNvbnN0IGRlZmF1bHREZXZpY2UgPSBkZXZpY2VzLmZpbmQoZCA9PiBkLmRldmljZUlkID09PSBkZWZhdWx0SWQpO1xuICAgICAgaWYgKCFkZWZhdWx0RGV2aWNlKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignY291bGQgbm90IHJlbGlhYmx5IGRldGVybWluZSBkZWZhdWx0IGRldmljZScpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKGQgPT4gZC5kZXZpY2VJZCAhPT0gZGVmYXVsdElkICYmIGQuZ3JvdXBJZCA9PT0gKGdyb3VwSWQgIT09IG51bGwgJiYgZ3JvdXBJZCAhPT0gdm9pZCAwID8gZ3JvdXBJZCA6IGRlZmF1bHREZXZpY2UuZ3JvdXBJZCkpO1xuICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdjb3VsZCBub3QgcmVsaWFibHkgZGV0ZXJtaW5lIGRlZmF1bHQgZGV2aWNlJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlID09PSBudWxsIHx8IGRldmljZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2aWNlLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIGhhc0RldmljZUluVXNlKGtpbmQpIHtcbiAgICByZXR1cm4ga2luZCA/IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5oYXMoa2luZCkgOiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2l6ZSA+IDA7XG4gIH1cbn1cbkRldmljZU1hbmFnZXIubWVkaWFEZXZpY2VLaW5kcyA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XG5EZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBRdWV1ZVRhc2tTdGF0dXM7XG4oZnVuY3Rpb24gKFF1ZXVlVGFza1N0YXR1cykge1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiV0FJVElOR1wiXSA9IDBdID0gXCJXQUlUSU5HXCI7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJSVU5OSU5HXCJdID0gMV0gPSBcIlJVTk5JTkdcIjtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IDJdID0gXCJDT01QTEVURURcIjtcbn0pKFF1ZXVlVGFza1N0YXR1cyB8fCAoUXVldWVUYXNrU3RhdHVzID0ge30pKTtcbmNsYXNzIEFzeW5jUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRhc2tNdXRleCA9IG5ldyBfKCk7XG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcbiAgfVxuICBydW4odGFzaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0YXNrSW5mbyA9IHtcbiAgICAgICAgaWQ6IHRoaXMubmV4dFRhc2tJbmRleCsrLFxuICAgICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cy5XQUlUSU5HXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnRhc2tNdXRleC5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgIHJldHVybiB5aWVsZCB0YXNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHt9KSk7XG4gICAgfSk7XG4gIH1cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJ0Y1VybCh1cmwsIHNlYXJjaFBhcmFtcykge1xuICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHRvV2Vic29ja2V0VXJsKHVybCkpO1xuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHVybE9iai5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFwcGVuZFVybFBhdGgodXJsT2JqLCAncnRjJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0ZVVybChydGNXc1VybCkge1xuICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHRvSHR0cFVybChydGNXc1VybCkpO1xuICByZXR1cm4gYXBwZW5kVXJsUGF0aCh1cmxPYmosICd2YWxpZGF0ZScpO1xufVxuZnVuY3Rpb24gZW5zdXJlVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgPyBwYXRoIDogXCJcIi5jb25jYXQocGF0aCwgXCIvXCIpO1xufVxuZnVuY3Rpb24gYXBwZW5kVXJsUGF0aCh1cmxPYmosIHBhdGgpIHtcbiAgdXJsT2JqLnBhdGhuYW1lID0gXCJcIi5jb25jYXQoZW5zdXJlVHJhaWxpbmdTbGFzaCh1cmxPYmoucGF0aG5hbWUpKS5jb25jYXQocGF0aCk7XG4gIHJldHVybiB1cmxPYmoudG9TdHJpbmcoKTtcbn1cblxuY29uc3QgcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMgPSBbJ3N5bmNTdGF0ZScsICd0cmlja2xlJywgJ29mZmVyJywgJ2Fuc3dlcicsICdzaW11bGF0ZScsICdsZWF2ZSddO1xuZnVuY3Rpb24gY2FuUGFzc1Rocm91Z2hRdWV1ZShyZXEpIHtcbiAgY29uc3QgY2FuUGFzcyA9IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzLmluZGV4T2YocmVxLmNhc2UpID49IDA7XG4gIGxpdmVraXRMb2dnZXIudHJhY2UoJ3JlcXVlc3QgYWxsb3dlZCB0byBieXBhc3MgcXVldWU6Jywge1xuICAgIGNhblBhc3MsXG4gICAgcmVxXG4gIH0pO1xuICByZXR1cm4gY2FuUGFzcztcbn1cbnZhciBTaWduYWxDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKFNpZ25hbENvbm5lY3Rpb25TdGF0ZSkge1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDBdID0gXCJDT05ORUNUSU5HXCI7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJDT05ORUNURURcIl0gPSAxXSA9IFwiQ09OTkVDVEVEXCI7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJSRUNPTk5FQ1RJTkdcIl0gPSAyXSA9IFwiUkVDT05ORUNUSU5HXCI7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJESVNDT05ORUNUSU5HXCJdID0gM10gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkRJU0NPTk5FQ1RFRFwiXSA9IDRdID0gXCJESVNDT05ORUNURURcIjtcbn0pKFNpZ25hbENvbm5lY3Rpb25TdGF0ZSB8fCAoU2lnbmFsQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFNpZ25hbENsaWVudCB7XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cbiAgZ2V0IGlzRGlzY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORyB8fCB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICB9XG4gIGdldCBpc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HIHx8IHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gIH1cbiAgZ2V0TmV4dFJlcXVlc3RJZCgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgKz0gMTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdElkO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB1c2VKU09OID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9hO1xuICAgIC8qKiBzaWduYWwgcnR0IGluIG1pbGxpc2Vjb25kcyAqL1xuICAgIHRoaXMucnR0ID0gMDtcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5yZXNldENhbGxiYWNrcyA9ICgpID0+IHtcbiAgICAgIHRoaXMub25BbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTGVhdmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTmVnb3RpYXRlUmVxdWVzdGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbk9mZmVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblRva2VuUmVmcmVzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Ucmlja2xlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkNsb3NlID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5TaWduYWwpO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy51c2VKU09OID0gdXNlSlNPTjtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBBc3luY1F1ZXVlKCk7XG4gICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gIH1cbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBkdXJpbmcgYSBmdWxsIHJlY29ubmVjdCwgd2UnZCB3YW50IHRvIHN0YXJ0IHRoZSBzZXF1ZW5jZSBldmVuIGlmIGN1cnJlbnRseVxuICAgICAgLy8gY29ubmVjdGVkXG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbiAgcmVjb25uZWN0KHVybCwgdG9rZW4sIHNpZCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2F0dGVtcHRlZCB0byByZWNvbm5lY3Qgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBiZWluZyBzZXQsIGlnbm9yaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gICAgICAvLyBjbGVhciBwaW5nIGludGVydmFsIGFuZCByZXN0YXJ0IGl0IG9uY2UgcmVjb25uZWN0ZWRcbiAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHtcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICBzaWQsXG4gICAgICAgIHJlY29ubmVjdFJlYXNvbjogcmVhc29uXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3QodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0cztcbiAgICBjb25zdCBjbGllbnRJbmZvID0gZ2V0Q2xpZW50SW5mbygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXModG9rZW4sIGNsaWVudEluZm8sIG9wdHMpO1xuICAgIGNvbnN0IHJ0Y1VybCA9IGNyZWF0ZVJ0Y1VybCh1cmwsIHBhcmFtcyk7XG4gICAgY29uc3QgdmFsaWRhdGVVcmwgPSBjcmVhdGVWYWxpZGF0ZVVybChydGNVcmwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgKHNpZ25hbCknLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgdGltZWQgb3V0IChzaWduYWwpJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSk7XG4gICAgICAgIH0sIG9wdHMud2Vic29ja2V0VGltZW91dCk7XG4gICAgICAgIGlmIChhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIGNvbnN0IHJlZGFjdGVkVXJsID0gbmV3IFVSTChydGNVcmwpO1xuICAgICAgICBpZiAocmVkYWN0ZWRVcmwuc2VhcmNoUGFyYW1zLmhhcygnYWNjZXNzX3Rva2VuJykpIHtcbiAgICAgICAgICByZWRhY3RlZFVybC5zZWFyY2hQYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCAnPHJlZGFjdGVkPicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiY29ubmVjdGluZyB0byBcIi5jb25jYXQocmVkYWN0ZWRVcmwpLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICByZWNvbm5lY3Q6IG9wdHMucmVjb25uZWN0LFxuICAgICAgICAgIHJlY29ubmVjdFJlYXNvbjogb3B0cy5yZWNvbm5lY3RSZWFzb25cbiAgICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jbG9zZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQocnRjVXJsKTtcbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IGV2ID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCBmZXRjaCh2YWxpZGF0ZVVybCk7XG4gICAgICAgICAgICAgIGlmIChyZXNwLnN0YXR1cy50b0ZpeGVkKDApLnN0YXJ0c1dpdGgoJzQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHlpZWxkIHJlc3AudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKG1zZywgQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQsIHJlc3Auc3RhdHVzKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoXCJFbmNvdW50ZXJlZCB1bmtub3duIHdlYnNvY2tldCBlcnJvciBkdXJpbmcgY29ubmVjdGlvbjogXCIuY29uY2F0KGV2LnRvU3RyaW5nKCkpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvciwgcmVzcC5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnc2VydmVyIHdhcyBub3QgcmVhY2hhYmxlJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyIGVycm9ycywgaGFuZGxlXG4gICAgICAgICAgdGhpcy5oYW5kbGVXU0Vycm9yKGV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gZXYgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgIC8vIG5vdCBjb25zaWRlcmVkIGNvbm5lY3RlZCB1bnRpbCBKb2luUmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgICBsZXQgcmVzcDtcbiAgICAgICAgICBpZiAodHlwZW9mIGV2LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShldi5kYXRhKTtcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tSnNvbihqc29uLCB7XG4gICAgICAgICAgICAgIGlnbm9yZVVua25vd25GaWVsZHM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShldi5kYXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFwiY291bGQgbm90IGRlY29kZSB3ZWJzb2NrZXQgbWVzc2FnZTogXCIuY29uY2F0KHR5cGVvZiBldi5kYXRhKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIGxldCBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGpvaW4gbWVzc2FnZSBvbmx5XG4gICAgICAgICAgICBpZiAoKChfYSA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnam9pbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nVGltZW91dDtcbiAgICAgICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gJiYgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwaW5nIGNvbmZpZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5waW5nVGltZW91dER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHRoaXMucGluZ0ludGVydmFsRHVyYXRpb25cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORyAmJiByZXNwLm1lc3NhZ2UuY2FzZSAhPT0gJ2xlYXZlJykge1xuICAgICAgICAgICAgICAvLyBpbiByZWNvbm5lY3RpbmcsIGFueSBtZXNzYWdlIHJlY2VpdmVkIG1lYW5zIHNpZ25hbCByZWNvbm5lY3RlZFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAncmVjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZGVjbGFyaW5nIHNpZ25hbCByZWNvbm5lY3RlZCB3aXRob3V0IHJlY29ubmVjdCByZXNwb25zZSByZWNlaXZlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHNob3VsZFByb2Nlc3NNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiAmJiByZXNwLm1lc3NhZ2UuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignUmVjZWl2ZWQgbGVhdmUgcmVxdWVzdCB3aGlsZSB0cnlpbmcgdG8gKHJlKWNvbm5lY3QnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0LCB1bmRlZmluZWQsIHJlc3AubWVzc2FnZS52YWx1ZS5yZWFzb24pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdHMucmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgIC8vIG5vbi1yZWNvbm5lY3QgY2FzZSwgc2hvdWxkIHJlY2VpdmUgam9pbiByZXNwb25zZSBmaXJzdFxuICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihcImRpZCBub3QgcmVjZWl2ZSBqb2luIHJlc3BvbnNlLCBnb3QgXCIuY29uY2F0KChfYyA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhc2UsIFwiIGluc3RlYWRcIiksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNob3VsZFByb2Nlc3NNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICAgICAgeWllbGQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTaWduYWxSZXNwb25zZShyZXNwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IGV2ID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdXZWJzb2NrZXQgZ290IGNsb3NlZCBkdXJpbmcgYSAocmUpY29ubmVjdGlvbiBhdHRlbXB0JywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcIndlYnNvY2tldCBjbG9zZWRcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICByZWFzb246IGV2LnJlYXNvbixcbiAgICAgICAgICAgIGNvZGU6IGV2LmNvZGUsXG4gICAgICAgICAgICB3YXNDbGVhbjogZXYud2FzQ2xlYW4sXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoZXYucmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHVwZGF0ZVN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLndzKSB7XG4gICAgICAgICAgICBfdGhpcy53cy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMud3Mub25vcGVuID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLndzLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgLy8gY2FsbGluZyBgd3MuY2xvc2UoKWAgb25seSBzdGFydHMgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIChDTE9TSU5HIHN0YXRlKSwgcHJlZmVyIHRvIHdhaXQgdW50aWwgc3RhdGUgaXMgYWN0dWFsbHkgQ0xPU0VEXG4gICAgICAgICAgICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLndzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMud3MucmVhZHlTdGF0ZSA8IF90aGlzLndzLkNMT1NJTkcpIHtcbiAgICAgICAgICAgICAgX3RoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgLy8gMjUwbXMgZ3JhY2UgcGVyaW9kIGZvciB3cyB0byBjbG9zZSBncmFjZWZ1bGx5XG4gICAgICAgICAgICAgIHlpZWxkIFByb21pc2UucmFjZShbY2xvc2VQcm9taXNlLCBzbGVlcCgyNTApXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gaW5pdGlhbCBvZmZlciBhZnRlciBqb2luaW5nXG4gIHNlbmRPZmZlcihvZmZlcikge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIG9mZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBvZmZlclNkcDogb2ZmZXIuc2RwXG4gICAgfSkpO1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ29mZmVyJyxcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG9mZmVyKVxuICAgIH0pO1xuICB9XG4gIC8vIGFuc3dlciBhIHNlcnZlci1pbml0aWF0ZWQgb2ZmZXJcbiAgc2VuZEFuc3dlcihhbnN3ZXIpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBhbnN3ZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGFuc3dlclNkcDogYW5zd2VyLnNkcFxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYW5zd2VyJyxcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcilcbiAgICB9KTtcbiAgfVxuICBzZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgaWNlIGNhbmRpZGF0ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgY2FuZGlkYXRlXG4gICAgfSkpO1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd0cmlja2xlJyxcbiAgICAgIHZhbHVlOiBuZXcgVHJpY2tsZVJlcXVlc3Qoe1xuICAgICAgICBjYW5kaWRhdGVJbml0OiBKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUpLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnbXV0ZScsXG4gICAgICB2YWx1ZTogbmV3IE11dGVUcmFja1JlcXVlc3Qoe1xuICAgICAgICBzaWQ6IHRyYWNrU2lkLFxuICAgICAgICBtdXRlZFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kQWRkVHJhY2socmVxKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2FkZFRyYWNrJyxcbiAgICAgIHZhbHVlOiByZXFcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YV8xLCBuYW1lXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAobWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IF90aGlzMi5nZXROZXh0UmVxdWVzdElkKCk7XG4gICAgICAgIHlpZWxkIF90aGlzMi5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgY2FzZTogJ3VwZGF0ZU1ldGFkYXRhJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoe1xuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVxdWVzdElkO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndHJhY2tTZXR0aW5nJyxcbiAgICAgIHZhbHVlOiBzZXR0aW5nc1xuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvbicsXG4gICAgICB2YWx1ZTogc3ViXG4gICAgfSk7XG4gIH1cbiAgc2VuZFN5bmNTdGF0ZShzeW5jKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N5bmNTdGF0ZScsXG4gICAgICB2YWx1ZTogc3luY1xuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVWaWRlb0xheWVycyh0cmFja1NpZCwgbGF5ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3VwZGF0ZUxheWVycycsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKHtcbiAgICAgICAgdHJhY2tTaWQsXG4gICAgICAgIGxheWVyc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoYWxsUGFydGljaXBhbnRzLCB0cmFja1Blcm1pc3Npb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvblBlcm1pc3Npb24nLFxuICAgICAgdmFsdWU6IG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKHtcbiAgICAgICAgYWxsUGFydGljaXBhbnRzLFxuICAgICAgICB0cmFja1Blcm1pc3Npb25zXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRTaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3NpbXVsYXRlJyxcbiAgICAgIHZhbHVlOiBzY2VuYXJpb1xuICAgIH0pO1xuICB9XG4gIHNlbmRQaW5nKCkge1xuICAgIC8qKiBzZW5kIGJvdGggb2YgcGluZyBhbmQgcGluZ1JlcSBmb3IgY29tcGF0aWJpbGl0eSB0byBvbGQgYW5kIG5ldyBzZXJ2ZXIgKi9cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3BpbmcnLFxuICAgICAgdmFsdWU6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcbiAgICB9KSwgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAncGluZ1JlcScsXG4gICAgICB2YWx1ZTogbmV3IFBpbmcoe1xuICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICAgIHJ0dDogcHJvdG9JbnQ2NC5wYXJzZSh0aGlzLnJ0dClcbiAgICAgIH0pXG4gICAgfSldKTtcbiAgfVxuICBzZW5kVXBkYXRlTG9jYWxBdWRpb1RyYWNrKHRyYWNrU2lkLCBmZWF0dXJlcykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVBdWRpb1RyYWNrJyxcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlTG9jYWxBdWRpb1RyYWNrKHtcbiAgICAgICAgdHJhY2tTaWQsXG4gICAgICAgIGZlYXR1cmVzXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRMZWF2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnbGVhdmUnLFxuICAgICAgdmFsdWU6IG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICByZWFzb246IERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCxcbiAgICAgICAgLy8gc2VydmVyIGRvZXNuJ3QgcHJvY2VzcyB0aGlzIGZpZWxkLCBrZWVwaW5nIGl0IGhlcmUgdG8gaW5kaWNhdGUgdGhlIGludGVudCBvZiBhIGZ1bGwgZGlzY29ubmVjdFxuICAgICAgICBhY3Rpb246IExlYXZlUmVxdWVzdF9BY3Rpb24uRElTQ09OTkVDVFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kUmVxdWVzdChtZXNzYWdlXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBsZXQgZnJvbVF1ZXVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBjYXB0dXJlIGFsbCByZXF1ZXN0cyB3aGlsZSByZWNvbm5lY3RpbmcgYW5kIHB1dCB0aGVtIGluIGEgcXVldWVcbiAgICAgICAgLy8gdW5sZXNzIHRoZSByZXF1ZXN0IG9yaWdpbmF0ZXMgZnJvbSB0aGUgcXVldWUsIHRoZW4gZG9uJ3QgZW5xdWV1ZSBhZ2FpblxuICAgICAgICBjb25zdCBjYW5RdWV1ZSA9ICFmcm9tUXVldWUgJiYgIWNhblBhc3NUaHJvdWdoUXVldWUobWVzc2FnZSk7XG4gICAgICAgIGlmIChjYW5RdWV1ZSAmJiBfdGhpczMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICBfdGhpczMucXVldWVkUmVxdWVzdHMucHVzaCgoKSA9PiBfX2F3YWl0ZXIoX3RoaXMzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZFJlcXVlc3QobWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHN1cmUgcHJldmlvdXNseSBxdWV1ZWQgcmVxdWVzdHMgYXJlIGJlaW5nIHNlbnQgZmlyc3RcbiAgICAgICAgaWYgKCFmcm9tUXVldWUpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczMucmVxdWVzdFF1ZXVlLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMy5zaWduYWxMYXRlbmN5KSB7XG4gICAgICAgICAgeWllbGQgc2xlZXAoX3RoaXMzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXMzLndzIHx8IF90aGlzMy53cy5yZWFkeVN0YXRlICE9PSBfdGhpczMud3MuT1BFTikge1xuICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoXCJjYW5ub3Qgc2VuZCBzaWduYWwgcmVxdWVzdCBiZWZvcmUgY29ubmVjdGVkLCB0eXBlOiBcIi5jb25jYXQobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLmNhc2UpLCBfdGhpczMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBTaWduYWxSZXF1ZXN0KHtcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfdGhpczMudXNlSlNPTikge1xuICAgICAgICAgICAgX3RoaXMzLndzLnNlbmQocmVxLnRvSnNvblN0cmluZygpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMzLndzLnNlbmQocmVxLnRvQmluYXJ5KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoJ2Vycm9yIHNlbmRpbmcgc2lnbmFsIG1lc3NhZ2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVTaWduYWxSZXNwb25zZShyZXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IG1zZyA9IHJlcy5tZXNzYWdlO1xuICAgIGlmIChtc2cgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdW5zdXBwb3J0ZWQgbWVzc2FnZScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwaW5nSGFuZGxlZCA9IGZhbHNlO1xuICAgIGlmIChtc2cuY2FzZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5vbkFuc3dlcikge1xuICAgICAgICB0aGlzLm9uQW5zd2VyKHNkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnb2ZmZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25PZmZlcikge1xuICAgICAgICB0aGlzLm9uT2ZmZXIoc2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmlja2xlJykge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gSlNPTi5wYXJzZShtc2cudmFsdWUuY2FuZGlkYXRlSW5pdCk7XG4gICAgICBpZiAodGhpcy5vblRyaWNrbGUpIHtcbiAgICAgICAgdGhpcy5vblRyaWNrbGUoY2FuZGlkYXRlLCBtc2cudmFsdWUudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uUGFydGljaXBhbnRVcGRhdGUoKF9hID0gbXNnLnZhbHVlLnBhcnRpY2lwYW50cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1B1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCkge1xuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzcGVha2Vyc0NoYW5nZWQnKSB7XG4gICAgICBpZiAodGhpcy5vblNwZWFrZXJzQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKChfYiA9IG1zZy52YWx1ZS5zcGVha2VycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdsZWF2ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uTGVhdmUpIHtcbiAgICAgICAgdGhpcy5vbkxlYXZlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ211dGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZChtc2cudmFsdWUuc2lkLCBtc2cudmFsdWUubXV0ZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyb29tVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25Sb29tVXBkYXRlICYmIG1zZy52YWx1ZS5yb29tKSB7XG4gICAgICAgIHRoaXMub25Sb29tVXBkYXRlKG1zZy52YWx1ZS5yb29tKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnY29ubmVjdGlvblF1YWxpdHknKSB7XG4gICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uUXVhbGl0eShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdHJlYW1TdGF0ZVVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmliZWRRdWFsaXR5VXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZWZyZXNoVG9rZW4nKSB7XG4gICAgICBpZiAodGhpcy5vblRva2VuUmVmcmVzaCkge1xuICAgICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrVW5wdWJsaXNoZWQnKSB7XG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkge1xuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmlwdGlvblJlc3BvbnNlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICB0aGlzLm9uU3Vic2NyaXB0aW9uRXJyb3IobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncG9uZycpIDsgZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nUmVzcCcpIHtcbiAgICAgIHRoaXMucnR0ID0gRGF0ZS5ub3coKSAtIE51bWJlci5wYXJzZUludChtc2cudmFsdWUubGFzdFBpbmdUaW1lc3RhbXAudG9TdHJpbmcoKSk7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgIHBpbmdIYW5kbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncmVxdWVzdFJlc3BvbnNlJykge1xuICAgICAgaWYgKHRoaXMub25SZXF1ZXN0UmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5vblJlcXVlc3RSZXNwb25zZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1N1YnNjcmliZWQnKSB7XG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrU3Vic2NyaWJlZChtc2cudmFsdWUudHJhY2tTaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5zdXBwb3J0ZWQgbWVzc2FnZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBtc2dDYXNlOiBtc2cuY2FzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXBpbmdIYW5kbGVkKSB7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gIH1cbiAgc2V0UmVjb25uZWN0ZWQoKSB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxID0gdGhpcy5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlT25DbG9zZShyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpIHJldHVybjtcbiAgICAgIGNvbnN0IG9uQ2xvc2VDYWxsYmFjayA9IHRoaXMub25DbG9zZTtcbiAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwid2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkOiBcIi5jb25jYXQocmVhc29uKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSkpO1xuICAgICAgaWYgKG9uQ2xvc2VDYWxsYmFjaykge1xuICAgICAgICBvbkNsb3NlQ2FsbGJhY2socmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVXU0Vycm9yKGV2KSB7XG4gICAgdGhpcy5sb2cuZXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgZXJyb3I6IGV2XG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBpbmcgdGltZW91dCBhbmQgc3RhcnRzIGEgbmV3IHRpbWVvdXQuXG4gICAqIENhbGwgdGhpcyBhZnRlciByZWNlaXZpbmcgYSBwb25nIG1lc3NhZ2VcbiAgICovXG4gIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgdGltZW91dCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5waW5nVGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybihcInBpbmcgdGltZW91dCB0cmlnZ2VyZWQuIGxhc3QgcG9uZyByZWNlaXZlZCBhdDogXCIuY29uY2F0KG5ldyBEYXRlKERhdGUubm93KCkgLSB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKS50b1VUQ1N0cmluZygpKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuaGFuZGxlT25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gICAgfSwgdGhpcy5waW5nVGltZW91dER1cmF0aW9uICogMTAwMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBwaW5nIHRpbWVvdXQgKGRvZXMgbm90IHN0YXJ0IGEgbmV3IHRpbWVvdXQpXG4gICAqL1xuICBjbGVhclBpbmdUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0KSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0UGluZ0ludGVydmFsKCkge1xuICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ0ludGVydmFsRHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgaW50ZXJ2YWwgZHVyYXRpb24gbm90IHNldCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydCBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IENyaXRpY2FsVGltZXJzLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc2VuZFBpbmcoKTtcbiAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uICogMTAwMCk7XG4gIH1cbiAgY2xlYXJQaW5nSW50ZXJ2YWwoKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ2NsZWFyaW5nIHBpbmcgaW50ZXJ2YWwnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMuY2xlYXJQaW5nVGltZW91dCgpO1xuICAgIGlmICh0aGlzLnBpbmdJbnRlcnZhbCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnBpbmdJbnRlcnZhbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oc2QpIHtcbiAgY29uc3QgcnNkID0ge1xuICAgIHR5cGU6ICdvZmZlcicsXG4gICAgc2RwOiBzZC5zZHBcbiAgfTtcbiAgc3dpdGNoIChzZC50eXBlKSB7XG4gICAgY2FzZSAnYW5zd2VyJzpcbiAgICBjYXNlICdvZmZlcic6XG4gICAgY2FzZSAncHJhbnN3ZXInOlxuICAgIGNhc2UgJ3JvbGxiYWNrJzpcbiAgICAgIHJzZC50eXBlID0gc2QudHlwZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByc2Q7XG59XG5mdW5jdGlvbiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHJzZCkge1xuICBjb25zdCBzZCA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgIHNkcDogcnNkLnNkcCxcbiAgICB0eXBlOiByc2QudHlwZVxuICB9KTtcbiAgcmV0dXJuIHNkO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgaW5mbywgb3B0cykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgcGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgdG9rZW4pO1xuICAvLyBvcHRzXG4gIGlmIChvcHRzLnJlY29ubmVjdCkge1xuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdCcsICcxJyk7XG4gICAgaWYgKG9wdHMuc2lkKSB7XG4gICAgICBwYXJhbXMuc2V0KCdzaWQnLCBvcHRzLnNpZCk7XG4gICAgfVxuICB9XG4gIHBhcmFtcy5zZXQoJ2F1dG9fc3Vic2NyaWJlJywgb3B0cy5hdXRvU3Vic2NyaWJlID8gJzEnIDogJzAnKTtcbiAgLy8gQ2xpZW50SW5mb1xuICBwYXJhbXMuc2V0KCdzZGsnLCBpc1JlYWN0TmF0aXZlKCkgPyAncmVhY3RuYXRpdmUnIDogJ2pzJyk7XG4gIHBhcmFtcy5zZXQoJ3ZlcnNpb24nLCBpbmZvLnZlcnNpb24pO1xuICBwYXJhbXMuc2V0KCdwcm90b2NvbCcsIGluZm8ucHJvdG9jb2wudG9TdHJpbmcoKSk7XG4gIGlmIChpbmZvLmRldmljZU1vZGVsKSB7XG4gICAgcGFyYW1zLnNldCgnZGV2aWNlX21vZGVsJywgaW5mby5kZXZpY2VNb2RlbCk7XG4gIH1cbiAgaWYgKGluZm8ub3MpIHtcbiAgICBwYXJhbXMuc2V0KCdvcycsIGluZm8ub3MpO1xuICB9XG4gIGlmIChpbmZvLm9zVmVyc2lvbikge1xuICAgIHBhcmFtcy5zZXQoJ29zX3ZlcnNpb24nLCBpbmZvLm9zVmVyc2lvbik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3Nlcikge1xuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXInLCBpbmZvLmJyb3dzZXIpO1xuICB9XG4gIGlmIChpbmZvLmJyb3dzZXJWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3Nlcl92ZXJzaW9uJywgaW5mby5icm93c2VyVmVyc2lvbik7XG4gIH1cbiAgaWYgKG9wdHMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICBwYXJhbXMuc2V0KCdhZGFwdGl2ZV9zdHJlYW0nLCAnMScpO1xuICB9XG4gIGlmIChvcHRzLnJlY29ubmVjdFJlYXNvbikge1xuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdF9yZWFzb24nLCBvcHRzLnJlY29ubmVjdFJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIGlmICgoX2EgPSBuYXZpZ2F0b3IuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGFyYW1zLnNldCgnbmV0d29yaycsIG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbnZhciBsaWIgPSB7fTtcblxudmFyIHBhcnNlciA9IHt9O1xuXG52YXIgZ3JhbW1hciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoYXNSZXF1aXJlZEdyYW1tYXI7XG5mdW5jdGlvbiByZXF1aXJlR3JhbW1hcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkR3JhbW1hcikgcmV0dXJuIGdyYW1tYXIuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRHcmFtbWFyID0gMTtcbiAgdmFyIGdyYW1tYXIkMSA9IGdyYW1tYXIuZXhwb3J0cyA9IHtcbiAgICB2OiBbe1xuICAgICAgbmFtZTogJ3ZlcnNpb24nLFxuICAgICAgcmVnOiAvXihcXGQqKSQvXG4gICAgfV0sXG4gICAgbzogW3tcbiAgICAgIC8vIG89LSAyMDUxOCAwIElOIElQNCAyMDMuMC4xMTMuMVxuICAgICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXG4gICAgICBuYW1lOiAnb3JpZ2luJyxcbiAgICAgIHJlZzogL14oXFxTKikgKFxcZCopIChcXGQqKSAoXFxTKikgSVAoXFxkKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiAnJXMgJXMgJWQgJXMgSVAlZCAlcydcbiAgICB9XSxcbiAgICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcbiAgICBzOiBbe1xuICAgICAgbmFtZTogJ25hbWUnXG4gICAgfV0sXG4gICAgaTogW3tcbiAgICAgIG5hbWU6ICdkZXNjcmlwdGlvbidcbiAgICB9XSxcbiAgICB1OiBbe1xuICAgICAgbmFtZTogJ3VyaSdcbiAgICB9XSxcbiAgICBlOiBbe1xuICAgICAgbmFtZTogJ2VtYWlsJ1xuICAgIH1dLFxuICAgIHA6IFt7XG4gICAgICBuYW1lOiAncGhvbmUnXG4gICAgfV0sXG4gICAgejogW3tcbiAgICAgIG5hbWU6ICd0aW1lem9uZXMnXG4gICAgfV0sXG4gICAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFjdHVhbGx5IGJlIHBhcnNlZCBwcm9wZXJseS4uLlxuICAgIHI6IFt7XG4gICAgICBuYW1lOiAncmVwZWF0cydcbiAgICB9XSxcbiAgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWxzbyBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyBrOiBbe31dLCAvLyBvdXRkYXRlZCB0aGluZyBpZ25vcmVkXG4gICAgdDogW3tcbiAgICAgIC8vIHQ9MCAwXG4gICAgICBuYW1lOiAndGltaW5nJyxcbiAgICAgIHJlZzogL14oXFxkKikgKFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3N0YXJ0JywgJ3N0b3AnXSxcbiAgICAgIGZvcm1hdDogJyVkICVkJ1xuICAgIH1dLFxuICAgIGM6IFt7XG4gICAgICAvLyBjPUlOIElQNCAxMC40Ny4xOTcuMjZcbiAgICAgIG5hbWU6ICdjb25uZWN0aW9uJyxcbiAgICAgIHJlZzogL15JTiBJUChcXGQpIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd2ZXJzaW9uJywgJ2lwJ10sXG4gICAgICBmb3JtYXQ6ICdJTiBJUCVkICVzJ1xuICAgIH1dLFxuICAgIGI6IFt7XG4gICAgICAvLyBiPUFTOjQwMDBcbiAgICAgIHB1c2g6ICdiYW5kd2lkdGgnLFxuICAgICAgcmVnOiAvXihUSUFTfEFTfENUfFJSfFJTKTooXFxkKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdsaW1pdCddLFxuICAgICAgZm9ybWF0OiAnJXM6JXMnXG4gICAgfV0sXG4gICAgbTogW3tcbiAgICAgIC8vIG09dmlkZW8gNTE3NDQgUlRQL0FWUCAxMjYgOTcgOTggMzQgMzFcbiAgICAgIC8vIE5COiBzcGVjaWFsIC0gcHVzaGVzIHRvIHNlc3Npb25cbiAgICAgIC8vIFRPRE86IHJ0cC9mbXRwIHNob3VsZCBiZSBmaWx0ZXJlZCBieSB0aGUgcGF5bG9hZHMgZm91bmQgaGVyZT9cbiAgICAgIHJlZzogL14oXFx3KikgKFxcZCopIChbXFx3L10qKSg/OiAoLiopKT8vLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXG4gICAgICBmb3JtYXQ6ICclcyAlZCAlcyAlcydcbiAgICB9XSxcbiAgICBhOiBbe1xuICAgICAgLy8gYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgICAgcHVzaDogJ3J0cCcsXG4gICAgICByZWc6IC9ecnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLmVuY29kaW5nID8gJ3J0cG1hcDolZCAlcy8lcy8lcycgOiBvLnJhdGUgPyAncnRwbWFwOiVkICVzLyVzJyA6ICdydHBtYXA6JWQgJXMnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9Zm10cDoxMDggcHJvZmlsZS1sZXZlbC1pZD0yNDtvYmplY3Q9MjM7Yml0cmF0ZT02NDAwMFxuICAgICAgLy8gYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgICAgIHB1c2g6ICdmbXRwJyxcbiAgICAgIHJlZzogL15mbXRwOihcXGQqKSAoW1xcU3wgXSopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6ICdmbXRwOiVkICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Y29udHJvbDpzdHJlYW1pZD0wXG4gICAgICBuYW1lOiAnY29udHJvbCcsXG4gICAgICByZWc6IC9eY29udHJvbDooLiopLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRyb2w6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1ydGNwOjY1MTc5IElOIElQNCAxOTMuODQuNzcuMTk0XG4gICAgICBuYW1lOiAncnRjcCcsXG4gICAgICByZWc6IC9ecnRjcDooXFxkKikoPzogKFxcUyopIElQKFxcZCkgKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsncG9ydCcsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uYWRkcmVzcyAhPSBudWxsID8gJ3J0Y3A6JWQgJXMgSVAlZCAlcycgOiAncnRjcDolZCc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IHRyci1pbnQgMTAwXG4gICAgICBwdXNoOiAncnRjcEZiVHJySW50JyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgdHJyLWludCAoXFxkKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAncnRjcC1mYjolcyB0cnItaW50ICVkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICAgIHB1c2g6ICdydGNwRmInLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3R5cGUnLCAnc3VidHlwZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5zdWJ0eXBlICE9IG51bGwgPyAncnRjcC1mYjolcyAlcyAlcycgOiAncnRjcC1mYjolcyAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgICAvLyBhPWV4dG1hcDoxL3JlY3Zvbmx5IFVSSS1ncHMtc3RyaW5nXG4gICAgICAvLyBhPWV4dG1hcDozIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c21wdGUtdGMgMjVANjAwLzI0XG4gICAgICBwdXNoOiAnZXh0JyxcbiAgICAgIHJlZzogL15leHRtYXA6KFxcZCspKD86XFwvKFxcdyspKT8oPzogKHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQpKT8gKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJywgJ2RpcmVjdGlvbicsICdlbmNyeXB0LXVyaScsICd1cmknLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnZXh0bWFwOiVkJyArIChvLmRpcmVjdGlvbiA/ICcvJXMnIDogJyV2JykgKyAob1snZW5jcnlwdC11cmknXSA/ICcgJXMnIDogJyV2JykgKyAnICVzJyArIChvLmNvbmZpZyA/ICcgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9ZXh0bWFwLWFsbG93LW1peGVkXG4gICAgICBuYW1lOiAnZXh0bWFwQWxsb3dNaXhlZCcsXG4gICAgICByZWc6IC9eKGV4dG1hcC1hbGxvdy1taXhlZCkvXG4gICAgfSwge1xuICAgICAgLy8gYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcbiAgICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgICAgcmVnOiAvXmNyeXB0bzooXFxkKikgKFtcXHdfXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5zZXNzaW9uQ29uZmlnICE9IG51bGwgPyAnY3J5cHRvOiVkICVzICVzICVzJyA6ICdjcnlwdG86JWQgJXMgJXMnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9c2V0dXA6YWN0cGFzc1xuICAgICAgbmFtZTogJ3NldHVwJyxcbiAgICAgIHJlZzogL15zZXR1cDooXFx3KikvLFxuICAgICAgZm9ybWF0OiAnc2V0dXA6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb25uZWN0aW9uOm5ld1xuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25UeXBlJyxcbiAgICAgIHJlZzogL15jb25uZWN0aW9uOihuZXd8ZXhpc3RpbmcpLyxcbiAgICAgIGZvcm1hdDogJ2Nvbm5lY3Rpb246JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1taWQ6MVxuICAgICAgbmFtZTogJ21pZCcsXG4gICAgICByZWc6IC9ebWlkOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICdtaWQ6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1tc2lkOjBjOGIwNjRkLWQ4MDctNDNiNC1iNDM0LWY5MmE4ODlkODU4NyA5ODE3ODY4NS1kNDA5LTQ2ZTAtOGUxNi03ZWYwZGIwZGI2NGFcbiAgICAgIG5hbWU6ICdtc2lkJyxcbiAgICAgIHJlZzogL15tc2lkOiguKikvLFxuICAgICAgZm9ybWF0OiAnbXNpZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXB0aW1lOjIwXG4gICAgICBuYW1lOiAncHRpbWUnLFxuICAgICAgcmVnOiAvXnB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdwdGltZTolZCdcbiAgICB9LCB7XG4gICAgICAvLyBhPW1heHB0aW1lOjYwXG4gICAgICBuYW1lOiAnbWF4cHRpbWUnLFxuICAgICAgcmVnOiAvXm1heHB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdtYXhwdGltZTolZCdcbiAgICB9LCB7XG4gICAgICAvLyBhPXNlbmRyZWN2XG4gICAgICBuYW1lOiAnZGlyZWN0aW9uJyxcbiAgICAgIHJlZzogL14oc2VuZHJlY3Z8cmVjdm9ubHl8c2VuZG9ubHl8aW5hY3RpdmUpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9aWNlLWxpdGVcbiAgICAgIG5hbWU6ICdpY2VsaXRlJyxcbiAgICAgIHJlZzogL14oaWNlLWxpdGUpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9aWNlLXVmcmFnOkY3Z0lcbiAgICAgIG5hbWU6ICdpY2VVZnJhZycsXG4gICAgICByZWc6IC9eaWNlLXVmcmFnOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtdWZyYWc6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2UtcHdkOng5Y21sL1l6aWNoVjIrWGxoaU11OGdcbiAgICAgIG5hbWU6ICdpY2VQd2QnLFxuICAgICAgcmVnOiAvXmljZS1wd2Q6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1wd2Q6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1maW5nZXJwcmludDpTSEEtMSAwMDoxMToyMjozMzo0NDo1NTo2Njo3Nzo4ODo5OTpBQTpCQjpDQzpERDpFRTpGRjowMDoxMToyMjozM1xuICAgICAgbmFtZTogJ2ZpbmdlcnByaW50JyxcbiAgICAgIHJlZzogL15maW5nZXJwcmludDooXFxTKikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnaGFzaCddLFxuICAgICAgZm9ybWF0OiAnZmluZ2VycHJpbnQ6JXMgJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jYW5kaWRhdGU6MCAxIFVEUCAyMTEzNjY3MzI3IDIwMy4wLjExMy4xIDU0NDAwIHR5cCBob3N0XG4gICAgICAvLyBhPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjIyOTgxNTYyMCAxIHRjcCAxNTE4MjgwNDQ3IDE5Mi4xNjguMTUwLjE5IDYwMDE3IHR5cCBob3N0IHRjcHR5cGUgYWN0aXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIHB1c2g6ICdjYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15jYW5kaWRhdGU6KFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgdHlwIChcXFMqKSg/OiByYWRkciAoXFxTKikgcnBvcnQgKFxcZCopKT8oPzogdGNwdHlwZSAoXFxTKikpPyg/OiBnZW5lcmF0aW9uIChcXGQqKSk/KD86IG5ldHdvcmstaWQgKFxcZCopKT8oPzogbmV0d29yay1jb3N0IChcXGQqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2ZvdW5kYXRpb24nLCAnY29tcG9uZW50JywgJ3RyYW5zcG9ydCcsICdwcmlvcml0eScsICdpcCcsICdwb3J0JywgJ3R5cGUnLCAncmFkZHInLCAncnBvcnQnLCAndGNwdHlwZScsICdnZW5lcmF0aW9uJywgJ25ldHdvcmstaWQnLCAnbmV0d29yay1jb3N0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnY2FuZGlkYXRlOiVzICVkICVzICVkICVzICVkIHR5cCAlcyc7XG4gICAgICAgIHN0ciArPSBvLnJhZGRyICE9IG51bGwgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcblxuICAgICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBzdHIgKz0gby50Y3B0eXBlICE9IG51bGwgPyAnIHRjcHR5cGUgJXMnIDogJyV2JztcbiAgICAgICAgaWYgKG8uZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IG9bJ25ldHdvcmstaWQnXSAhPSBudWxsID8gJyBuZXR3b3JrLWlkICVkJyA6ICcldic7XG4gICAgICAgIHN0ciArPSBvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWVuZC1vZi1jYW5kaWRhdGVzIChrZWVwIGFmdGVyIHRoZSBjYW5kaWRhdGVzIGxpbmUgZm9yIHJlYWRhYmlsaXR5KVxuICAgICAgbmFtZTogJ2VuZE9mQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cbiAgICB9LCB7XG4gICAgICAvLyBhPXJlbW90ZS1jYW5kaWRhdGVzOjEgMjAzLjAuMTEzLjEgNTQ0MDAgMiAyMDMuMC4xMTMuMSA1NDQwMSAuLi5cbiAgICAgIG5hbWU6ICdyZW1vdGVDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15yZW1vdGUtY2FuZGlkYXRlczooLiopLyxcbiAgICAgIGZvcm1hdDogJ3JlbW90ZS1jYW5kaWRhdGVzOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9aWNlLW9wdGlvbnM6Z29vZ2xlLWljZVxuICAgICAgbmFtZTogJ2ljZU9wdGlvbnMnLFxuICAgICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2Utb3B0aW9uczolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXG4gICAgICBwdXNoOiAnc3NyY3MnLFxuICAgICAgcmVnOiAvXnNzcmM6KFxcZCopIChbXFx3Xy1dKikoPzo6KC4qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ3NzcmM6JWQnO1xuICAgICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnICVzJztcbiAgICAgICAgICBpZiAoby52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJzolcyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQyAxIDJcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMtRlIgMzAwNDM2NDE5NSAxMDgwNzcyMjQxXG4gICAgICBwdXNoOiAnc3NyY0dyb3VwcycsXG4gICAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxuICAgICAgcmVnOiAvXnNzcmMtZ3JvdXA6KFtcXHgyMVxceDIzXFx4MjRcXHgyNVxceDI2XFx4MjdcXHgyQVxceDJCXFx4MkRcXHgyRVxcd10qKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljcycsICdzc3JjcyddLFxuICAgICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPW1zaWQtc2VtYW50aWM6IFdNUyBKdmxhbTVYM1NYMU9QNnBuMjB6V29ndmFLSno1SGpmOU9ubFZcbiAgICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgICAgcmVnOiAvXm1zaWQtc2VtYW50aWM6XFxzPyhcXHcqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWMnLCAndG9rZW4nXSxcbiAgICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgICB9LCB7XG4gICAgICAvLyBhPWdyb3VwOkJVTkRMRSBhdWRpbyB2aWRlb1xuICAgICAgcHVzaDogJ2dyb3VwcycsXG4gICAgICByZWc6IC9eZ3JvdXA6KFxcdyopICguKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdtaWRzJ10sXG4gICAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3AtbXV4XG4gICAgICBuYW1lOiAncnRjcE11eCcsXG4gICAgICByZWc6IC9eKHJ0Y3AtbXV4KS9cbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3AtcnNpemVcbiAgICAgIG5hbWU6ICdydGNwUnNpemUnLFxuICAgICAgcmVnOiAvXihydGNwLXJzaXplKS9cbiAgICB9LCB7XG4gICAgICAvLyBhPXNjdHBtYXA6NTAwMCB3ZWJydGMtZGF0YWNoYW5uZWwgMTAyNFxuICAgICAgbmFtZTogJ3NjdHBtYXAnLFxuICAgICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnc2N0cG1hcE51bWJlcicsICdhcHAnLCAnbWF4TWVzc2FnZVNpemUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbCA/ICdzY3RwbWFwOiVzICVzICVzJyA6ICdzY3RwbWFwOiVzICVzJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxuICAgICAgbmFtZTogJ3hHb29nbGVGbGFnJyxcbiAgICAgIHJlZzogL154LWdvb2dsZS1mbGFnOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cmlkOjEgc2VuZCBtYXgtd2lkdGg9MTI4MDttYXgtaGVpZ2h0PTcyMDttYXgtZnBzPTMwO2RlcGVuZD0wXG4gICAgICBwdXNoOiAncmlkcycsXG4gICAgICByZWc6IC9ecmlkOihbXFxkXFx3XSspIChcXHcrKSg/OiAoW1xcU3wgXSopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnZGlyZWN0aW9uJywgJ3BhcmFtcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5wYXJhbXMgPyAncmlkOiVzICVzICVzJyA6ICdyaWQ6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3IHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF0gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAvLyBhPWltYWdlYXR0cjoqIHNlbmQgW3g9ODAwLHk9NjQwXSByZWN2ICpcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cbiAgICAgIHB1c2g6ICdpbWFnZWF0dHJzJyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3XG4gICAgICAnXmltYWdlYXR0cjooXFxcXGQrfFxcXFwqKScgK1xuICAgICAgLy8gc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXVxuICAgICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgICAvLyByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgICcoPzpbXFxcXHNcXFxcdF0rKHJlY3Z8c2VuZClbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKSk/JyksXG4gICAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ2ltYWdlYXR0cjolcyAlcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1zaW11bGNhc3Q6c2VuZCAxLDIsMzt+NCx+NSByZWN2IDY7fjcsfjhcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3QnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgLy8gYT1zaW11bGNhc3Q6XG4gICAgICAnXnNpbXVsY2FzdDonICtcbiAgICAgIC8vIHNlbmQgMSwyLDM7fjQsfjVcbiAgICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xuICAgICAgLy8gc3BhY2UgKyByZWN2IDY7fjcsfjhcbiAgICAgICcoPzpcXFxccz8oc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKSk/JyArXG4gICAgICAvLyBlbmRcbiAgICAgICckJyksXG4gICAgICBuYW1lczogWydkaXIxJywgJ2xpc3QxJywgJ2RpcjInLCAnbGlzdDInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdzaW11bGNhc3Q6JXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIG9sZCBzaW11bGNhc3QgZHJhZnQgMDMgKGltcGxlbWVudGVkIGJ5IEZpcmVmb3gpXG4gICAgICAvLyAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zZHAtc2ltdWxjYXN0LTAzXG4gICAgICAvLyBhPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XG4gICAgICAvLyBhPXNpbXVsY2FzdDogc2VuZCByaWQ9NTs2OzcgcGF1c2VkPTYsN1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdF8wMycsXG4gICAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3NpbXVsY2FzdDogJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1mcmFtZXJhdGU6MjVcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI5Ljk3XG4gICAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICAgIHJlZzogL15mcmFtZXJhdGU6KFxcZCsoPzokfFxcLlxcZCspKS8sXG4gICAgICBmb3JtYXQ6ICdmcmFtZXJhdGU6JXMnXG4gICAgfSwge1xuICAgICAgLy8gUkZDNDU3MFxuICAgICAgLy8gYT1zb3VyY2UtZmlsdGVyOiBpbmNsIElOIElQNCAyMzkuNS4yLjMxIDEwLjEuMTUuNVxuICAgICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXG4gICAgICByZWc6IC9ec291cmNlLWZpbHRlcjogKihleGNsfGluY2wpIChcXFMqKSAoSVA0fElQNnxcXCopIChcXFMqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ2ZpbHRlck1vZGUnLCAnbmV0VHlwZScsICdhZGRyZXNzVHlwZXMnLCAnZGVzdEFkZHJlc3MnLCAnc3JjTGlzdCddLFxuICAgICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1idW5kbGUtb25seVxuICAgICAgbmFtZTogJ2J1bmRsZU9ubHknLFxuICAgICAgcmVnOiAvXihidW5kbGUtb25seSkvXG4gICAgfSwge1xuICAgICAgLy8gYT1sYWJlbDoxXG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgcmVnOiAvXmxhYmVsOiguKykvLFxuICAgICAgZm9ybWF0OiAnbGFiZWw6JXMnXG4gICAgfSwge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XG4gICAgICBuYW1lOiAnc2N0cFBvcnQnLFxuICAgICAgcmVnOiAvXnNjdHAtcG9ydDooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTZcbiAgICAgIG5hbWU6ICdtYXhNZXNzYWdlU2l6ZScsXG4gICAgICByZWc6IC9ebWF4LW1lc3NhZ2Utc2l6ZTooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ21heC1tZXNzYWdlLXNpemU6JXMnXG4gICAgfSwge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcbiAgICAgIHB1c2g6ICd0c1JlZkNsb2NrcycsXG4gICAgICByZWc6IC9edHMtcmVmY2xrOihbXlxccz1dKikoPzo9KFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3RzLXJlZmNsazolcycgKyAoby5jbGtzcmNFeHQgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9bWVkaWFjbGs6ZGlyZWN0PTk2MzIxNDQyNFxuICAgICAgbmFtZTogJ21lZGlhQ2xrJyxcbiAgICAgIHJlZzogL15tZWRpYWNsazooPzppZD0oXFxTKikpPyAqKFteXFxzPV0qKSg/Oj0oXFxTKikpPyg/OiAqcmF0ZT0oXFxkKylcXC8oXFxkKykpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdtZWRpYWNsazonO1xuICAgICAgICBzdHIgKz0gby5pZCAhPSBudWxsID8gJ2lkPSVzICVzJyA6ICcldiVzJztcbiAgICAgICAgc3RyICs9IG8ubWVkaWFDbG9ja1ZhbHVlICE9IG51bGwgPyAnPSVzJyA6ICcnO1xuICAgICAgICBzdHIgKz0gby5yYXRlTnVtZXJhdG9yICE9IG51bGwgPyAnIHJhdGU9JXMnIDogJyc7XG4gICAgICAgIHN0ciArPSBvLnJhdGVEZW5vbWluYXRvciAhPSBudWxsID8gJy8lcycgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWtleXdkczprZXl3b3Jkc1xuICAgICAgbmFtZTogJ2tleXdvcmRzJyxcbiAgICAgIHJlZzogL15rZXl3ZHM6KC4rKSQvLFxuICAgICAgZm9ybWF0OiAna2V5d2RzOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Y29udGVudDptYWluXG4gICAgICBuYW1lOiAnY29udGVudCcsXG4gICAgICByZWc6IC9eY29udGVudDooLispLyxcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXG4gICAgfSxcbiAgICAvLyBCRkNQIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NTgzXG4gICAge1xuICAgICAgLy8gYT1mbG9vcmN0cmw6Yy1zXG4gICAgICBuYW1lOiAnYmZjcEZsb29yQ3RybCcsXG4gICAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxuICAgICAgZm9ybWF0OiAnZmxvb3JjdHJsOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9Y29uZmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwQ29uZklkJyxcbiAgICAgIHJlZzogL15jb25maWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ2NvbmZpZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXVzZXJpZDoxXG4gICAgICBuYW1lOiAnYmZjcFVzZXJJZCcsXG4gICAgICByZWc6IC9edXNlcmlkOihcXGQrKS8sXG4gICAgICBmb3JtYXQ6ICd1c2VyaWQ6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1mbG9vcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JJZCcsXG4gICAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21TdHJlYW0nXSxcbiAgICAgIGZvcm1hdDogJ2Zsb29yaWQ6JXMgbXN0cm06JXMnXG4gICAgfSwge1xuICAgICAgLy8gYW55IGE9IHRoYXQgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpcyBrZXB0IHZlcmJhdGltIG9uIG1lZGlhLmludmFsaWRcbiAgICAgIHB1c2g6ICdpbnZhbGlkJyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ11cbiAgICB9XVxuICB9O1xuXG4gIC8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xuICBPYmplY3Qua2V5cyhncmFtbWFyJDEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBvYmpzID0gZ3JhbW1hciQxW2tleV07XG4gICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmICghb2JqLnJlZykge1xuICAgICAgICBvYmoucmVnID0gLyguKikvO1xuICAgICAgfVxuICAgICAgaWYgKCFvYmouZm9ybWF0KSB7XG4gICAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGdyYW1tYXIuZXhwb3J0cztcbn1cblxudmFyIGhhc1JlcXVpcmVkUGFyc2VyO1xuZnVuY3Rpb24gcmVxdWlyZVBhcnNlcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkUGFyc2VyKSByZXR1cm4gcGFyc2VyO1xuICBoYXNSZXF1aXJlZFBhcnNlciA9IDE7XG4gIChmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgIHZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XG4gICAgfTtcbiAgICB2YXIgYXR0YWNoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChtYXRjaCwgbG9jYXRpb24sIG5hbWVzLCByYXdOYW1lKSB7XG4gICAgICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICAgICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAobWF0Y2hbaSArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gICAgICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgICAgIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XG4gICAgICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICAgICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XG4gICAgICB9XG4gICAgICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/IHt9IDpcbiAgICAgIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gICAgICBhdHRhY2hQcm9wZXJ0aWVzKGNvbnRlbnQubWF0Y2gob2JqLnJlZyksIGtleUxvY2F0aW9uLCBvYmoubmFtZXMsIG9iai5uYW1lKTtcbiAgICAgIGlmIChvYmoucHVzaCkge1xuICAgICAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG4gICAgdmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG4gICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIHZhciBzZXNzaW9uID0ge30sXG4gICAgICAgIG1lZGlhID0gW10sXG4gICAgICAgIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgICAgIC8vIHBhcnNlIGxpbmVzIHdlIHVuZGVyc3RhbmRcbiAgICAgIHNkcC5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pLmZpbHRlcih2YWxpZExpbmUpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgICAgICB2YXIgY29udGVudCA9IGwuc2xpY2UoMik7XG4gICAgICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgICAgICBtZWRpYS5wdXNoKHtcbiAgICAgICAgICAgIHJ0cDogW10sXG4gICAgICAgICAgICBmbXRwOiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxvY2F0aW9uID0gbWVkaWFbbWVkaWEubGVuZ3RoIC0gMV07IC8vIHBvaW50IGF0IGxhdGVzdCBtZWRpYSBsaW5lXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICB2YXIgb2JqID0gZ3JhbW1hclt0eXBlXVtqXTtcbiAgICAgICAgICBpZiAob2JqLnJlZy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlc3Npb24ubWVkaWEgPSBtZWRpYTsgLy8gbGluayBpdCB1cFxuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfTtcbiAgICB2YXIgcGFyYW1SZWR1Y2VyID0gZnVuY3Rpb24gKGFjYywgZXhwcikge1xuICAgICAgdmFyIHMgPSBleHByLnNwbGl0KC89KC4rKS8sIDIpO1xuICAgICAgaWYgKHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGFjY1tzWzBdXSA9IHRvSW50SWZJbnQoc1sxXSk7XG4gICAgICB9IGVsc2UgaWYgKHMubGVuZ3RoID09PSAxICYmIGV4cHIubGVuZ3RoID4gMSkge1xuICAgICAgICBhY2Nbc1swXV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH07XG4gICAgZXhwb3J0cy5wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuc3BsaXQoLztcXHM/LykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICAgIH07XG5cbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIGFsaWFzIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuMFxuICAgIGV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cy5wYXJzZVBhcmFtcztcbiAgICBleHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRvU3RyaW5nKCkuc3BsaXQoJyAnKS5tYXAoTnVtYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcbiAgICBleHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5zdWJzdHJpbmcoMSwgaXRlbS5sZW5ndGggLSAxKS5zcGxpdCgnLCcpLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgdmFyIHNjaWQsXG4gICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZm9ybWF0WzBdICE9PSAnficpIHtcbiAgICAgICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdC5zdWJzdHJpbmcoMSwgZm9ybWF0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaWQ6IHNjaWQsXG4gICAgICAgICAgICBwYXVzZWQ6IHBhdXNlZFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSkocGFyc2VyKTtcbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxudmFyIHdyaXRlcjtcbnZhciBoYXNSZXF1aXJlZFdyaXRlcjtcbmZ1bmN0aW9uIHJlcXVpcmVXcml0ZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFdyaXRlcikgcmV0dXJuIHdyaXRlcjtcbiAgaGFzUmVxdWlyZWRXcml0ZXIgPSAxO1xuICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG5cbiAgLy8gY3VzdG9taXplZCB1dGlsLmZvcm1hdCAtIGRpc2NhcmRzIGV4Y2VzcyBhcmd1bWVudHMgYW5kIGNhbiB2b2lkIG1pZGRsZSBvbmVzXG4gIHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZHYlXS9nO1xuICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgcmV0dXJuIGZvcm1hdFN0ci5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmIChpID49IGxlbikge1xuICAgICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgICAgfVxuICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICBpICs9IDE7XG4gICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgY2FzZSAnJSUnOlxuICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgIGNhc2UgJyVzJzpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgICAgIGNhc2UgJyVkJzpcbiAgICAgICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgICAgIGNhc2UgJyV2JzpcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxuICB9O1xuICB2YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICAgIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pIDogb2JqLmZvcm1hdDtcbiAgICB2YXIgYXJncyA9IFt0eXBlICsgJz0nICsgc3RyXTtcbiAgICBpZiAob2JqLm5hbWVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IG9iai5uYW1lc1tpXTtcbiAgICAgICAgaWYgKG9iai5uYW1lKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG5cbiAgLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuICAvLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxuICB2YXIgZGVmYXVsdE91dGVyT3JkZXIgPSBbJ3YnLCAnbycsICdzJywgJ2knLCAndScsICdlJywgJ3AnLCAnYycsICdiJywgJ3QnLCAncicsICd6JywgJ2EnXTtcbiAgdmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG4gIHdyaXRlciA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICAgIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgc2Vzc2lvbi52ZXJzaW9uID0gMDsgLy8gJ3Y9MCcgbXVzdCBiZSB0aGVyZSAob25seSBkZWZpbmVkIHZlcnNpb24gYXRtKVxuICAgIH1cbiAgICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICAgIHNlc3Npb24ubmFtZSA9ICcgJzsgLy8gJ3M9ICcgbXVzdCBiZSB0aGVyZSBpZiBubyBtZWFuaW5nZnVsIG5hbWUgc2V0XG4gICAgfVxuICAgIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICAgIGlmIChtTGluZS5wYXlsb2FkcyA9PSBudWxsKSB7XG4gICAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG91dGVyT3JkZXIgPSBvcHRzLm91dGVyT3JkZXIgfHwgZGVmYXVsdE91dGVyT3JkZXI7XG4gICAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gICAgdmFyIHNkcCA9IFtdO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIG91dGVyT3JkZXIgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMgb24gc2Vzc2lvblxuICAgIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iai5uYW1lIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5wdXNoIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgICBzZHAucHVzaChtYWtlTGluZSgnbScsIGdyYW1tYXIubVswXSwgbUxpbmUpKTtcbiAgICAgIGlubmVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIGlmIChvYmoubmFtZSBpbiBtTGluZSAmJiBtTGluZVtvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBtTGluZSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1MaW5lW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xuICB9O1xuICByZXR1cm4gd3JpdGVyO1xufVxuXG52YXIgaGFzUmVxdWlyZWRMaWI7XG5mdW5jdGlvbiByZXF1aXJlTGliKCkge1xuICBpZiAoaGFzUmVxdWlyZWRMaWIpIHJldHVybiBsaWI7XG4gIGhhc1JlcXVpcmVkTGliID0gMTtcbiAgdmFyIHBhcnNlciA9IHJlcXVpcmVQYXJzZXIoKTtcbiAgdmFyIHdyaXRlciA9IHJlcXVpcmVXcml0ZXIoKTtcbiAgdmFyIGdyYW1tYXIgPSByZXF1aXJlR3JhbW1hcigpO1xuICBsaWIuZ3JhbW1hciA9IGdyYW1tYXI7XG4gIGxpYi53cml0ZSA9IHdyaXRlcjtcbiAgbGliLnBhcnNlID0gcGFyc2VyLnBhcnNlO1xuICBsaWIucGFyc2VQYXJhbXMgPSBwYXJzZXIucGFyc2VQYXJhbXM7XG4gIGxpYi5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxuICBsaWIucGFyc2VQYXlsb2FkcyA9IHBhcnNlci5wYXJzZVBheWxvYWRzO1xuICBsaWIucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gcGFyc2VyLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcztcbiAgbGliLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xuICBsaWIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gcGFyc2VyLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdDtcbiAgcmV0dXJuIGxpYjtcbn1cblxudmFyIGxpYkV4cG9ydHMgPSByZXF1aXJlTGliKCk7XG5cbmZ1bmN0aW9uIHIociwgZSwgbikge1xuICB2YXIgaSwgdCwgbztcbiAgdm9pZCAwID09PSBlICYmIChlID0gNTApLCB2b2lkIDAgPT09IG4gJiYgKG4gPSB7fSk7XG4gIHZhciBhID0gbnVsbCAhPSAoaSA9IG4uaXNJbW1lZGlhdGUpICYmIGksXG4gICAgdSA9IG51bGwgIT0gKHQgPSBuLmNhbGxiYWNrKSAmJiB0LFxuICAgIGMgPSBuLm1heFdhaXQsXG4gICAgdiA9IERhdGUubm93KCksXG4gICAgbCA9IFtdO1xuICBmdW5jdGlvbiBmKCkge1xuICAgIGlmICh2b2lkIDAgIT09IGMpIHtcbiAgICAgIHZhciByID0gRGF0ZS5ub3coKSAtIHY7XG4gICAgICBpZiAociArIGUgPj0gYykgcmV0dXJuIGMgLSByO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICB2YXIgZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgIG4gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoaSwgdCkge1xuICAgICAgdmFyIGMgPSBhICYmIHZvaWQgMCA9PT0gbztcbiAgICAgIGlmICh2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvID0gdm9pZCAwLCB2ID0gRGF0ZS5ub3coKSwgIWEpIHtcbiAgICAgICAgICB2YXIgaSA9IHIuYXBwbHkobiwgZSk7XG4gICAgICAgICAgdSAmJiB1KGkpLCBsLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgci5yZXNvbHZlKShpKTtcbiAgICAgICAgICB9KSwgbCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9LCBmKCkpLCBjKSB7XG4gICAgICAgIHZhciBkID0gci5hcHBseShuLCBlKTtcbiAgICAgICAgcmV0dXJuIHUgJiYgdShkKSwgaShkKTtcbiAgICAgIH1cbiAgICAgIGwucHVzaCh7XG4gICAgICAgIHJlc29sdmU6IGksXG4gICAgICAgIHJlamVjdDogdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBkLmNhbmNlbCA9IGZ1bmN0aW9uIChyKSB7XG4gICAgdm9pZCAwICE9PSBvICYmIGNsZWFyVGltZW91dChvKSwgbC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gKDAsIGUucmVqZWN0KShyKTtcbiAgICB9KSwgbCA9IFtdO1xuICB9LCBkO1xufVxuXG4vKiBUaGUgc3ZjIGNvZGVjIChhdjEvdnA5KSB3b3VsZCB1c2UgYSB2ZXJ5IGxvdyBiaXRyYXRlIGF0IHRoZSBiZWdpbmluZyBhbmRcbmluY3JlYXNlIHNsb3dseSBieSB0aGUgYmFuZHdpZHRoIGVzdGltYXRvciB1bnRpbCBpdCByZWFjaCB0aGUgdGFyZ2V0IGJpdHJhdGUuIFRoZVxucHJvY2VzcyBjb21tb25seSBjb3N0IG1vcmUgdGhhbiAxMCBzZWNvbmRzIGNhdXNlIHN1YnNjcmliZXIgd2lsbCBnZXQgYmx1ciB2aWRlbyBhdFxudGhlIGZpcnN0IGZldyBzZWNvbmRzLiBTbyB3ZSB1c2UgYSA3MCUgb2YgdGFyZ2V0IGJpdHJhdGUgaGVyZSBhcyB0aGUgc3RhcnQgYml0cmF0ZSB0b1xuZWxpbWluYXRlIHRoaXMgaXNzdWUuXG4qL1xuY29uc3Qgc3RhcnRCaXRyYXRlRm9yU1ZDID0gMC43O1xuY29uc3QgZGVib3VuY2VJbnRlcnZhbCA9IDIwO1xuY29uc3QgUENFdmVudHMgPSB7XG4gIE5lZ290aWF0aW9uU3RhcnRlZDogJ25lZ290aWF0aW9uU3RhcnRlZCcsXG4gIE5lZ290aWF0aW9uQ29tcGxldGU6ICduZWdvdGlhdGlvbkNvbXBsZXRlJyxcbiAgUlRQVmlkZW9QYXlsb2FkVHlwZXM6ICdydHBWaWRlb1BheWxvYWRUeXBlcydcbn07XG4vKiogQGludGVybmFsICovXG5jbGFzcyBQQ1RyYW5zcG9ydCBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgZ2V0IHBjKCkge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGM7XG4gIH1cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmRkRXh0SUQgPSAwO1xuICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzID0gW107XG4gICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gW107XG4gICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IFtdO1xuICAgIC8vIGRlYm91bmNlZCBuZWdvdGlhdGUgaW50ZXJmYWNlXG4gICAgdGhpcy5uZWdvdGlhdGUgPSByKG9uRXJyb3IgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBkZWJvdW5jZUludGVydmFsKTtcbiAgICB0aGlzLmNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QQ1RyYW5zcG9ydCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcbiAgfVxuICBjcmVhdGVQQygpIHtcbiAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbmZpZyk7XG4gICAgcGMub25pY2VjYW5kaWRhdGUgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWV2LmNhbmRpZGF0ZSkgcmV0dXJuO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYuY2FuZGlkYXRlKTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY2FuZGlkYXRlZXJyb3IgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uRGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHBjLm9udHJhY2sgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBwYztcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgfVxuICBnZXQgaXNJQ0VDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjICE9PSBudWxsICYmICh0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKTtcbiAgfVxuICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uICYmICF0aGlzLnJlc3RhcnRpbmdJY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbihzZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBsZXQgbXVuZ2VkU0RQID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNkLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzdGVyZW9NaWRzLFxuICAgICAgICAgIG5hY2tNaWRzXG4gICAgICAgIH0gPSBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKHNkKTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gc3RlcmVvTWlkcztcbiAgICAgICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IG5hY2tNaWRzO1xuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IHNkLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIC8vIG11bmcgc2RwIGZvciBvcHVzIGJpdHJhdGUgc2V0dGluZ3NcbiAgICAgICAgICAgIHRoaXMudHJhY2tCaXRyYXRlcy5zb21lKHRyYWNrYnIgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRyYWNrYnIudHJhbnNjZWl2ZXIgfHwgbWVkaWEubWlkICE9IHRyYWNrYnIudHJhbnNjZWl2ZXIubWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChydHAuY29kZWMudG9VcHBlckNhc2UoKSA9PT0gdHJhY2tici5jb2RlYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY29kZWNQYXlsb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGZtdHBGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xuICAgICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgPSBmbXRwLmNvbmZpZy5zcGxpdCgnOycpLmZpbHRlcihhdHRyID0+ICFhdHRyLmluY2x1ZGVzKCdtYXhhdmVyYWdlYml0cmF0ZScpKS5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAodHJhY2tici5tYXhiciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gXCI7bWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZtdHBGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFmbXRwRm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tici5tYXhiciA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjUGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBcIm1heGF2ZXJhZ2ViaXRyYXRlPVwiLmNvbmNhdCh0cmFja2JyLm1heGJyICogMTAwMClcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG11bmdlZFNEUCA9IGxpYkV4cG9ydHMud3JpdGUoc2RwUGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWRTRFAsIHRydWUpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucmVuZWdvdGlhdGUpIHtcbiAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSk7XG4gICAgICAgIGlmIChzZC5zZHApIHtcbiAgICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKHNkLnNkcCk7XG4gICAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBtZWRpYS5ydHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMub25PZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBJQ0UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BjICYmIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgICAgLy8gd2UncmUgd2FpdGluZyBmb3IgdGhlIHBlZXIgdG8gYWNjZXB0IG91ciBvZmZlciwgc28gd2UnbGwganVzdCB3YWl0XG4gICAgICAgIC8vIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIHdoZW4gSUNFIHJlc3RhcnQgaXMgbmVlZGVkXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTRCA9IHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pY2VSZXN0YXJ0KSAmJiBjdXJyZW50U0QpIHtcbiAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWQgYnV0IHdlIGRvbid0IGhhdmUgYSByZW1vdGUgZGVzY3JpcHRpb25cbiAgICAgICAgICAvLyB0aGUgYmVzdCB0aGluZyB0byBkbyBpcyB0byByZWNyZWF0ZSB0aGUgcGVlcmNvbm5lY3Rpb25cbiAgICAgICAgICB5aWVsZCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihjdXJyZW50U0QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcGMgfHwgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBjcmVhdGVPZmZlciB3aXRoIGNsb3NlZCBwZWVyIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhY3R1YWxseSBuZWdvdGlhdGVcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydGluZyB0byBuZWdvdGlhdGUnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgY29uc3Qgb2ZmZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZU9mZmVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ29yaWdpbmFsIG9mZmVyJywgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHNkcDogb2ZmZXIuc2RwXG4gICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gb2ZmZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSk7XG4gICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBbXSwgW10pO1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcbiAgICAgICAgICAgIGlmICghbWVkaWEubXNpZCB8fCAhdHJhY2tici5jaWQgfHwgIW1lZGlhLm1zaWQuaW5jbHVkZXModHJhY2tici5jaWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTVkNDb2RlYyh0cmFja2JyLmNvZGVjKSkge1xuICAgICAgICAgICAgICB0aGlzLmVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEsIHNkcFBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBhdjEgc2xvdyBzdGFydGluZyBpc3N1ZSBhbHJlYWR5IGZpeGVkIGluIGNocm9tZSAxMjQsIGNsZWFuIHRoaXMgYWZ0ZXIgc29tZSB2ZXJzaW9uc1xuICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIGF2MSBiaXRyYXRlIHNldHRpbmcgdGhhdCBjYW4ndCBhcHBseSBieSBzZW5kRW5jb2RpbmdcbiAgICAgICAgICAgIGlmICh0cmFja2JyLmNvZGVjICE9PSAnYXYxJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Qml0cmF0ZSA9IE1hdGgucm91bmQodHJhY2tici5tYXhiciAqIHN0YXJ0Qml0cmF0ZUZvclNWQyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xuICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbm90aGVyIHRyYWNrJ3MgZm10cCBhbHJlYWR5IGlzIHNldCwgd2UgY2Fubm90IG92ZXJyaWRlIHRoZSBiaXRyYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXMgdGhlIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nIGZvcmNlZCB0byB1c2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbCB0cmFjaydzIGJpdHJhdGUgZm9yIGFsbCB0cmFja3NcbiAgICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1zdGFydC1iaXRyYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9XCIuY29uY2F0KHN0YXJ0Qml0cmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChvZmZlciwgbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpKTtcbiAgICAgIHRoaXMub25PZmZlcihvZmZlcik7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQW5kU2V0QW5zd2VyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBhbnN3ZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSk7XG4gICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCB0aGlzLnJlbW90ZVN0ZXJlb01pZHMsIHRoaXMucmVtb3RlTmFja01pZHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKGFuc3dlciwgbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpKTtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIHJldHVybiB0aGlzLnBjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpO1xuICB9XG4gIGFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cbiAgYWRkVHJhY2sodHJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgY2xvc2VkLCBjYW5ub3QgYWRkIHRyYWNrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYy5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgc2V0VHJhY2tDb2RlY0JpdHJhdGUoaW5mbykge1xuICAgIHRoaXMudHJhY2tCaXRyYXRlcy5wdXNoKGluZm8pO1xuICB9XG4gIHNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBjb25maWd1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpO1xuICB9XG4gIGNhblJlbW92ZVRyYWNrKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVUcmFjayk7XG4gIH1cbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gIH1cbiAgZ2V0Q29ubmVjdGlvblN0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvblN0YXRlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnY2xvc2VkJztcbiAgfVxuICBnZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pY2VDb25uZWN0aW9uU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldFNpZ25hbGxpbmdTdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZ25hbGluZ1N0YXRlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnY2xvc2VkJztcbiAgfVxuICBnZXRUcmFuc2NlaXZlcnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gIH1cbiAgZ2V0U2VuZGVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNlbmRlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gIH1cbiAgZ2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxEZXNjcmlwdGlvbjtcbiAgfVxuICBnZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgfVxuICBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5wYy5nZXRTdGF0cygpO1xuICB9XG4gIGdldENvbm5lY3RlZEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gJyc7XG4gICAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IG5ldyBNYXAoKTtcbiAgICAgIC8vIGlkIC0+IGNhbmRpZGF0ZSBpcFxuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIHN3aXRjaCAodi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9IHYuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5kaWRhdGVQYWlycy5zZXQodi5pZCwgdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZW1vdGUtY2FuZGlkYXRlJzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIFwiXCIuY29uY2F0KHYuYWRkcmVzcywgXCI6XCIpLmNvbmNhdCh2LnBvcnQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkSUQgPSAoX2EgPSBjYW5kaWRhdGVQYWlycy5nZXQoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlQ2FuZGlkYXRlSWQ7XG4gICAgICBpZiAoc2VsZWN0ZWRJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlcy5nZXQoc2VsZWN0ZWRJRCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWQsIHJlbW90ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAobXVuZ2VkKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2RwID0gc2Quc2RwO1xuICAgICAgICBzZC5zZHAgPSBtdW5nZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIG11bmdlZCBcIi5jb25jYXQocmVtb3RlID8gJ3JlbW90ZScgOiAnbG9jYWwnLCBcIiBkZXNjcmlwdGlvblwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcIm5vdCBhYmxlIHRvIHNldCBcIi5jb25jYXQoc2QudHlwZSwgXCIsIGZhbGxpbmcgYmFjayB0byB1bm1vZGlmaWVkIHNkcFwiKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIHNkcDogbXVuZ2VkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHNkLnNkcCA9IG9yaWdpbmFsU2RwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbXNnID0gJ3Vua25vd24gZXJyb3InO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbXNnID0gZS5tZXNzYWdlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG1zZyA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmllbGRzID0ge1xuICAgICAgICAgIGVycm9yOiBtc2csXG4gICAgICAgICAgc2RwOiBzZC5zZHBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyZW1vdGUgJiYgdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbikge1xuICAgICAgICAgIGZpZWxkcy5yZW1vdGVTZHAgPSB0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwidW5hYmxlIHRvIHNldCBcIi5jb25jYXQoc2QudHlwZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGZpZWxkc1xuICAgICAgICB9KSk7XG4gICAgICAgIHRocm93IG5ldyBOZWdvdGlhdGlvbkVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSwgc2RwKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkZEZvdW5kID0gKF9hID0gbWVkaWEuZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZShleHQgPT4ge1xuICAgICAgaWYgKGV4dC51cmkgPT09IGRkRXh0ZW5zaW9uVVJJKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIGlmICghZGRGb3VuZCkge1xuICAgICAgaWYgKHRoaXMuZGRFeHRJRCA9PT0gMCkge1xuICAgICAgICBsZXQgbWF4SUQgPSAwO1xuICAgICAgICBzZHAubWVkaWEuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKG0udHlwZSAhPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoX2EgPSBtLmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZXh0ID0+IHtcbiAgICAgICAgICAgIGlmIChleHQudmFsdWUgPiBtYXhJRCkge1xuICAgICAgICAgICAgICBtYXhJRCA9IGV4dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGRFeHRJRCA9IG1heElEICsgMTtcbiAgICAgIH1cbiAgICAgIChfYiA9IG1lZGlhLmV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGhpcy5kZEV4dElELFxuICAgICAgICB1cmk6IGRkRXh0ZW5zaW9uVVJJXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgc3RlcmVvTWlkcywgbmFja01pZHMpIHtcbiAgLy8gZm91bmQgb3B1cyBjb2RlYyB0byBhZGQgbmFjayBmYlxuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICAvLyBhZGQgbmFjayBydGNwZmIgaWYgbm90IGV4aXN0XG4gIGlmIChvcHVzUGF5bG9hZCA+IDApIHtcbiAgICBpZiAoIW1lZGlhLnJ0Y3BGYikge1xuICAgICAgbWVkaWEucnRjcEZiID0gW107XG4gICAgfVxuICAgIGlmIChuYWNrTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQpICYmICFtZWRpYS5ydGNwRmIuc29tZShmYiA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XG4gICAgICBtZWRpYS5ydGNwRmIucHVzaCh7XG4gICAgICAgIHBheWxvYWQ6IG9wdXNQYXlsb2FkLFxuICAgICAgICB0eXBlOiAnbmFjaydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RlcmVvTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQpKSB7XG4gICAgICBtZWRpYS5mbXRwLnNvbWUoZm10cCA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJztzdGVyZW89MSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihvZmZlcikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHN0ZXJlb01pZHMgPSBbXTtcbiAgY29uc3QgbmFja01pZHMgPSBbXTtcbiAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcbiAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmICgoX2EgPSBtZWRpYS5ydGNwRmIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcbiAgICAgICAgbmFja01pZHMucHVzaChtZWRpYS5taWQpO1xuICAgICAgfVxuICAgICAgbWVkaWEuZm10cC5zb21lKGZtdHAgPT4ge1xuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xuICAgICAgICAgIGlmIChmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3Byb3Atc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgc3RlcmVvTWlkcy5wdXNoKG1lZGlhLm1pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RlcmVvTWlkcyxcbiAgICBuYWNrTWlkc1xuICB9O1xufVxuZnVuY3Rpb24gZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKSB7XG4gIC8vIENocm9tZSBjb3VsZCBnZW5lcmF0ZSBzZHAgd2l0aCBjID0gSU4gSVA0IDxpcHY2IGFkZHI+XG4gIC8vIGluIGVkZ2UgY2FzZSBhbmQgcmV0dXJuIGVycm9yIHdoZW4gc2V0IHNkcC5UaGlzIGlzIG5vdCBhXG4gIC8vIHNkayBlcnJvciBidXQgY29ycmVjdCBpdCBpZiB0aGUgaXNzdWUgZGV0ZWN0ZWQuXG4gIGlmIChtZWRpYS5jb25uZWN0aW9uKSB7XG4gICAgY29uc3QgaXNWNiA9IG1lZGlhLmNvbm5lY3Rpb24uaXAuaW5kZXhPZignOicpID49IDA7XG4gICAgaWYgKG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9PT0gNCAmJiBpc1Y2IHx8IG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9PT0gNiAmJiAhaXNWNikge1xuICAgICAgLy8gZmFsbGJhY2sgdG8gZHVtbXkgYWRkcmVzc1xuICAgICAgbWVkaWEuY29ubmVjdGlvbi5pcCA9ICcwLjAuMC4wJztcbiAgICAgIG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9IDQ7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRWaWRlb0NvZGVjID0gJ3ZwOCc7XG5jb25zdCBwdWJsaXNoRGVmYXVsdHMgPSB7XG4gIGF1ZGlvUHJlc2V0OiBBdWRpb1ByZXNldHMubXVzaWMsXG4gIGR0eDogdHJ1ZSxcbiAgcmVkOiB0cnVlLFxuICBmb3JjZVN0ZXJlbzogZmFsc2UsXG4gIHNpbXVsY2FzdDogdHJ1ZSxcbiAgc2NyZWVuU2hhcmVFbmNvZGluZzogU2NyZWVuU2hhcmVQcmVzZXRzLmgxMDgwZnBzMTUuZW5jb2RpbmcsXG4gIHN0b3BNaWNUcmFja09uTXV0ZTogZmFsc2UsXG4gIHZpZGVvQ29kZWM6IGRlZmF1bHRWaWRlb0NvZGVjLFxuICBiYWNrdXBDb2RlYzogdHJ1ZVxufTtcbmNvbnN0IGF1ZGlvRGVmYXVsdHMgPSB7XG4gIGRldmljZUlkOiB7XG4gICAgaWRlYWw6ICdkZWZhdWx0J1xuICB9LFxuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gIHZvaWNlSXNvbGF0aW9uOiB0cnVlXG59O1xuY29uc3QgdmlkZW9EZWZhdWx0cyA9IHtcbiAgZGV2aWNlSWQ6IHtcbiAgICBpZGVhbDogJ2RlZmF1bHQnXG4gIH0sXG4gIHJlc29sdXRpb246IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb25cbn07XG5jb25zdCByb29tT3B0aW9uRGVmYXVsdHMgPSB7XG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcbiAgZHluYWNhc3Q6IGZhbHNlLFxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXG4gIGRpc2Nvbm5lY3RPblBhZ2VMZWF2ZTogdHJ1ZSxcbiAgd2ViQXVkaW9NaXg6IGZhbHNlXG59O1xuY29uc3Qgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyA9IHtcbiAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgbWF4UmV0cmllczogMSxcbiAgcGVlckNvbm5lY3Rpb25UaW1lb3V0OiAxNTAwMCxcbiAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcbn07XG5cbnZhciBQQ1RyYW5zcG9ydFN0YXRlO1xuKGZ1bmN0aW9uIChQQ1RyYW5zcG9ydFN0YXRlKSB7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIk5FV1wiXSA9IDBdID0gXCJORVdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDJdID0gXCJDT05ORUNURURcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiRkFJTEVEXCJdID0gM10gPSBcIkZBSUxFRFwiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TSU5HXCJdID0gNF0gPSBcIkNMT1NJTkdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ0xPU0VEXCJdID0gNV0gPSBcIkNMT1NFRFwiO1xufSkoUENUcmFuc3BvcnRTdGF0ZSB8fCAoUENUcmFuc3BvcnRTdGF0ZSA9IHt9KSk7XG5jbGFzcyBQQ1RyYW5zcG9ydE1hbmFnZXIge1xuICBnZXQgbmVlZHNQdWJsaXNoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQ7XG4gIH1cbiAgZ2V0IG5lZWRzU3Vic2NyaWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICBjb25zdHJ1Y3RvcihydGNDb25maWcsIHN1YnNjcmliZXJQcmltYXJ5LCBsb2dnZXJPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMudXBkYXRlU3RhdGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZXMgPSB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0cy5tYXAodHIgPT4gdHIuZ2V0Q29ubmVjdGlvblN0YXRlKCkpO1xuICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoc3QgPT4gc3QgPT09ICdjb25uZWN0ZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuc29tZShzdCA9PiBzdCA9PT0gJ2ZhaWxlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnY29ubmVjdGluZycpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoc3QgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TRUQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuc29tZShzdCA9PiBzdCA9PT0gJ2Nsb3NlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NJTkc7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoc3QgPT4gc3QgPT09ICduZXcnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5ORVc7XG4gICAgICB9XG4gICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInBjIHN0YXRlIGNoYW5nZTogZnJvbSBcIi5jb25jYXQoUENUcmFuc3BvcnRTdGF0ZVtwcmV2aW91c1N0YXRlXSwgXCIgdG8gXCIpLmNvbmNhdChQQ1RyYW5zcG9ydFN0YXRlW3RoaXMuc3RhdGVdKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgKF9hID0gdGhpcy5vblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzLnN0YXRlLCB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSwgdGhpcy5zdWJzY3JpYmVyLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUENNYW5hZ2VyKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSAhc3Vic2NyaWJlclByaW1hcnk7XG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSBzdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMucHVibGlzaGVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vblNpZ25hbGluZ1N0YXRlY2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNhbmRpZGF0ZSA9IGNhbmRpZGF0ZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlID0gY2FuZGlkYXRlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIH07XG4gICAgLy8gaW4gc3Vic2NyaWJlciBwcmltYXJ5IG1vZGUsIHNlcnZlciBzaWRlIG9wZW5zIHN1YiBkYXRhIGNoYW5uZWxzLlxuICAgIHRoaXMuc3Vic2NyaWJlci5vbkRhdGFDaGFubmVsID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25UcmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIub25PZmZlciA9IG9mZmVyID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25QdWJsaXNoZXJPZmZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgb2ZmZXIpO1xuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMucmVtb3RlT2ZmZXJMb2NrID0gbmV3IF8oKTtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgfVxuICByZXF1aXJlUHVibGlzaGVyKCkge1xuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuICByZXF1aXJlU3Vic2NyaWJlcigpIHtcbiAgICBsZXQgcmVxdWlyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKTtcbiAgfVxuICBzZXRQdWJsaXNoZXJBbnN3ZXIoc2QpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICB9XG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbmRlciBvZiBwdWJsaXNoZXIuZ2V0U2VuZGVycygpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBoYXZlIHJlbW92ZVRyYWNrIHlldC5cbiAgICAgICAgICAgIGlmIChwdWJsaXNoZXIuY2FuUmVtb3ZlVHJhY2soKSkge1xuICAgICAgICAgICAgICBwdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcmVtb3ZlVHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLnB1Ymxpc2hlci5jbG9zZSgpLCB0aGlzLnN1YnNjcmliZXIuY2xvc2UoKV0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIHRyaWdnZXJJY2VSZXN0YXJ0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnN1YnNjcmliZXIucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgICAvLyBvbmx5IHJlc3RhcnQgcHVibGlzaGVyIGlmIGl0J3MgbmVlZGVkXG4gICAgICBpZiAodGhpcy5uZWVkc1B1Ymxpc2hlcikge1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcih7XG4gICAgICAgICAgaWNlUmVzdGFydDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyKHNkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgUlRDU2RwVHlwZTogc2QudHlwZSxcbiAgICAgICAgc2RwOiBzZC5zZHAsXG4gICAgICAgIHNpZ25hbGluZ1N0YXRlOiB0aGlzLnN1YnNjcmliZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkudG9TdHJpbmcoKVxuICAgICAgfSkpO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5yZW1vdGVPZmZlckxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgLy8gYW5zd2VyIHRoZSBvZmZlclxuICAgICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnN1YnNjcmliZXIuY3JlYXRlQW5kU2V0QW5zd2VyKCk7XG4gICAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZywgaWNlUmVzdGFydCkge1xuICAgIHRoaXMucHVibGlzaGVyLnNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICB0aGlzLnN1YnNjcmliZXIuc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIGlmIChpY2VSZXN0YXJ0KSB7XG4gICAgICB0aGlzLnRyaWdnZXJJY2VSZXN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIGVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RlZCcgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCduZWdvdGlhdGlvbiByZXF1aXJlZCwgc3RhcnQgbmVnb3RpYXRpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKChfYSA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKHRyYW5zcG9ydCA9PiB0aGlzLmVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZCh0cmFuc3BvcnQsIGFib3J0Q29udHJvbGxlciwgdGltZW91dCkpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmVnb3RpYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiB0aW1lZCBvdXQnKTtcbiAgICAgICAgfSwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG5lZ290aWF0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiBhYm9ydGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCwgKCkgPT4ge1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZShlID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLCB0cmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhY2sodHJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhY2sodHJhY2spO1xuICB9XG4gIGNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHJlcXVpcmVkIHRyYW5zcG9ydCdzIGFkZHJlc3MgaWYgbm8gZXhwbGljaXQgdGFyZ2V0IGlzIHNwZWNpZmllZFxuICAgKi9cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcyh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUikge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzWzBdLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgfVxuICBnZXQgcmVxdWlyZWRUcmFuc3BvcnRzKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSBbXTtcbiAgICBpZiAodGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCkge1xuICAgICAgdHJhbnNwb3J0cy5wdXNoKHRoaXMucHVibGlzaGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5zdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gIH1cbiAgZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHBjVHJhbnNwb3J0XzEsIGFib3J0Q29udHJvbGxlcl8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHBjVHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlID0gcGNUcmFuc3BvcnQuZ2V0Q29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IHRyYW5zcG9ydCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignY291bGQgbm90IGVzdGFibGlzaCBwYyBjb25uZWN0aW9uJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTsgLy8gRklYTUUgd2Ugc2hvdWxkbid0IHJlbHkgb24gYHNsZWVwYCBpbiB0aGUgY29ubmVjdGlvbiBwYXRocywgYXMgaXQgaW52b2tlcyBgc2V0VGltZW91dGAgd2hpY2ggY2FuIGJlIGRyYXN0aWNhbGx5IHRocm90dGxlZCBieSBicm93c2VyIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IDIwMjQgTGl2ZUtpdCwgSW5jLlxuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4vKipcbiAqIFNwZWNpYWxpemVkIGVycm9yIGhhbmRsaW5nIGZvciBSUEMgbWV0aG9kcy5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyB0eXBlLCB3aGVuIHRocm93biBpbiBhIG1ldGhvZCBoYW5kbGVyLCB3aWxsIGhhdmUgdGhlaXIgYG1lc3NhZ2VgXG4gKiBzZXJpYWxpemVkIGFuZCBzZW50IGFjcm9zcyB0aGUgd2lyZS4gVGhlIHNlbmRlciB3aWxsIHJlY2VpdmUgYW4gZXF1aXZhbGVudCBlcnJvciBvbiB0aGUgb3RoZXIgc2lkZS5cbiAqXG4gKiBCdWlsdC1pbiB0eXBlcyBhcmUgaW5jbHVkZWQgYnV0IGRldmVsb3BlcnMgbWF5IHVzZSBhbnkgc3RyaW5nLCB3aXRoIGEgbWF4IGxlbmd0aCBvZiAyNTYgYnl0ZXMuXG4gKi9cbmNsYXNzIFJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29kZSBhbmQgbWVzc2FnZSwgcGx1cyBhbiBvcHRpb25hbCBkYXRhIHBheWxvYWQuXG4gICAqXG4gICAqIElmIHRocm93biBpbiBhbiBSUEMgbWV0aG9kIGhhbmRsZXIsIHRoZSBlcnJvciB3aWxsIGJlIHNlbnQgYmFjayB0byB0aGUgY2FsbGVyLlxuICAgKlxuICAgKiBFcnJvciBjb2RlcyAxMDAxLTE5OTkgYXJlIHJlc2VydmVkIGZvciBidWlsdC1pbiBlcnJvcnMgKHNlZSBScGNFcnJvci5FcnJvckNvZGUgZm9yIHRoZWlyIG1lYW5pbmdzKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IHRydW5jYXRlQnl0ZXMobWVzc2FnZSwgUnBjRXJyb3IuTUFYX01FU1NBR0VfQllURVMpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgPyB0cnVuY2F0ZUJ5dGVzKGRhdGEsIFJwY0Vycm9yLk1BWF9EQVRBX0JZVEVTKSA6IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgZnJvbVByb3RvKHByb3RvKSB7XG4gICAgcmV0dXJuIG5ldyBScGNFcnJvcihwcm90by5jb2RlLCBwcm90by5tZXNzYWdlLCBwcm90by5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b1Byb3RvKCkge1xuICAgIHJldHVybiBuZXcgUnBjRXJyb3IkMSh7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgZnJvbSB0aGUgY29kZSwgd2l0aCBhbiBhdXRvLXBvcHVsYXRlZCBtZXNzYWdlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBidWlsdEluKGtleSwgZGF0YSkge1xuICAgIHJldHVybiBuZXcgUnBjRXJyb3IoUnBjRXJyb3IuRXJyb3JDb2RlW2tleV0sIFJwY0Vycm9yLkVycm9yTWVzc2FnZVtrZXldLCBkYXRhKTtcbiAgfVxufVxuUnBjRXJyb3IuTUFYX01FU1NBR0VfQllURVMgPSAyNTY7XG5ScGNFcnJvci5NQVhfREFUQV9CWVRFUyA9IDE1MzYwOyAvLyAxNSBLQlxuUnBjRXJyb3IuRXJyb3JDb2RlID0ge1xuICBBUFBMSUNBVElPTl9FUlJPUjogMTUwMCxcbiAgQ09OTkVDVElPTl9USU1FT1VUOiAxNTAxLFxuICBSRVNQT05TRV9USU1FT1VUOiAxNTAyLFxuICBSRUNJUElFTlRfRElTQ09OTkVDVEVEOiAxNTAzLFxuICBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRTogMTUwNCxcbiAgU0VORF9GQUlMRUQ6IDE1MDUsXG4gIFVOU1VQUE9SVEVEX01FVEhPRDogMTQwMCxcbiAgUkVDSVBJRU5UX05PVF9GT1VORDogMTQwMSxcbiAgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRTogMTQwMixcbiAgVU5TVVBQT1JURURfU0VSVkVSOiAxNDAzLFxuICBVTlNVUFBPUlRFRF9WRVJTSU9OOiAxNDA0XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuUnBjRXJyb3IuRXJyb3JNZXNzYWdlID0ge1xuICBBUFBMSUNBVElPTl9FUlJPUjogJ0FwcGxpY2F0aW9uIGVycm9yIGluIG1ldGhvZCBoYW5kbGVyJyxcbiAgQ09OTkVDVElPTl9USU1FT1VUOiAnQ29ubmVjdGlvbiB0aW1lb3V0JyxcbiAgUkVTUE9OU0VfVElNRU9VVDogJ1Jlc3BvbnNlIHRpbWVvdXQnLFxuICBSRUNJUElFTlRfRElTQ09OTkVDVEVEOiAnUmVjaXBpZW50IGRpc2Nvbm5lY3RlZCcsXG4gIFJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFOiAnUmVzcG9uc2UgcGF5bG9hZCB0b28gbGFyZ2UnLFxuICBTRU5EX0ZBSUxFRDogJ0ZhaWxlZCB0byBzZW5kJyxcbiAgVU5TVVBQT1JURURfTUVUSE9EOiAnTWV0aG9kIG5vdCBzdXBwb3J0ZWQgYXQgZGVzdGluYXRpb24nLFxuICBSRUNJUElFTlRfTk9UX0ZPVU5EOiAnUmVjaXBpZW50IG5vdCBmb3VuZCcsXG4gIFJFUVVFU1RfUEFZTE9BRF9UT09fTEFSR0U6ICdSZXF1ZXN0IHBheWxvYWQgdG9vIGxhcmdlJyxcbiAgVU5TVVBQT1JURURfU0VSVkVSOiAnUlBDIG5vdCBzdXBwb3J0ZWQgYnkgc2VydmVyJyxcbiAgVU5TVVBQT1JURURfVkVSU0lPTjogJ1Vuc3VwcG9ydGVkIFJQQyB2ZXJzaW9uJ1xufTtcbi8qXG4gKiBNYXhpbXVtIHBheWxvYWQgc2l6ZSBmb3IgUlBDIHJlcXVlc3RzIGFuZCByZXNwb25zZXMuIElmIGEgcGF5bG9hZCBleGNlZWRzIHRoaXMgc2l6ZSxcbiAqIHRoZSBSUEMgY2FsbCB3aWxsIGZhaWwgd2l0aCBhIFJFUVVFU1RfUEFZTE9BRF9UT09fTEFSR0UoMTQwMikgb3IgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UoMTUwNCkgZXJyb3IuXG4gKi9cbmNvbnN0IE1BWF9QQVlMT0FEX0JZVEVTID0gMTUzNjA7IC8vIDE1IEtCXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBieXRlTGVuZ3RoKHN0cikge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIpLmxlbmd0aDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRydW5jYXRlQnl0ZXMoc3RyLCBtYXhCeXRlcykge1xuICBpZiAoYnl0ZUxlbmd0aChzdHIpIDw9IG1heEJ5dGVzKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgbG93ID0gMDtcbiAgbGV0IGhpZ2ggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCArIDEpIC8gMik7XG4gICAgaWYgKGVuY29kZXIuZW5jb2RlKHN0ci5zbGljZSgwLCBtaWQpKS5sZW5ndGggPD0gbWF4Qnl0ZXMpIHtcbiAgICAgIGxvdyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHIuc2xpY2UoMCwgbG93KTtcbn1cblxuY29uc3QgbW9uaXRvckZyZXF1ZW5jeSA9IDIwMDA7XG5mdW5jdGlvbiBjb21wdXRlQml0cmF0ZShjdXJyZW50U3RhdHMsIHByZXZTdGF0cykge1xuICBpZiAoIXByZXZTdGF0cykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBieXRlc05vdztcbiAgbGV0IGJ5dGVzUHJldjtcbiAgaWYgKCdieXRlc1JlY2VpdmVkJyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgIGJ5dGVzUHJldiA9IHByZXZTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICB9IGVsc2UgaWYgKCdieXRlc1NlbnQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzU2VudDtcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNTZW50O1xuICB9XG4gIGlmIChieXRlc05vdyA9PT0gdW5kZWZpbmVkIHx8IGJ5dGVzUHJldiA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCB8fCBwcmV2U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gKGJ5dGVzTm93IC0gYnl0ZXNQcmV2KSAqIDggKiAxMDAwIC8gKGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgLSBwcmV2U3RhdHMudGltZXN0YW1wKTtcbn1cblxuY29uc3QgZGVmYXVsdERpbWVuc2lvbnNUaW1lb3V0ID0gMTAwMDtcbmNsYXNzIExvY2FsVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IHNlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0IHNlbmRlcihzZW5kZXIpIHtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gIH1cbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJhaW50cztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBraW5kLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50ID0gKCkgPT4gdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyKCkuY2F0Y2goKCkgPT4gdGhpcy5sb2cuZGVidWcoJ3RyYWNrIG11dGUgYm91bmNlIGdvdCBjYW5jZWxsZWQgYnkgYW4gdW5tdXRlIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyID0gcigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW0oKTtcbiAgICB9KSwgNTAwMCk7XG4gICAgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgndW5tdXRlJyk7XG4gICAgICB5aWVsZCB0aGlzLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kKSB7XG4gICAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgIHRoaXMubXV0ZUxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMucGF1c2VVcHN0cmVhbUxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMucHJvY2Vzc29yTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5yZXN0YXJ0TG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhVHJhY2ssIHRydWUpO1xuICAgIC8vIGFkZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIsIGNvbnN0cmFpbnRzIGFyZSBzeW5jZWQgd2l0aCBNZWRpYVN0cmVhbVRyYWNrXG4gICAgdGhpcy5fY29uc3RyYWludHMgPSBtZWRpYVRyYWNrLmdldENvbnN0cmFpbnRzKCk7XG4gICAgaWYgKGNvbnN0cmFpbnRzKSB7XG4gICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgIH1cbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suaWQ7XG4gIH1cbiAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMua2luZCAhPT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQ7XG4gIH1cbiAgZ2V0IGlzVXNlclByb3ZpZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkQnlVc2VyO1xuICB9XG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvY2Vzc2VkVHJhY2spICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiByZXR1cm5zIG1lZGlhU3RyZWFtVHJhY2sgc2V0dGluZ3Mgb2YgdGhlIGNhcHR1cmluZyBtZWRpYXN0cmVhbXRyYWNrIHNvdXJjZSAtIGlnbm9yaW5nIHByb2Nlc3NvcnNcbiAgICovXG4gIGdldFNvdXJjZVRyYWNrU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgfVxuICBzZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrLCBmb3JjZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAobmV3VHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIC8vIGRldGFjaFxuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgnbmV3LXRyYWNrJyk7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW25ld1RyYWNrXSk7XG4gICAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgLy8gd2hlbiB1bmRlcmx5aW5nIHRyYWNrIGVtaXRzIG11dGUsIGl0IGluZGljYXRlcyB0aGF0IHRoZSBkZXZpY2UgaXMgdW5hYmxlXG4gICAgICAgIC8vIHRvIHByb2R1Y2UgbWVkaWEuIEluIHRoaXMgY2FzZSB3ZSdsbCBuZWVkIHRvIHNpZ25hbCB3aXRoIHJlbW90ZSB0aGF0XG4gICAgICAgIC8vIHRoZSB0cmFjayBpcyBcIm11dGVkXCJcbiAgICAgICAgLy8gbm90ZSB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIExvY2FsVHJhY2subXV0ZSBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvXG4gICAgICAgIC8vIHRvdWNoIE1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZFxuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbmV3VHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgIH1cbiAgICAgIGxldCBwcm9jZXNzZWRUcmFjaztcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NvciAmJiBuZXdUcmFjaykge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3JFbGVtZW50KSB7XG4gICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQobmV3VHJhY2ssIHRoaXMucHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIHByb2Nlc3NvckVsZW1lbnQgaXRzZWxmIHN0YXlzIG11dGVkXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCB0aGlzLnByb2Nlc3Nvci5yZXN0YXJ0KHtcbiAgICAgICAgICAgIHRyYWNrOiBuZXdUcmFjayxcbiAgICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMucHJvY2Vzc29yRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb2Nlc3NlZFRyYWNrID0gdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2s7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbmRlciAmJiAoKF9hID0gdGhpcy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSAnY2xvc2VkJykge1xuICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2socHJvY2Vzc2VkVHJhY2sgIT09IG51bGwgJiYgcHJvY2Vzc2VkVHJhY2sgIT09IHZvaWQgMCA/IHByb2Nlc3NlZFRyYWNrIDogbmV3VHJhY2spO1xuICAgICAgfVxuICAgICAgLy8gaWYgYG5ld1RyYWNrYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3RpbmcgdHJhY2ssIHN0b3AgdGhlXG4gICAgICAvLyBvbGRlciB0cmFjayBqdXN0IGJlZm9yZSByZXBsYWNpbmcgaXRcbiAgICAgIGlmICghdGhpcy5wcm92aWRlZEJ5VXNlciAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICE9PSBuZXdUcmFjaykge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICAvLyBzeW5jIG11dGVkIHN0YXRlIHdpdGggdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG5ld2x5IHByb3ZpZGVkIHRyYWNrXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XG4gICAgICAgIC8vIHdoZW4gYSB2YWxpZCB0cmFjayBpcyByZXBsYWNlLCB3ZSdkIHdhbnQgdG8gc3RhcnQgcHJvZHVjaW5nXG4gICAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRlZmF1bHREaW1lbnNpb25zVGltZW91dDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChfdGhpcy5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGRpbWVuc2lvbnMgZm9yIGF1ZGlvIHRyYWNrcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3MpID09PSAnaU9TJykge1xuICAgICAgICAgIC8vIGJyb3dzZXJzIHJlcG9ydCB3cm9uZyBpbml0aWFsIHJlc29sdXRpb24gb24gaU9TLlxuICAgICAgICAgIC8vIHdoZW4gc2xpZ2h0bHkgZGVsYXlpbmcgdGhlIGNhbGwgdG8gLmdldFNldHRpbmdzKCksIHRoZSBjb3JyZWN0IHJlc29sdXRpb24gaXMgYmVpbmcgcmVwb3J0ZWRcbiAgICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRlZCA8IHRpbWVvdXQpIHtcbiAgICAgICAgICBjb25zdCBkaW1zID0gX3RoaXMuZGltZW5zaW9ucztcbiAgICAgICAgICBpZiAoZGltcykge1xuICAgICAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byBnZXQgdHJhY2sgZGltZW5zaW9ucyBhZnRlciB0aW1lb3V0Jyk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0RGV2aWNlSWQoZGV2aWNlSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkID09PSBkZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgPT09IHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgIC8vIHdoZW4gdHJhY2sgaXMgbXV0ZWQsIHVuZGVybHlpbmcgbWVkaWEgc3RyZWFtIHRyYWNrIGlzIHN0b3BwZWQgYW5kXG4gICAgICAvLyB3aWxsIGJlIHJlc3RhcnRlZCBsYXRlclxuICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICByZXR1cm4gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgRGV2aWNlSUQgb2YgdGhlIGRldmljZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIGZvciB0aGlzIHRyYWNrXG4gICAqL1xuICBnZXREZXZpY2VJZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGxldCBub3JtYWxpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gc2NyZWVuIHNoYXJlIGRvZXNuJ3QgaGF2ZSBhIHVzYWJsZSBkZXZpY2UgaWRcbiAgICAgICAgaWYgKF90aGlzMi5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgZ3JvdXBJZFxuICAgICAgICB9ID0gX3RoaXMyLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBfdGhpczIua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbyA/ICdhdWRpb2lucHV0JyA6ICd2aWRlb2lucHV0JztcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSA/IERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5ub3JtYWxpemVEZXZpY2VJZChraW5kLCBkZXZpY2VJZCwgZ3JvdXBJZCkgOiBkZXZpY2VJZDtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldFRyYWNrTXV0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZChmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICByZXBsYWNlVHJhY2sodHJhY2ssIHVzZXJQcm92aWRlZE9yT3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIHJlcGxhY2UgYW4gdW5wdWJsaXNoZWQgdHJhY2snKTtcbiAgICAgIH1cbiAgICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjaztcbiAgICAgIGxldCBzdG9wUHJvY2Vzc29yO1xuICAgICAgaWYgKHR5cGVvZiB1c2VyUHJvdmlkZWRPck9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucztcbiAgICAgIH0gZWxzZSBpZiAodXNlclByb3ZpZGVkT3JPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlclByb3ZpZGVkVHJhY2sgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnMudXNlclByb3ZpZGVkVHJhY2s7XG4gICAgICAgIHN0b3BQcm9jZXNzb3IgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnMuc3RvcFByb2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvdmlkZWRCeVVzZXIgPSB1c2VyUHJvdmlkZWRUcmFjayAhPT0gbnVsbCAmJiB1c2VyUHJvdmlkZWRUcmFjayAhPT0gdm9pZCAwID8gdXNlclByb3ZpZGVkVHJhY2sgOiB0cnVlO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlcGxhY2UgTWVkaWFTdHJlYW1UcmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sodHJhY2spO1xuICAgICAgLy8gdGhpcyBtdXN0IGJlIHN5bmNlZCAqYWZ0ZXIqIHNldHRpbmcgbWVkaWFTdHJlYW1UcmFjayBhYm92ZSwgc2luY2UgaXQgcmVsaWVzXG4gICAgICAvLyBvbiB0aGUgcHJldmlvdXMgc3RhdGUgaW4gb3JkZXIgdG8gY2xlYW51cFxuICAgICAgaWYgKHN0b3BQcm9jZXNzb3IgJiYgdGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICByZXN0YXJ0KGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnJlc3RhcnRMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghY29uc3RyYWludHMpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHRoaXMuX2NvbnN0cmFpbnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRldmljZUlkLFxuICAgICAgICAgICAgZmFjaW5nTW9kZVxuICAgICAgICAgIH0gPSBjb25zdHJhaW50cyxcbiAgICAgICAgICBvdGhlckNvbnN0cmFpbnRzID0gX19yZXN0KGNvbnN0cmFpbnRzLCBbXCJkZXZpY2VJZFwiLCBcImZhY2luZ01vZGVcIl0pO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyB0cmFjayB3aXRoIGNvbnN0cmFpbnRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgY29uc3RyYWludHNcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IHtcbiAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgdmlkZW86IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICBzdHJlYW1Db25zdHJhaW50cy52aWRlbyA9IGRldmljZUlkIHx8IGZhY2luZ01vZGUgPyB7XG4gICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgIGZhY2luZ01vZGVcbiAgICAgICAgICB9IDogdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyA9IGRldmljZUlkID8ge1xuICAgICAgICAgICAgZGV2aWNlSWRcbiAgICAgICAgICB9IDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBzdGVwcyBhcmUgZHVwbGljYXRlZCBmcm9tIHNldE1lZGlhU3RyZWFtVHJhY2sgYmVjYXVzZSB3ZSBtdXN0IHN0b3BcbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRyYWNrcyBiZWZvcmUgbmV3IHRyYWNrcyBjYW4gYmUgYWNxdWlyZWRcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAvLyBvbiBTYWZhcmksIHRoZSBvbGQgYXVkaW8gdHJhY2sgbXVzdCBiZSBzdG9wcGVkIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjcXVpcmVcbiAgICAgICAgLy8gdGhlIG5ldyB0cmFjaywgb3RoZXJ3aXNlIHRoZSBuZXcgdHJhY2sgd2lsbCBzdG9wIHdpdGhcbiAgICAgICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICAvLyBjcmVhdGUgbmV3IHRyYWNrIGFuZCBhdHRhY2hcbiAgICAgICAgY29uc3QgbWVkaWFTdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShzdHJlYW1Db25zdHJhaW50cyk7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICAgIHlpZWxkIG5ld1RyYWNrLmFwcGx5Q29uc3RyYWludHMob3RoZXJDb25zdHJhaW50cyk7XG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZS1hY3F1aXJlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrKTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsbHlTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgd2FzIHN0b3BwZWQgZHVyaW5nIGEgcmVzdGFydCwgc3RvcHBpbmcgcmVzdGFydGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgXCIuY29uY2F0KHRoaXMua2luZCwgXCIgdHJhY2sgXCIpLmNvbmNhdChtdXRlZCA/ICdtdXRlZCcgOiAndW5tdXRlZCcpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGlmICh0aGlzLmlzTXV0ZWQgPT09IG11dGVkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICB9XG4gIGdldCBuZWVkc1JlQWNxdWlzaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSAhPT0gJ2xpdmUnIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2subXV0ZWQgfHwgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fCB0aGlzLnJlYWNxdWlyZVRyYWNrO1xuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ2aXNpYmlsaXR5IGNoYW5nZWQsIGlzIGluIEJhY2tncm91bmQ6IFwiLmNvbmNhdCh0aGlzLmlzSW5CYWNrZ3JvdW5kKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJhY2sgbmVlZHMgdG8gYmUgcmVhY3F1aXJlZCwgcmVzdGFydGluZyBcIi5jb25jYXQodGhpcy5zb3VyY2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gdHJ1ZTtcbiAgICBzdXBlci5zdG9wKCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAoX2EgPSB0aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICB0aGlzLnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogcGF1c2VzIHB1Ymxpc2hpbmcgdG8gdGhlIHNlcnZlciB3aXRob3V0IGRpc2FibGluZyB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFja1xuICAgKiB0aGlzIGlzIHVzZWQgdG8gZGlzcGxheSBhIHVzZXIncyBvd24gdmlkZW8gbG9jYWxseSB3aGlsZSBwYXVzaW5nIHB1Ymxpc2hpbmcgdG9cbiAgICogdGhlIHNlcnZlci5cbiAgICogdGhpcyBBUEkgaXMgdW5zdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIgZHVlIHRvIGEgYnVnXG4gICAqKi9cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybigndW5hYmxlIHRvIHBhdXNlIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcyk7XG4gICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICAgIGlmICgoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm5hbWUpID09PSAnU2FmYXJpJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTIuMCcpIDwgMCkge1xuICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODQ5MTFcbiAgICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigncGF1c2VVcHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcmVzdW1lIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgLy8gdGhpcyBvcGVyYXRpb24gaXMgbm9vcCBpZiBtZWRpYXN0cmVhbXRyYWNrIGlzIGFscmVhZHkgYmVpbmcgc2VudFxuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBMb2NhbFRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBTZW5kZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIHJldHVybiBzdGF0c1JlcG9ydDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIHByb2Nlc3NvciBvbiB0aGlzIHRyYWNrLlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIEBwYXJhbSBwcm9jZXNzb3JcbiAgICogQHBhcmFtIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocHJvY2Vzc29yKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzMy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfdGhpczMubG9nLmRlYnVnKCdzZXR0aW5nIHVwIHByb2Nlc3NvcicsIF90aGlzMy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzb3JFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChfdGhpczMua2luZCk7XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGtpbmQ6IF90aGlzMy5raW5kLFxuICAgICAgICAgICAgdHJhY2s6IF90aGlzMy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHByb2Nlc3NvckVsZW1lbnQsXG4gICAgICAgICAgICBhdWRpb0NvbnRleHQ6IF90aGlzMy5hdWRpb0NvbnRleHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoJ3Byb2Nlc3NvciBpbml0aWFsaXplZCcsIF90aGlzMy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBpZiAoX3RoaXMzLnByb2Nlc3Nvcikge1xuICAgICAgICAgICAgeWllbGQgX3RoaXMzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssIHByb2Nlc3NvckVsZW1lbnQpO1xuICAgICAgICAgIHByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHByb2Nlc3NvckVsZW1lbnQucGxheSgpLmNhdGNoKGVycm9yID0+IF90aGlzMy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBwbGF5IHByb2Nlc3NvciBlbGVtZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgICBfdGhpczMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICAgIF90aGlzMy5wcm9jZXNzb3JFbGVtZW50ID0gcHJvY2Vzc29yRWxlbWVudDtcbiAgICAgICAgICBpZiAoX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBfdGhpczMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgICAgICBpZiAoZWwgIT09IF90aGlzMy5wcm9jZXNzb3JFbGVtZW50ICYmIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KSB7XG4gICAgICAgICAgICAgICAgZGV0YWNoVHJhY2soX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgICAgICAgICAgYXR0YWNoVG9FbGVtZW50KF90aGlzMy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2ssIGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgKF9hID0gX3RoaXMzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2VUcmFjayhfdGhpczMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLmVtaXQoVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgX3RoaXMzLnByb2Nlc3Nvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBnZXRQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdHJhY2sgcHJvY2Vzc29yXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0b3BQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBsZXQga2VlcEVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFfdGhpczQucHJvY2Vzc29yKSByZXR1cm47XG4gICAgICAgIF90aGlzNC5sb2cuZGVidWcoJ3N0b3BwaW5nIHByb2Nlc3NvcicsIF90aGlzNC5sb2dDb250ZXh0KTtcbiAgICAgICAgKF9hID0gX3RoaXM0LnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgICAgeWllbGQgX3RoaXM0LnByb2Nlc3Nvci5kZXN0cm95KCk7XG4gICAgICAgIF90aGlzNC5wcm9jZXNzb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgha2VlcEVsZW1lbnQpIHtcbiAgICAgICAgICAoX2IgPSBfdGhpczQucHJvY2Vzc29yRWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZSgpO1xuICAgICAgICAgIF90aGlzNC5wcm9jZXNzb3JFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IG9yaWdpbmFsIHRyYWNrIGNvbnN0cmFpbnRzIGluIGNhc2UgdGhlIHByb2Nlc3NvciBjaGFuZ2VkIHRoZW1cbiAgICAgICAgeWllbGQgX3RoaXM0Ll9tZWRpYVN0cmVhbVRyYWNrLmFwcGx5Q29uc3RyYWludHMoX3RoaXM0Ll9jb25zdHJhaW50cyk7XG4gICAgICAgIC8vIGZvcmNlIHJlLXNldHRpbmcgb2YgdGhlIG1lZGlhU3RyZWFtVHJhY2sgb24gdGhlIHNlbmRlclxuICAgICAgICB5aWVsZCBfdGhpczQuc2V0TWVkaWFTdHJlYW1UcmFjayhfdGhpczQuX21lZGlhU3RyZWFtVHJhY2ssIHRydWUpO1xuICAgICAgICBfdGhpczQuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBMb2NhbEF1ZGlvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcbiAgLyoqXG4gICAqIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGVuaGFuY2VkIG5vaXNlIGNhbmNlbGxhdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZCBvbiB0aGlzIHRyYWNrXG4gICAqL1xuICBnZXQgZW5oYW5jZWROb2lzZUNhbmNlbGxhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIGxldCBhdWRpb0NvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuQXVkaW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuc3RvcE9uTXV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdHM7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJLcmlzcCBub2lzZSBmaWx0ZXIgZW5hYmxlZFwiLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMsIEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTiwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJEaXNhYmxlID0gKCkgPT4ge1xuICAgICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcIktyaXNwIG5vaXNlIGZpbHRlciBkaXNhYmxlZFwiLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMsIEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTiwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgbXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpc2FibGVkIHNwZWNpYWwgaGFuZGxpbmcgYXMgaXQgd2lsbCBjYXVzZSBCVCBoZWFkc2V0cyB0byBzd2l0Y2ggY29tbXVuaWNhdGlvbiBtb2Rlc1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmIHRoaXMuc3RvcE9uTXV0ZSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBtaWMgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgbWljcm9waG9uZSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxuICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5tdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgdW5tdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIudW5tdXRlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSB1bm11dGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXZpY2VIYXNDaGFuZ2VkID0gdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkICE9PSB1bndyYXBDb25zdHJhaW50KHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkKTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiAodGhpcy5zdG9wT25NdXRlIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJyB8fCBkZXZpY2VIYXNDaGFuZ2VkKSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWFjcXVpcmluZyBtaWMgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBjb25zdHJhaW50cztcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKHtcbiAgICAgICAgICBhdWRpbzogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgY29uc3RyYWludHMgPSBzdHJlYW1Db25zdHJhaW50cy5hdWRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KGNvbnN0cmFpbnRzKTtcbiAgICB9KTtcbiAgfVxuICByZXN0YXJ0KGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICByZXN0YXJ0OiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucmVzdGFydFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIF9zdXBlci5yZXN0YXJ0LmNhbGwodGhpcywgY29uc3RyYWludHMpO1xuICAgICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9KTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKCkge1xuICAgIGlmICghaXNXZWIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzUmVhY3ROYXRpdmUoKSAmJiAhdGhpcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignQXVkaW8gY29udGV4dCBuZWVkcyB0byBiZSBzZXQgb24gTG9jYWxBdWRpb1RyYWNrIGluIG9yZGVyIHRvIGVuYWJsZSBwcm9jZXNzb3JzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgLy8gUk4gd29uJ3QgaGF2ZSBvciB1c2UgQXVkaW9Db250ZXh0XG4gICAgICAgICAgYXVkaW9Db250ZXh0OiB0aGlzLmF1ZGlvQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yIFwiLmNvbmNhdChwcm9jZXNzb3IubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgeWllbGQgKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZS1say1rcmlzcC1ub2lzZS1maWx0ZXInLCB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUpO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc2FibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJywgdGhpcy5oYW5kbGVLcmlzcE5vaXNlRmlsdGVyRGlzYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMucHJvY2Vzc29yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgbGV0IGF1ZGlvU3RhdHM7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGF1ZGlvU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICByb3VuZFRyaXBUaW1lOiB2LnJvdW5kVHJpcFRpbWUsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXVkaW9TdGF0cztcbiAgICB9KTtcbiAgfVxuICBjaGVja0ZvclNpbGVuY2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBkZXRlY3RTaWxlbmNlKHRoaXMpO1xuICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdzaWxlbmNlIGRldGVjdGVkIG9uIGxvY2FsIGF1ZGlvIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1NpbGVuY2VEZXRlY3RlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhY2tJc1NpbGVudDtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBsb2dnZXJPcHRpb25zKSB7XG4gIHN3aXRjaCAobWVkaWFTdHJlYW1UcmFjay5raW5kKSB7XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbEF1ZGlvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCB1bmRlZmluZWQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxWaWRlb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihcInVuc3VwcG9ydGVkIHRyYWNrIHR5cGU6IFwiLmNvbmNhdChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpKTtcbiAgfVxufVxuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzMTY5ID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzNDMgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0czQzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0c1NjcmVlblNoYXJlID0gT2JqZWN0LnZhbHVlcyhTY3JlZW5TaGFyZVByZXNldHMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSA9IFtWaWRlb1ByZXNldHMuaDE4MCwgVmlkZW9QcmVzZXRzLmgzNjBdO1xuLyogQGludGVybmFsICovXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzID0gW1ZpZGVvUHJlc2V0czQzLmgxODAsIFZpZGVvUHJlc2V0czQzLmgzNjBdO1xuLyogQGludGVybmFsICovXG5jb25zdCBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyA9IGZyb21QcmVzZXQgPT4ge1xuICBjb25zdCBsYXllcnMgPSBbe1xuICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMixcbiAgICBmcHM6IGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlXG4gIH1dO1xuICByZXR1cm4gbGF5ZXJzLm1hcCh0ID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBuZXcgVmlkZW9QcmVzZXQoTWF0aC5mbG9vcihmcm9tUHJlc2V0LndpZHRoIC8gdC5zY2FsZVJlc29sdXRpb25Eb3duQnkpLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuaGVpZ2h0IC8gdC5zY2FsZVJlc29sdXRpb25Eb3duQnkpLCBNYXRoLm1heCgxNTAwMDAsIE1hdGguZmxvb3IoZnJvbVByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlIC8gKE1hdGgucG93KHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5LCAyKSAqICgoKF9hID0gZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDMwKSAvICgoX2IgPSB0LmZwcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMzApKSkpKSwgdC5mcHMsIGZyb21QcmVzZXQuZW5jb2RpbmcucHJpb3JpdHkpO1xuICB9KTtcbn07XG4vLyAvKipcbi8vICAqXG4vLyAgKiBAaW50ZXJuYWxcbi8vICAqIEBleHBlcmltZW50YWxcbi8vICAqL1xuLy8gY29uc3QgY29tcHV0ZURlZmF1bHRNdWx0aUNvZGVjU2ltdWxjYXN0RW5jb2RpbmdzID0gKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XG4vLyAgIC8vIHVzZSB2cDggYXMgYSBkZWZhdWx0XG4vLyAgIGNvbnN0IHZwOCA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoZmFsc2UsIHdpZHRoLCBoZWlnaHQpO1xuLy8gICBjb25zdCB2cDkgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjkgfTtcbi8vICAgY29uc3QgaDI2NCA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDEuMSB9O1xuLy8gICBjb25zdCBhdjEgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjcgfTtcbi8vICAgcmV0dXJuIHtcbi8vICAgICB2cDgsXG4vLyAgICAgdnA5LFxuLy8gICAgIGgyNjQsXG4vLyAgICAgYXYxLFxuLy8gICB9O1xuLy8gfTtcbmNvbnN0IHZpZGVvUmlkcyA9IFsncScsICdoJywgJ2YnXTtcbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9FbmNvZGluZztcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICB2aWRlb0VuY29kaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcmVlblNoYXJlRW5jb2Rpbmc7XG4gIH1cbiAgY29uc3QgdXNlU2ltdWxjYXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpbXVsY2FzdDtcbiAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjYWxhYmlsaXR5TW9kZTtcbiAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NvZGVjO1xuICBpZiAoIXZpZGVvRW5jb2RpbmcgJiYgIXVzZVNpbXVsY2FzdCAmJiAhc2NhbGFiaWxpdHlNb2RlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgLy8gd2hlbiB3ZSBhcmVuJ3Qgc2ltdWxjYXN0aW5nIG9yIHN2Yywgd2lsbCBuZWVkIHRvIHJldHVybiBhIHNpbmdsZSBlbmNvZGluZyB3aXRob3V0XG4gICAgLy8gY2FwcGluZyBiYW5kd2lkdGguIHdlIGFsd2F5cyByZXF1aXJlIGEgZW5jb2RpbmcgZm9yIGR5bmFjYXN0XG4gICAgcmV0dXJuIFt7fV07XG4gIH1cbiAgaWYgKCF2aWRlb0VuY29kaW5nKSB7XG4gICAgLy8gZmluZCB0aGUgcmlnaHQgZW5jb2RpbmcgYmFzZWQgb24gd2lkdGgvaGVpZ2h0XG4gICAgdmlkZW9FbmNvZGluZyA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgdmlkZW9Db2RlYyk7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygndXNpbmcgdmlkZW8gZW5jb2RpbmcnLCB2aWRlb0VuY29kaW5nKTtcbiAgfVxuICBjb25zdCBzb3VyY2VGcmFtZXJhdGUgPSB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgY29uc3Qgb3JpZ2luYWwgPSBuZXcgVmlkZW9QcmVzZXQod2lkdGgsIGhlaWdodCwgdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLCB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZSwgdmlkZW9FbmNvZGluZy5wcmlvcml0eSk7XG4gIGlmIChzY2FsYWJpbGl0eU1vZGUgJiYgaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICAgIGlmIChzbS5zcGF0aWFsID4gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NhbGFiaWxpdHlNb2RlOiBcIi5jb25jYXQoc2NhbGFiaWxpdHlNb2RlKSk7XG4gICAgfVxuICAgIC8vIEJlZm9yZSBNMTEzIGluIENocm9tZSwgZGVmaW5pbmcgbXVsdGlwbGUgZW5jb2RpbmdzIHdpdGggYW4gU1ZDIGNvZGVjIGluZGljYXRlZFxuICAgIC8vIHRoYXQgU1ZDIG1vZGUgc2hvdWxkIGJlIHVzZWQuIFNhZmFyaSBzdGlsbCB3b3JrcyB0aGlzIHdheS5cbiAgICAvLyBUaGlzIGlzIGEgYml0IGNvbmZ1c2luZyBidXQgaXMgZHVlIHRvIGhvdyBsaWJ3ZWJydGMgaW50ZXJwcmV0ZWQgdGhlIGVuY29kaW5ncyBmaWVsZFxuICAgIC8vIGJlZm9yZSBNMTEzLlxuICAgIC8vIEFubm91bmNlZCBoZXJlOiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2cvZGlzY3Vzcy13ZWJydGMvYy8tUVEzcHhybC1mdz9wbGk9MVxuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKGlzU2FmYXJpKCkgfHxcbiAgICAvLyBFdmVuIHRobyBSTiBydW5zIE0xMTQsIGl0IGRvZXMgbm90IHByb2R1Y2UgU1ZDIGxheWVycyB3aGVuIGEgc2luZ2xlIGVuY29kaW5nXG4gICAgLy8gaXMgcHJvdmlkZWQuIFNvIHdlJ2xsIHVzZSB0aGUgbGVnYWN5IFNWQyBzcGVjaWZpY2F0aW9uIGZvciBub3cuXG4gICAgLy8gVE9ETzogd2hlbiB3ZSB1cHN0cmVhbSBsaWJ3ZWJydGMsIHRoaXMgd2lsbCBuZWVkIGFkZGl0aW9uYWwgdmVyaWZpY2F0aW9uXG4gICAgaXNSZWFjdE5hdGl2ZSgpIHx8IChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdDaHJvbWUnICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbiwgJzExMycpIDwgMCkge1xuICAgICAgY29uc3QgYml0cmF0ZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAyIDogMztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICAgIC8vIGluIGxlZ2FjeSBTVkMsIHNjYWxlUmVzb2x1dGlvbkRvd25CeSBjYW5ub3QgYmUgc2V0XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKHtcbiAgICAgICAgICByaWQ6IHZpZGVvUmlkc1syIC0gaV0sXG4gICAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gTWF0aC5wb3coYml0cmF0ZXNSYXRpbywgaSksXG4gICAgICAgICAgbWF4RnJhbWVyYXRlOiBvcmlnaW5hbC5lbmNvZGluZy5tYXhGcmFtZXJhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBsZWdhY3kgU1ZDLCBzY2FsYWJpbGl0eU1vZGUgaXMgc2V0IG9ubHkgb24gdGhlIGZpcnN0IGVuY29kaW5nXG4gICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlID0gc2NhbGFiaWxpdHlNb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZ3MucHVzaCh7XG4gICAgICAgIG1heEJpdHJhdGU6IHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSxcbiAgICAgICAgbWF4RnJhbWVyYXRlOiBvcmlnaW5hbC5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgc2NhbGFiaWxpdHlNb2RlOiBzY2FsYWJpbGl0eU1vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHkpIHtcbiAgICAgIGVuY29kaW5nc1swXS5wcmlvcml0eSA9IG9yaWdpbmFsLmVuY29kaW5nLnByaW9yaXR5O1xuICAgICAgZW5jb2RpbmdzWzBdLm5ldHdvcmtQcmlvcml0eSA9IG9yaWdpbmFsLmVuY29kaW5nLnByaW9yaXR5O1xuICAgIH1cbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwidXNpbmcgc3ZjIGVuY29kaW5nXCIsIHtcbiAgICAgIGVuY29kaW5nc1xuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGluZ3M7XG4gIH1cbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcbiAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICB9XG4gIGxldCBwcmVzZXRzID0gW107XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcHJlc2V0cyA9IChfYSA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xuICB9IGVsc2Uge1xuICAgIHByZXNldHMgPSAoX2IgPSBzb3J0UHJlc2V0cyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9TaW11bGNhc3RMYXllcnMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfVxuICBsZXQgbWlkUHJlc2V0O1xuICBpZiAocHJlc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbG93UHJlc2V0ID0gcHJlc2V0c1swXTtcbiAgICBpZiAocHJlc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICBbLCBtaWRQcmVzZXRdID0gcHJlc2V0cztcbiAgICB9XG4gICAgLy8gTk9URTpcbiAgICAvLyAgIDEuIE9yZGVyaW5nIG9mIHRoZXNlIGVuY29kaW5ncyBpcyBpbXBvcnRhbnQuIENocm9tZSBzZWVtc1xuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXG4gICAgLy8gICAgICBTbyBlbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxuICAgIC8vICAgMi4gbGl2ZWtpdC1zZXJ2ZXIgdHJhbnNsYXRlcyByaWRzIGludG8gbGF5ZXJzLiBTbywgYWxsIGVuY29kaW5nc1xuICAgIC8vICAgICAgc2hvdWxkIGhhdmUgdGhlIGJhc2UgbGF5ZXIgYHFgIGFuZCB0aGVuIG1vcmUgYWRkZWRcbiAgICAvLyAgICAgIGJhc2VkIG9uIG90aGVyIGNvbmRpdGlvbnMuXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChzaXplID49IDk2MCAmJiBtaWRQcmVzZXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbbG93UHJlc2V0LCBtaWRQcmVzZXQsIG9yaWdpbmFsXSwgc291cmNlRnJhbWVyYXRlKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPj0gNDgwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdLCBzb3VyY2VGcmFtZXJhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW29yaWdpbmFsXSk7XG59XG5mdW5jdGlvbiBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3ModHJhY2ssIHZpZGVvQ29kZWMsIG9wdHMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAvLyBiYWNrdXBDb2RlYyBzaG91bGQgbm90IGJlIHRydWUgYW55bW9yZSwgZGVmYXVsdCBjb2RlYyBpcyBzZXQgaW4gTG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoXG4gIGlmICghb3B0cy5iYWNrdXBDb2RlYyB8fCBvcHRzLmJhY2t1cENvZGVjID09PSB0cnVlIHx8IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgPT09IG9wdHMudmlkZW9Db2RlYykge1xuICAgIC8vIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkXG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2aWRlb0NvZGVjICE9PSBvcHRzLmJhY2t1cENvZGVjLmNvZGVjKSB7XG4gICAgbGl2ZWtpdExvZ2dlci53YXJuKCdyZXF1ZXN0ZWQgYSBkaWZmZXJlbnQgY29kZWMgdGhhbiBzcGVjaWZpZWQgYXMgYmFja3VwJywge1xuICAgICAgc2VydmVyUmVxdWVzdGVkOiB2aWRlb0NvZGVjLFxuICAgICAgYmFja3VwOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjXG4gICAgfSk7XG4gIH1cbiAgb3B0cy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgLy8gdXNlIGJhY2t1cCBlbmNvZGluZyBzZXR0aW5nIGFzIHZpZGVvRW5jb2RpbmcgZm9yIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nXG4gIG9wdHMudmlkZW9FbmNvZGluZyA9IG9wdHMuYmFja3VwQ29kZWMuZW5jb2Rpbmc7XG4gIGNvbnN0IHNldHRpbmdzID0gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICBjb25zdCB3aWR0aCA9IChfYSA9IHNldHRpbmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IChfYyA9IHNldHRpbmdzLmhlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKF9kID0gdHJhY2suZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmhlaWdodDtcbiAgLy8gZGlzYWJsZSBzaW11bGNhc3QgZm9yIHNjcmVlbnNoYXJlIGJhY2t1cCBjb2RlYyBzaW5jZSBMMVR4IGlzIHVzZWQgYnkgcHJpbWFyeSBjb2RlY1xuICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgb3B0cy5zaW11bGNhc3QpIHtcbiAgICBvcHRzLnNpbXVsY2FzdCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0cyk7XG4gIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgY29kZWMpIHtcbiAgY29uc3QgcHJlc2V0cyA9IHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpO1xuICBsZXQge1xuICAgIGVuY29kaW5nXG4gIH0gPSBwcmVzZXRzWzBdO1xuICAvLyBoYW5kbGUgcG9ydHJhaXQgYnkgc3dhcHBpbmcgZGltZW5zaW9uc1xuICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgZW5jb2RpbmcgPSBwcmVzZXQuZW5jb2Rpbmc7XG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gcHJlc2V0cyBhcmUgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgdnA4IGFzIGEgY29kZWNcbiAgLy8gZm9yIG90aGVyIGNvZGVjcyB3ZSBhZGp1c3QgdGhlIG1heEJpdHJhdGUgaWYgbm8gc3BlY2lmaWMgdmlkZW9FbmNvZGluZyBoYXMgYmVlbiBwcm92aWRlZFxuICAvLyB1c2VycyBzaG91bGQgb3ZlcnJpZGUgdGhlc2Ugd2l0aCBvbmVzIHRoYXQgYXJlIG9wdGltaXplZCBmb3IgdGhlaXIgdXNlIGNhc2VcbiAgLy8gTk9URTogU1ZDIGNvZGVjIGJpdHJhdGVzIGFyZSBpbmNsdXNpdmUgb2YgYWxsIHNjYWxhYmlsaXR5IGxheWVycy4gd2hpbGVcbiAgLy8gYml0cmF0ZSBmb3Igbm9uLVNWQyBjb2RlY3MgZG9lcyBub3QgaW5jbHVkZSBvdGhlciBzaW11bGNhc3QgbGF5ZXJzLlxuICBpZiAoY29kZWMpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdhdjEnOlxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC44NTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBwcmVzZXRzU2NyZWVuU2hhcmU7XG4gIH1cbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gcHJlc2V0czQzO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKSB7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzKG9yaWdpbmFsKTtcbiAgfVxuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBvcmlnaW5hbDtcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDM7XG59XG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXG5mdW5jdGlvbiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBwcmVzZXRzLCBzb3VyY2VGcmFtZXJhdGUpIHtcbiAgY29uc3QgZW5jb2RpbmdzID0gW107XG4gIHByZXNldHMuZm9yRWFjaCgocHJlc2V0LCBpZHgpID0+IHtcbiAgICBpZiAoaWR4ID49IHZpZGVvUmlkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHJpZCA9IHZpZGVvUmlkc1tpZHhdO1xuICAgIGNvbnN0IGVuY29kaW5nID0ge1xuICAgICAgcmlkLFxuICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBNYXRoLm1heCgxLCBzaXplIC8gTWF0aC5taW4ocHJlc2V0LndpZHRoLCBwcmVzZXQuaGVpZ2h0KSksXG4gICAgICBtYXhCaXRyYXRlOiBwcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZVxuICAgIH07XG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlIHNvdXJjZUZyYW1lcmF0ZSBpcyB0aGUgaGlnaGVzdCBmcmFtZXJhdGUgYXBwbGllZCBhY3Jvc3MgYWxsIGxheWVycyBzbyB0aGF0IHRoZVxuICAgIC8vIG9yaWdpbmFsIGVuY29kaW5nIGRvZXNuJ3QgZ2V0IGJ1bXBlZCB1bmludGVudGlvbmFsbHkgYnkgYW55IG9mIHRoZSBvdGhlciBsYXllcnNcbiAgICBjb25zdCBtYXhGcmFtZXJhdGUgPSBzb3VyY2VGcmFtZXJhdGUgJiYgcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSA/IE1hdGgubWluKHNvdXJjZUZyYW1lcmF0ZSwgcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkgOiBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgIGlmIChtYXhGcmFtZXJhdGUpIHtcbiAgICAgIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IG1heEZyYW1lcmF0ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmcucHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgfSk7XG4gIC8vIFJOIGlvcyBzaW11bGNhc3QgcmVxdWlyZXMgYWxsIHNhbWUgZnJhbWVyYXRlcy5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSAmJiBnZXRSZWFjdE5hdGl2ZU9zKCkgPT09ICdpb3MnKSB7XG4gICAgbGV0IHRvcEZyYW1lcmF0ZSA9IHVuZGVmaW5lZDtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XG4gICAgICBpZiAoIXRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBub3RpZnlPbmNlID0gdHJ1ZTtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICE9IHRvcEZyYW1lcmF0ZSkge1xuICAgICAgICBpZiAobm90aWZ5T25jZSkge1xuICAgICAgICAgIG5vdGlmeU9uY2UgPSBmYWxzZTtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTaW11bGNhc3Qgb24gaU9TIFJlYWN0LU5hdGl2ZSByZXF1aXJlcyBhbGwgZW5jb2RpbmdzIHRvIHNoYXJlIHRoZSBzYW1lIGZyYW1lcmF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiU2V0dGluZyBmcmFtZXJhdGUgb2YgZW5jb2RpbmcgXFxcIlwiLmNvbmNhdCgoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBcIlxcXCIgdG8gXCIpLmNvbmNhdCh0b3BGcmFtZXJhdGUpKTtcbiAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gdG9wRnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzb3J0UHJlc2V0cyhwcmVzZXRzKSB7XG4gIGlmICghcHJlc2V0cykgcmV0dXJuO1xuICByZXR1cm4gcHJlc2V0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2Rpbmc6IGFFbmNcbiAgICB9ID0gYTtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZzogYkVuY1xuICAgIH0gPSBiO1xuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICByZXR1cm4gYUVuYy5tYXhGcmFtZXJhdGUgPiBiRW5jLm1heEZyYW1lcmF0ZSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2NhbGFiaWxpdHlNb2RlIHtcbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHNjYWxhYmlsaXR5TW9kZS5tYXRjaCgvXkwoXFxkKVQoXFxkKShofF9LRVl8X0tFWV9TSElGVCl7MCwxfSQvKTtcbiAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYWJpbGl0eSBtb2RlJyk7XG4gICAgfVxuICAgIHRoaXMuc3BhdGlhbCA9IHBhcnNlSW50KHJlc3VsdHNbMV0pO1xuICAgIHRoaXMudGVtcG9yYWwgPSBwYXJzZUludChyZXN1bHRzWzJdKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAzKSB7XG4gICAgICBzd2l0Y2ggKHJlc3VsdHNbM10pIHtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ19LRVknOlxuICAgICAgICBjYXNlICdfS0VZX1NISUZUJzpcbiAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHJlc3VsdHNbM107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gXCJMXCIuY29uY2F0KHRoaXMuc3BhdGlhbCwgXCJUXCIpLmNvbmNhdCh0aGlzLnRlbXBvcmFsKS5jb25jYXQoKF9hID0gdGhpcy5zdWZmaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjaykge1xuICAvLyBhIGZldyBvZiByZWFzb25zIHdlIGhhdmUgZGlmZmVyZW50IGRlZmF1bHQgcGF0aHM6XG4gIC8vIDEuIHdpdGhvdXQgdGhpcywgQ2hyb21lIHNlZW1zIHRvIGFnZ3Jlc3NpdmVseSByZXNpemUgdGhlIFNWQyB2aWRlbyBzdGF0aW5nIGBxdWFsaXR5LWxpbWl0YXRpb246IGJhbmR3aWR0aGAgZXZlbiB3aGVuIEJXIGlzbid0IGFuIGlzc3VlXG4gIC8vIDIuIHNpbmNlIHdlIGFyZSBvdmVycmlkaW5nIGNvbnRlbnRIaW50IHRvIG1vdGlvbiAodG8gd29ya2Fyb3VuZCBMMVQzIHB1Ymxpc2hpbmcpLCBpdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZGVncmFkYXRpb25QcmVmZXJlbmNlIHRvIGBiYWxhbmNlZGBcbiAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlIHx8IHRyYWNrLmNvbnN0cmFpbnRzLmhlaWdodCAmJiB1bndyYXBDb25zdHJhaW50KHRyYWNrLmNvbnN0cmFpbnRzLmhlaWdodCkgPj0gMTA4MCkge1xuICAgIHJldHVybiAnbWFpbnRhaW4tcmVzb2x1dGlvbic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdiYWxhbmNlZCc7XG4gIH1cbn1cblxuY29uc3QgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMgPSA1MDAwO1xuY2xhc3MgTG9jYWxWaWRlb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjayB7XG4gIGdldCBzZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRlcjtcbiAgfVxuICBzZXQgc2VuZGVyKHNlbmRlcikge1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgICBpZiAodGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UpIHtcbiAgICAgIHRoaXMuc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLlZpZGVvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gJ2JhbGFuY2VkJztcbiAgICB0aGlzLm1vbml0b3JTZW5kZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXRzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZ2V0IGF1ZGlvIHNlbmRlciBzdGF0cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHNNYXAgPSBuZXcgTWFwKHN0YXRzLm1hcChzID0+IFtzLnJpZCwgc10pKTtcbiAgICAgIGlmICh0aGlzLnByZXZTdGF0cykge1xuICAgICAgICBsZXQgdG90YWxCaXRyYXRlID0gMDtcbiAgICAgICAgc3RhdHNNYXAuZm9yRWFjaCgocywga2V5KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xuICAgICAgICAgIHRvdGFsQml0cmF0ZSArPSBjb21wdXRlQml0cmF0ZShzLCBwcmV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gdG90YWxCaXRyYXRlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0c01hcDtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmRlckxvY2sgPSBuZXcgXygpO1xuICB9XG4gIGdldCBpc1NpbXVsY2FzdCgpIHtcbiAgICBpZiAodGhpcy5zZW5kZXIgJiYgdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpLmVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIGlmICghaXNXZWIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzYXZlIG9yaWdpbmFsIGVuY29kaW5nc1xuICAgIC8vIFRPRE8gOiBtZXJnZSBzaW11bGNhc3QgdHJhY2tzIHN0YXRzXG4gICAgY29uc3QgcGFyYW1zID0gKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5lbmNvZGluZ3MgPSBwYXJhbXMuZW5jb2RpbmdzO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5mb3JFYWNoKHRyYWNrSW5mbyA9PiB7XG4gICAgICB0cmFja0luZm8ubWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG4gIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBwYXVzZVVwc3RyZWFtOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucGF1c2VVcHN0cmVhbVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgdmFyIF9kO1xuICAgICAgeWllbGQgX3N1cGVyLnBhdXNlVXBzdHJlYW0uY2FsbCh0aGlzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgeWllbGQgKF9kID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgcmVzdW1lVXBzdHJlYW06IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN1bWVVcHN0cmVhbVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgdmFyIF9kO1xuICAgICAgeWllbGQgX3N1cGVyLnJlc3VtZVVwc3RyZWFtLmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgZV8yID0ge1xuICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgbXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgY2FtZXJhIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICB1bm11dGU6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IHVubXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWFjcXVpcmluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICBzdXBlci5zZXRUcmFja011dGVkKG11dGVkKTtcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgfVxuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGNvbnN0IHZzID0ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHYuZnJhbWVzUGVyU2Vjb25kLFxuICAgICAgICAgICAgZnJhbWVzU2VudDogdi5mcmFtZXNTZW50LFxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIGJ5dGVzU2VudDogdi5ieXRlc1NlbnQsXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogdi5xdWFsaXR5TGltaXRhdGlvblJlYXNvbixcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zOiB2LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLFxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogdi5xdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzLFxuICAgICAgICAgICAgcmlkOiAoX2EgPSB2LnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdi5pZCxcbiAgICAgICAgICAgIHJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudDogdi5yZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQsXG4gICAgICAgICAgICB0YXJnZXRCaXRyYXRlOiB2LnRhcmdldEJpdHJhdGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvL8KgbG9jYXRlIHRoZSBhcHByb3ByaWF0ZSByZW1vdGUtaW5ib3VuZC1ydHAgaXRlbVxuICAgICAgICAgIGNvbnN0IHIgPSBzdGF0cy5nZXQodi5yZW1vdGVJZCk7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHZzLmppdHRlciA9IHIuaml0dGVyO1xuICAgICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xuICAgICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbXMucHVzaCh2cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gbWFrZSBzdXJlIGhpZ2hlc3QgcmVzIGxheWVyIGlzIGFsd2F5cyBmaXJzdFxuICAgICAgaXRlbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKChfYSA9IGIuZnJhbWVXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSAoKF9iID0gYS5mcmFtZVdpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0pO1xuICB9XG4gIHNldFB1Ymxpc2hpbmdRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBxID0gVmlkZW9RdWFsaXR5LkxPVzsgcSA8PSBWaWRlb1F1YWxpdHkuSElHSDsgcSArPSAxKSB7XG4gICAgICBxdWFsaXRpZXMucHVzaChuZXcgU3Vic2NyaWJlZFF1YWxpdHkoe1xuICAgICAgICBxdWFsaXR5OiBxLFxuICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHlcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIHB1Ymxpc2hpbmcgcXVhbGl0eS4gbWF4IHF1YWxpdHkgXCIuY29uY2F0KG1heFF1YWxpdHkpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhxdWFsaXRpZXMpO1xuICB9XG4gIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICBsZXQgY29uc3RyYWludHM7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7XG4gICAgICAgICAgdmlkZW86IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtQ29uc3RyYWludHMudmlkZW8gIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIGlmIChzYy5zZW5kZXIgJiYgKChfZCA9IHNjLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCk7XG4gICAgICAgICAgICB5aWVsZCBzYy5zZW5kZXIucmVwbGFjZVRyYWNrKHNjLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8zXzEpIHtcbiAgICAgICAgZV8zID0ge1xuICAgICAgICAgIGVycm9yOiBlXzNfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yXzEpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHNldFByb2Nlc3Nvcjoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnNldFByb2Nlc3NvclxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChwcm9jZXNzb3IpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBlXzQsIF9iLCBfYztcbiAgICAgICAgdmFyIF9kLCBfZTtcbiAgICAgICAgeWllbGQgX3N1cGVyLnNldFByb2Nlc3Nvci5jYWxsKF90aGlzLCBwcm9jZXNzb3IsIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KTtcbiAgICAgICAgaWYgKChfZCA9IF90aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgX2cgPSBfX2FzeW5jVmFsdWVzKF90aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9oOyBfaCA9IHlpZWxkIF9nLm5leHQoKSwgX2EgPSBfaC5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfYyA9IF9oLnZhbHVlO1xuICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgICAgICB5aWVsZCAoX2UgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZXBsYWNlVHJhY2soX3RoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgICAgICAgZV80ID0ge1xuICAgICAgICAgICAgICBlcnJvcjogZV80XzFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IF9nLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2cpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIHNldERlZ3JhZGF0aW9uUHJlZmVyZW5jZShwcmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gcHJlZmVyZW5jZTtcbiAgICAgIGlmICh0aGlzLnNlbmRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBkZWdyYWRhdGlvblByZWZlcmVuY2UgdG8gXCIuY29uY2F0KHByZWZlcmVuY2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICBwYXJhbXMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gcHJlZmVyZW5jZTtcbiAgICAgICAgICB0aGlzLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiZmFpbGVkIHRvIHNldCBkZWdyYWRhdGlvblByZWZlcmVuY2VcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0sIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkU2ltdWxjYXN0VHJhY2soY29kZWMsIGVuY29kaW5ncykge1xuICAgIGlmICh0aGlzLnNpbXVsY2FzdENvZGVjcy5oYXMoY29kZWMpKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcIlwiLmNvbmNhdChjb2RlYywgXCIgYWxyZWFkeSBhZGRlZCwgc2tpcHBpbmcgYWRkaW5nIHNpbXVsY2FzdCBjb2RlY1wiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0ge1xuICAgICAgY29kZWMsXG4gICAgICBtZWRpYVN0cmVhbVRyYWNrOiB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSxcbiAgICAgIHNlbmRlcjogdW5kZWZpbmVkLFxuICAgICAgZW5jb2RpbmdzXG4gICAgfTtcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5zZXQoY29kZWMsIHNpbXVsY2FzdENvZGVjSW5mbyk7XG4gICAgcmV0dXJuIHNpbXVsY2FzdENvZGVjSW5mbztcbiAgfVxuICBzZXRTaW11bGNhc3RUcmFja1NlbmRlcihjb2RlYywgc2VuZGVyKSB7XG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjKTtcbiAgICBpZiAoIXNpbXVsY2FzdENvZGVjSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyID0gc2VuZGVyO1xuICAgIC8vIGJyb3dzZXIgd2lsbCByZWVuYWJsZSBkaXNhYmxlZCBjb2RlYy9sYXllcnMgYWZ0ZXIgbmV3IGNvZGVjIGhhcyBiZWVuIHB1Ymxpc2hlZCxcbiAgICAvLyBzbyByZWZyZXNoIHN1YnNjcmliZWRDb2RlY3MgYWZ0ZXIgcHVibGlzaCBhIG5ldyBjb2RlY1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZENvZGVjcykge1xuICAgICAgICB0aGlzLnNldFB1Ymxpc2hpbmdDb2RlY3ModGhpcy5zdWJzY3JpYmVkQ29kZWNzKTtcbiAgICAgIH1cbiAgICB9LCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGNvZGVjcyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nLCByZXR1cm5zIG5ldyBjb2RlY3MgdGhhdCBoYXZlIG5vdCB5ZXRcbiAgICogYmVlbiBwdWJsaXNoZWRcbiAgICovXG4gIHNldFB1Ymxpc2hpbmdDb2RlY3MoY29kZWNzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgY29kZWNzXzEsIGNvZGVjc18xXzE7XG4gICAgICB2YXIgX2IsIGVfNSwgX2MsIF9kO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBjb2RlY3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY29kZWNzLFxuICAgICAgICBjdXJyZW50Q29kZWM6IHRoaXMuY29kZWNcbiAgICAgIH0pKTtcbiAgICAgIC8vIG9ubHkgZW5hYmxlIHNpbXVsY2FzdCBjb2RlYyBmb3IgcHJlZmVyZW5jZSBjb2RlYyBzZXR0ZWRcbiAgICAgIGlmICghdGhpcy5jb2RlYyAmJiBjb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWNzWzBdLnF1YWxpdGllcyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IGNvZGVjcztcbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfYSA9IHRydWUsIGNvZGVjc18xID0gX19hc3luY1ZhbHVlcyhjb2RlY3MpOyBjb2RlY3NfMV8xID0geWllbGQgY29kZWNzXzEubmV4dCgpLCBfYiA9IGNvZGVjc18xXzEuZG9uZSwgIV9iOyBfYSA9IHRydWUpIHtcbiAgICAgICAgICBfZCA9IGNvZGVjc18xXzEudmFsdWU7XG4gICAgICAgICAgX2EgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IF9kO1xuICAgICAgICAgIGlmICghdGhpcy5jb2RlYyB8fCB0aGlzLmNvZGVjID09PSBjb2RlYy5jb2RlYykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGNvZGVjLnF1YWxpdGllcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYy5jb2RlYyk7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInRyeSBzZXRQdWJsaXNoaW5nQ29kZWMgZm9yIFwiLmNvbmNhdChjb2RlYy5jb2RlYyksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICBzaW11bGNhc3RDb2RlY0luZm9cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvIHx8ICFzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcSBvZiBjb2RlYy5xdWFsaXRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICBuZXdDb2RlY3MucHVzaChjb2RlYy5jb2RlYyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2ltdWxjYXN0Q29kZWNJbmZvLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInRyeSBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyIFwiLmNvbmNhdChjb2RlYy5jb2RlYyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAgIHlpZWxkIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlciwgc2ltdWxjYXN0Q29kZWNJbmZvLmVuY29kaW5ncywgY29kZWMucXVhbGl0aWVzLCB0aGlzLnNlbmRlckxvY2ssIHRoaXMubG9nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV81XzEpIHtcbiAgICAgICAgZV81ID0ge1xuICAgICAgICAgIGVycm9yOiBlXzVfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9hICYmICFfYiAmJiAoX2MgPSBjb2RlY3NfMS5yZXR1cm4pKSB5aWVsZCBfYy5jYWxsKGNvZGVjc18xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdDb2RlY3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGxheWVycyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nXG4gICAqL1xuICBzZXRQdWJsaXNoaW5nTGF5ZXJzKHF1YWxpdGllcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyBwdWJsaXNoaW5nIGxheWVycycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBxdWFsaXRpZXNcbiAgICAgIH0pKTtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIgfHwgIXRoaXMuZW5jb2RpbmdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIodGhpcy5zZW5kZXIsIHRoaXMuZW5jb2RpbmdzLCBxdWFsaXRpZXMsIHRoaXMuc2VuZGVyTG9jaywgdGhpcy5sb2csIHRoaXMubG9nQ29udGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzZW5kZXIsIHNlbmRlckVuY29kaW5ncywgcXVhbGl0aWVzLCBzZW5kZXJMb2NrLCBsb2csIGxvZ0NvbnRleHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBzZW5kZXJMb2NrLmxvY2soKTtcbiAgICBsb2cuZGVidWcoJ3NldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XG4gICAgICBzZW5kZXIsXG4gICAgICBxdWFsaXRpZXMsXG4gICAgICBzZW5kZXJFbmNvZGluZ3NcbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuY29kaW5nc1xuICAgICAgfSA9IHBhcmFtcztcbiAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZ3MubGVuZ3RoICE9PSBzZW5kZXJFbmNvZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIGxvZy53YXJuKCdjYW5ub3Qgc2V0IHB1Ymxpc2hpbmcgbGF5ZXJzLCBlbmNvZGluZ3MgbWlzbWF0Y2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICAgIHNlbmRlckVuY29kaW5nc1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgY29uc3QgY2xvc2FibGVTcGF0aWFsID0gKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci52ZXJzaW9uLCAnMTMzJykgPiAwO1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgaWYgKGNsb3NhYmxlU3BhdGlhbCAmJiBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgICAgIC8vIHN2YyBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBlbmNvZGluZ3NbMF07XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgY29uc3QgbW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgbGV0IG1heFF1YWxpdHkgPSBWaWRlb1F1YWxpdHkkMS5PRkY7XG4gICAgICAgIHF1YWxpdGllcy5mb3JFYWNoKHEgPT4ge1xuICAgICAgICAgIGlmIChxLmVuYWJsZWQgJiYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eSQxLk9GRiB8fCBxLnF1YWxpdHkgPiBtYXhRdWFsaXR5KSkge1xuICAgICAgICAgICAgbWF4UXVhbGl0eSA9IHEucXVhbGl0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWF4UXVhbGl0eSA9PT0gVmlkZW9RdWFsaXR5JDEuT0ZGKSB7XG4gICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSkge1xuICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWVuY29kaW5nLmFjdGl2ZSB8fCBtb2RlLnNwYXRpYWwgIT09IG1heFF1YWxpdHkgKyAxKSB7XG4gICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxNb2RlID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzZW5kZXJFbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgICBtb2RlLnNwYXRpYWwgPSBtYXhRdWFsaXR5ICsgMTtcbiAgICAgICAgICBtb2RlLnN1ZmZpeCA9IG9yaWdpbmFsTW9kZS5zdWZmaXg7XG4gICAgICAgICAgaWYgKG1vZGUuc3BhdGlhbCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gbm8gc3VmZml4IGZvciBMMVR4XG4gICAgICAgICAgICBtb2RlLnN1ZmZpeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IG1vZGUudG9TdHJpbmcoKTtcbiAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSBNYXRoLnBvdygyLCAyIC0gbWF4UXVhbGl0eSk7XG4gICAgICAgICAgaWYgKHNlbmRlckVuY29kaW5nc1swXS5tYXhCaXRyYXRlKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gc2VuZGVyRW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAoZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ICogZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbXVsY2FzdCBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgbGV0IHJpZCA9IChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgaWYgKHJpZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJpZCA9ICdxJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChyaWQpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWFsaXR5ID0gcXVhbGl0aWVzLmZpbmQocSA9PiBxLnF1YWxpdHkgPT09IHF1YWxpdHkpO1xuICAgICAgICAgIGlmICghc3Vic2NyaWJlZFF1YWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBsYXllciBcIi5jb25jYXQoc3Vic2NyaWJlZFF1YWxpdHkucXVhbGl0eSwgXCIgdG8gXCIpLmNvbmNhdChlbmNvZGluZy5hY3RpdmUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnKSwgbG9nQ29udGV4dCk7XG4gICAgICAgICAgICAvLyBGaXJlRm94IGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBlbmNvZGluZy5hY3RpdmUgdG8gZmFsc2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxuICAgICAgICAgICAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhGcmFtZVJhdGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gNDtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gMTA7XG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEZyYW1lUmF0ZSA9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBlbmNvZGluZ3NcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVuY29kaW5nczogcGFyYW1zLmVuY29kaW5nc1xuICAgICAgICB9KSk7XG4gICAgICAgIHlpZWxkIHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKSB7XG4gIHN3aXRjaCAocmlkKSB7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICBjYXNlICdxJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbn1cbmZ1bmN0aW9uIHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyh3aWR0aCwgaGVpZ2h0LCBlbmNvZGluZ3MsIHN2Yykge1xuICAvLyBkZWZhdWx0IHRvIGEgc2luZ2xlIGxheWVyLCBIUVxuICBpZiAoIWVuY29kaW5ncykge1xuICAgIHJldHVybiBbbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0gsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJpdHJhdGU6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSldO1xuICB9XG4gIGlmIChzdmMpIHtcbiAgICAvLyBzdmMgbGF5ZXJzXG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGNvbnN0IGVuY29kaW5nU00gPSBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlO1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZ1NNKTtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBjb25zdCByZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAxLjUgOiAyO1xuICAgIGNvbnN0IGJpdHJhdGVzUmF0aW8gPSBzbS5zdWZmaXggPT0gJ2gnID8gMiA6IDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcbiAgICAgIGxheWVycy5wdXNoKG5ldyBWaWRlb0xheWVyKHtcbiAgICAgICAgcXVhbGl0eTogTWF0aC5taW4oVmlkZW9RdWFsaXR5LkhJR0gsIHNtLnNwYXRpYWwgLSAxKSAtIGksXG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBNYXRoLnBvdyhyZXNSYXRpbywgaSkpLFxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBNYXRoLnBvdyhyZXNSYXRpbywgaSkpLFxuICAgICAgICBiaXRyYXRlOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSA/IE1hdGguY2VpbChlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIE1hdGgucG93KGJpdHJhdGVzUmF0aW8sIGkpKSA6IDAsXG4gICAgICAgIHNzcmM6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdzLm1hcChlbmNvZGluZyA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qgc2NhbGUgPSAoX2EgPSBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgbGV0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQoKF9iID0gZW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKHtcbiAgICAgIHF1YWxpdHksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gc2NhbGUpLFxuICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwoaGVpZ2h0IC8gc2NhbGUpLFxuICAgICAgYml0cmF0ZTogKF9jID0gZW5jb2RpbmcubWF4Qml0cmF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCxcbiAgICAgIHNzcmM6IDBcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcbmNvbnN0IHJlbGlhYmxlRGF0YUNoYW5uZWwgPSAnX3JlbGlhYmxlJztcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XG52YXIgUENTdGF0ZTtcbihmdW5jdGlvbiAoUENTdGF0ZSkge1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJOZXdcIl0gPSAwXSA9IFwiTmV3XCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDFdID0gXCJDb25uZWN0ZWRcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gMl0gPSBcIkRpc2Nvbm5lY3RlZFwiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJSZWNvbm5lY3RpbmdcIl0gPSAzXSA9IFwiUmVjb25uZWN0aW5nXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNsb3NlZFwiXSA9IDRdID0gXCJDbG9zZWRcIjtcbn0pKFBDU3RhdGUgfHwgKFBDU3RhdGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkO1xuICB9XG4gIGdldCBwZW5kaW5nUmVjb25uZWN0KCkge1xuICAgIHJldHVybiAhIXRoaXMucmVjb25uZWN0VGltZW91dDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ0Y0NvbmZpZyA9IHt9O1xuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XG4gICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGZhbHNlO1xuICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuTmV3O1xuICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVycyA9IHt9O1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSAwO1xuICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgIC8qKiBrZWVwcyB0cmFjayBvZiBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaGFzIGJlZW4gdHJpZWQgKi9cbiAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDA7XG4gICAgLyoqIHNwZWNpZmllcyBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byByZXRyeSAqL1xuICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gMTtcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5uZWwgPSBfYSA9PiBfX2F3YWl0ZXIodGhpcywgW19hXSwgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCB7XG4gICAgICAgIGNoYW5uZWxcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gcmVsaWFibGVEYXRhQ2hhbm5lbCkge1xuICAgICAgICAgIF90aGlzLnJlbGlhYmxlRENTdWIgPSBjaGFubmVsO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwubGFiZWwgPT09IGxvc3N5RGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICBfdGhpcy5sb3NzeURDU3ViID0gY2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9nLmRlYnVnKFwib24gZGF0YSBjaGFubmVsIFwiLmNvbmNhdChjaGFubmVsLmlkLCBcIiwgXCIpLmNvbmNhdChjaGFubmVsLmxhYmVsKSwgX3RoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGNoYW5uZWwub25tZXNzYWdlID0gX3RoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVEYXRhTWVzc2FnZSA9IG1lc3NhZ2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNwZWN0IGluY29taW5nIGRhdGEgbWVzc2FnZSBvcmRlciBieSBwcm9jZXNzaW5nIG1lc3NhZ2UgZXZlbnRzIG9uZSBhZnRlciB0aGUgb3RoZXJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuZGF0YVByb2Nlc3NMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGRlY29kZVxuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBidWZmZXIgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgIGJ1ZmZlciA9IHlpZWxkIG1lc3NhZ2UuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCd1bnN1cHBvcnRlZCBkYXRhIHR5cGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHAgPSBEYXRhUGFja2V0LmZyb21CaW5hcnkobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgIGlmICgoKF9hID0gZHAudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYXNlKSA9PT0gJ3NwZWFrZXInKSB7XG4gICAgICAgICAgLy8gZGlzcGF0Y2ggc3BlYWtlciB1cGRhdGVzXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCBkcC52YWx1ZS52YWx1ZS5zcGVha2Vycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCgoX2IgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGFwcGx5VXNlckRhdGFDb21wYXQoZHAsIGRwLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgZHApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZURhdGFFcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgY2hhbm5lbEtpbmQgPSBjaGFubmVsLm1heFJldHJhbnNtaXRzID09PSAwID8gJ2xvc3N5JyA6ICdyZWxpYWJsZSc7XG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFcnJvckV2ZW50ICYmIGV2ZW50LmVycm9yKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9ID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwiRGF0YUNoYW5uZWwgZXJyb3Igb24gXCIuY29uY2F0KGNoYW5uZWxLaW5kLCBcIjogXCIpLmNvbmNhdChldmVudC5tZXNzYWdlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJVbmtub3duIERhdGFDaGFubmVsIGVycm9yIG9uIFwiLmNvbmNhdChjaGFubmVsS2luZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3cgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/IERhdGFQYWNrZXRfS2luZC5MT1NTWSA6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRTtcbiAgICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGNoYW5uZWxLaW5kKTtcbiAgICB9O1xuICAgIC8vIHdlYnNvY2tldCByZWNvbm5lY3QgYmVoYXZpb3IuIGlmIHdlYnNvY2tldCBpcyBpbnRlcnJ1cHRlZCwgYW5kIHRoZSBQZWVyQ29ubmVjdGlvblxuICAgIC8vIGNvbnRpbnVlcyB0byB3b3JrLCB3ZSBjYW4gcmVjb25uZWN0IHRvIHdlYnNvY2tldCB0byBjb250aW51ZSB0aGUgc2Vzc2lvblxuICAgIC8vIGFmdGVyIGEgbnVtYmVyIG9mIHJldHJpZXMsIHdlJ2xsIGNsb3NlIGFuZCBnaXZlIHVwIHBlcm1hbmVudGx5XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0ID0gKGNvbm5lY3Rpb24sIGRpc2Nvbm5lY3RSZWFzb24pID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy53YXJuKFwiXCIuY29uY2F0KGNvbm5lY3Rpb24sIFwiIGRpc2Nvbm5lY3RlZFwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID09PSAwKSB7XG4gICAgICAgIC8vIG9ubHkgcmVzZXQgc3RhcnQgdGltZSBvbiB0aGUgZmlyc3QgdHJ5XG4gICAgICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzY29ubmVjdCA9IGR1cmF0aW9uID0+IHtcbiAgICAgICAgdGhpcy5sb2cud2FybihcImNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsIFwiIGF0dGVtcHRzLCBcIikuY29uY2F0KGR1cmF0aW9uLCBcIm1zLiBnaXZpbmcgdXBcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydDtcbiAgICAgIGxldCBkZWxheSA9IHRoaXMuZ2V0TmV4dFJldHJ5RGVsYXkoe1xuICAgICAgICBlbGFwc2VkTXM6IGR1cmF0aW9uLFxuICAgICAgICByZXRyeUNvdW50OiB0aGlzLnJlY29ubmVjdEF0dGVtcHRzXG4gICAgICB9KTtcbiAgICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICBkaXNjb25uZWN0KGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvbm5lY3Rpb24gPT09IGxlYXZlUmVjb25uZWN0KSB7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicmVjb25uZWN0aW5nIGluIFwiLmNvbmNhdChkZWxheSwgXCJtc1wiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy50b2tlbiAmJiB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSB7XG4gICAgICAgIC8vIHRva2VuIG1heSBoYXZlIGJlZW4gcmVmcmVzaGVkLCB3ZSBkbyBub3Qgd2FudCB0byByZWNyZWF0ZSB0aGUgcmVnaW9uVXJsUHJvdmlkZXJcbiAgICAgICAgLy8gc2luY2UgdGhlIGN1cnJlbnQgZW5naW5lIG1heSBoYXZlIGluaGVyaXRlZCBhIHJlZ2lvbmFsIHVybFxuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRoaXMudG9rZW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoZGlzY29ubmVjdFJlYXNvbikuZmluYWxseSgoKSA9PiB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQpLCBkZWxheSk7XG4gICAgfTtcbiAgICB0aGlzLndhaXRGb3JSZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblJlc3RhcnRlZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMgPSBraW5kID0+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCk7XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RhdHVzICE9PSB0aGlzLmRjQnVmZmVyU3RhdHVzLmdldChraW5kKSkge1xuICAgICAgICB0aGlzLmRjQnVmZmVyU3RhdHVzLnNldChraW5kLCBzdGF0dXMpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pc0J1ZmZlclN0YXR1c0xvdyA9IGtpbmQgPT4ge1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgIGlmIChkYykge1xuICAgICAgICByZXR1cm4gZGMuYnVmZmVyZWRBbW91bnQgPD0gZGMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUgPSAoKSA9PiB7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBlbmdpbmUgaXMgY3VycmVudGx5IHJlY29ubmVjdGluZywgYXR0ZW1wdCBhIHJlY29ubmVjdCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYnJvd3NlciBzdGF0ZSBoYXMgY2hhbmdlZCB0byAnb25MaW5lJ1xuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gb3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5FbmdpbmUpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBTaWduYWxDbGllbnQodW5kZWZpbmVkLCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50LnNpZ25hbExhdGVuY3kgPSB0aGlzLm9wdGlvbnMuZXhwU2lnbmFsTGF0ZW5jeTtcbiAgICB0aGlzLnJlY29ubmVjdFBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQb2xpY3k7XG4gICAgdGhpcy5yZWdpc3Rlck9uTGluZUxpc3RlbmVyKCk7XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuZGNCdWZmZXJTdGF0dXMgPSBuZXcgTWFwKFtbRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlXSwgW0RhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZV1dKTtcbiAgICB0aGlzLmNsaWVudC5vblBhcnRpY2lwYW50VXBkYXRlID0gdXBkYXRlcyA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHVwZGF0ZXMpO1xuICAgIHRoaXMuY2xpZW50Lm9uQ29ubmVjdGlvblF1YWxpdHkgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uUm9vbVVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gcmVzcCA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHJlc3ApO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblNwZWFrZXJzQ2hhbmdlZCA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3RyZWFtU3RhdGVVcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXF1ZXN0UmVzcG9uc2UsIHJlc3BvbnNlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IChfYiA9IChfYSA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUsXG4gICAgICByb29tSUQ6IChfZCA9IChfYyA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mucm9vbSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNpZCxcbiAgICAgIHBhcnRpY2lwYW50OiAoX2YgPSAoX2UgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaWRlbnRpdHksXG4gICAgICBwSUQ6IChfaCA9IChfZyA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5zaWRcbiAgICB9O1xuICB9XG4gIGpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICB0aGlzLnNpZ25hbE9wdHMgPSBvcHRzO1xuICAgICAgdGhpcy5tYXhKb2luQXR0ZW1wdHMgPSBvcHRzLm1heFJldHJpZXM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmpvaW5BdHRlbXB0cyArPSAxO1xuICAgICAgICB0aGlzLnNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCk7XG4gICAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuY2xpZW50LmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSA9IGpvaW5SZXNwb25zZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHlpZWxkIHRoaXMuY29uZmlndXJlKGpvaW5SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIG9mZmVyXG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSB8fCBqb2luUmVzcG9uc2UuZmFzdFB1Ymxpc2gpIHtcbiAgICAgICAgICB0aGlzLm5lZ290aWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbiA9IGpvaW5SZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uO1xuICAgICAgICAvLyBlbWl0IHNpZ25hbCBjb25uZWN0ZWQgZXZlbnQgYWZ0ZXIgYSBzaG9ydCBkZWxheSB0byBhbGxvdyBmb3Igam9pbiByZXNwb25zZSB0byBiZSBwcm9jZXNzZWQgb24gcm9vbVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiQ291bGRuJ3QgY29ubmVjdCB0byBzZXJ2ZXIsIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMuam9pbkF0dGVtcHRzLCBcIiBvZiBcIikuY29uY2F0KHRoaXMubWF4Sm9pbkF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW5BdHRlbXB0cyA8IHRoaXMubWF4Sm9pbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNsb3NpbmcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwUGVlckNvbm5lY3Rpb25zKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICB0aGlzLnBjTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGRjQ2xlYW51cCA9IGRjID0+IHtcbiAgICAgICAgaWYgKCFkYykgcmV0dXJuO1xuICAgICAgICBkYy5jbG9zZSgpO1xuICAgICAgICBkYy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gbnVsbDtcbiAgICAgICAgZGMub25jbG9zZSA9IG51bGw7XG4gICAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XG4gICAgICAgIGRjLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBkYy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBkYy5vbm9wZW4gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLmxvc3N5REMpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XG4gICAgICBkY0NsZWFudXAodGhpcy5yZWxpYWJsZURDKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlRENTdWIpO1xuICAgICAgdGhpcy5sb3NzeURDID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb3NzeURDU3ViID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZURDID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICB9XG4gIGNsZWFudXBDbGllbnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgICB0aGlzLmNsaWVudC5yZXNldENhbGxiYWNrcygpO1xuICAgIH0pO1xuICB9XG4gIGFkZFRyYWNrKHJlcSkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXSkge1xuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCdhIHRyYWNrIHdpdGggdGhlIHNhbWUgSUQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF07XG4gICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdwdWJsaWNhdGlvbiBvZiBsb2NhbCB0cmFjayB0aW1lZCBvdXQsIG5vIHJlc3BvbnNlIGZyb20gc2VydmVyJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgIH0sIDEwMDAwKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdID0ge1xuICAgICAgICByZXNvbHZlOiBpbmZvID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGluZm8pO1xuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW5jZWxsZWQgcHVibGljYXRpb24gYnkgY2FsbGluZyB1bnB1Ymxpc2gnKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQWRkVHJhY2socmVxKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBzZW5kZXIgZnJvbSBQZWVyQ29ubmVjdGlvbiwgcmV0dXJuaW5nIHRydWUgaWYgaXQgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqIGFuZCBhIG5lZ290aWF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgKiBAcGFyYW0gc2VuZGVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVqZWN0XG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdmYWlsZWQgdG8gcmVtb3ZlIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVNdXRlU3RhdHVzKHRyYWNrU2lkLCBtdXRlZCkge1xuICAgIHRoaXMuY2xpZW50LnNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKTtcbiAgfVxuICBnZXQgZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yZWxpYWJsZURDU3ViKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZTtcbiAgfVxuICBnZXRDb25uZWN0ZWRTZXJ2ZXJBZGRyZXNzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHNldFJlZ2lvblVybFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHByb3ZpZGVyO1xuICB9XG4gIGNvbmZpZ3VyZShqb2luUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxuICAgICAgaWYgKHRoaXMucGNNYW5hZ2VyICYmIHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZDtcbiAgICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHRoaXMubWFrZVJUQ0NvbmZpZ3VyYXRpb24oam9pblJlc3BvbnNlKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gbmV3IFBDVHJhbnNwb3J0TWFuYWdlcihydGNDb25maWcsIGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeSwgdGhpcy5sb2dnZXJPcHRpb25zKTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5UcmFuc3BvcnRzQ3JlYXRlZCwgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLCB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uSWNlQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZSwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50LnNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uUHVibGlzaGVyT2ZmZXIgPSBvZmZlciA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50LnNlbmRPZmZlcihvZmZlcik7XG4gICAgICB9O1xuICAgICAgdGhpcy5wY01hbmFnZXIub25EYXRhQ2hhbm5lbCA9IHRoaXMuaGFuZGxlRGF0YUNoYW5uZWw7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblN0YXRlQ2hhbmdlID0gKGNvbm5lY3Rpb25TdGF0ZSwgcHVibGlzaGVyU3RhdGUsIHN1YnNjcmliZXJTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByaW1hcnkgUEMgc3RhdGUgY2hhbmdlZCBcIi5jb25jYXQoY29ubmVjdGlvblN0YXRlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgaWYgKFsnY2xvc2VkJywgJ2Rpc2Nvbm5lY3RlZCcsICdmYWlsZWQnXS5pbmNsdWRlcyhwdWJsaXNoZXJTdGF0ZSkpIHtcbiAgICAgICAgICAvLyByZXNldCBwdWJsaXNoZXIgY29ubmVjdGlvbiBwcm9taXNlXG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSB0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuTmV3O1xuICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEKSB7XG4gICAgICAgICAgLy8gb24gU2FmYXJpLCBQZWVyQ29ubmVjdGlvbiB3aWxsIHN3aXRjaCB0byAnZGlzY29ubmVjdGVkJyBkdXJpbmcgcmVuZWdvdGlhdGlvblxuICAgICAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncGVlcmNvbm5lY3Rpb24gZmFpbGVkJywgc3Vic2NyaWJlclN0YXRlID09PSAnZmFpbGVkJyA/IFJlY29ubmVjdFJlYXNvbi5SUl9TVUJTQ1JJQkVSX0ZBSUxFRCA6IFJlY29ubmVjdFJlYXNvbi5SUl9QVUJMSVNIRVJfRkFJTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZWN0IGNhc2VzIHdoZXJlIGJvdGggc2lnbmFsIGNsaWVudCBhbmQgcGVlciBjb25uZWN0aW9uIGFyZSBzZXZlcmVkIGFuZCBhc3N1bWUgdGhhdCB1c2VyIGhhcyBsb3N0IG5ldHdvcmsgY29ubmVjdGlvblxuICAgICAgICBjb25zdCBpc1NpZ25hbFNldmVyZWQgPSB0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCB8fCB0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gICAgICAgIGNvbnN0IGlzUENTZXZlcmVkID0gW1BDVHJhbnNwb3J0U3RhdGUuRkFJTEVELCBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NJTkcsIFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEXS5pbmNsdWRlcyhjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBpZiAoaXNTaWduYWxTZXZlcmVkICYmIGlzUENTZXZlcmVkICYmICF0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5PZmZsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblRyYWNrID0gZXYgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCBldi50cmFjaywgZXYuc3RyZWFtc1swXSwgZXYucmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIGlmICghc3VwcG9ydE9wdGlvbmFsRGF0YWNoYW5uZWwoKF9iID0gam9pblJlc3BvbnNlLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wcm90b2NvbCkpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpIHtcbiAgICAvLyBjb25maWd1cmUgc2lnbmFsaW5nIGNsaWVudFxuICAgIHRoaXMuY2xpZW50Lm9uQW5zd2VyID0gc2QgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgc2VydmVyIGFuc3dlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBSVENTZHBUeXBlOiBzZC50eXBlXG4gICAgICB9KSk7XG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5zZXRQdWJsaXNoZXJBbnN3ZXIoc2QpO1xuICAgIH0pO1xuICAgIC8vIGFkZCBjYW5kaWRhdGUgb24gdHJpY2tsZVxuICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnZ290IElDRSBjYW5kaWRhdGUgZnJvbSBwZWVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnBjTWFuYWdlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpO1xuICAgIH07XG4gICAgLy8gd2hlbiBzZXJ2ZXIgY3JlYXRlcyBhbiBvZmZlciBmb3IgdGhlIGNsaWVudFxuICAgIHRoaXMuY2xpZW50Lm9uT2ZmZXIgPSBzZCA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIoc2QpO1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEFuc3dlcihhbnN3ZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHJlcyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdHJhY2tQdWJsaXNoZWRSZXNwb25zZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBjaWQ6IHJlcy5jaWQsXG4gICAgICAgIHRyYWNrOiAoX2EgPSByZXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWRcbiAgICAgIH0pKTtcbiAgICAgIGlmICghdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF0pIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJtaXNzaW5nIHRyYWNrIHJlc29sdmVyIGZvciBcIi5jb25jYXQocmVzLmNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGNpZDogcmVzLmNpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVzb2x2ZVxuICAgICAgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgcmVzb2x2ZShyZXMudHJhY2spO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSByZXNwb25zZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCByZXNwb25zZSk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkID0gdHJhY2tTaWQgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCB0cmFja1NpZCk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vblRva2VuUmVmcmVzaCA9IHRva2VuID0+IHtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQsIG11dGVkKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgdHJhY2tTaWQsIG11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25MZWF2ZSA9IGxlYXZlID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdjbGllbnQgbGVhdmUgcmVxdWVzdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICByZWFzb246IGxlYXZlID09PSBudWxsIHx8IGxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZS5yZWFzb25cbiAgICAgIH0pKTtcbiAgICAgIGlmIChsZWF2ZS5yZWdpb25zICYmIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHJlZ2lvbnMnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhsZWF2ZS5yZWdpb25zKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobGVhdmUuYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgTGVhdmVSZXF1ZXN0X0FjdGlvbi5ESVNDT05ORUNUOlxuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIGxlYXZlID09PSBudWxsIHx8IGxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZS5yZWFzb24pO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMZWF2ZVJlcXVlc3RfQWN0aW9uLlJFQ09OTkVDVDpcbiAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIC8vIHJlY29ubmVjdCBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIG5leHQgYXR0ZW1wdFxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChsZWF2ZVJlY29ubmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRVNVTUU6XG4gICAgICAgICAgLy8gcmVjb25uZWN0IGltbWVkaWF0ZWx5IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbmV4dCBhdHRlbXB0XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIG1ha2VSVENDb25maWd1cmF0aW9uKHNlcnZlclJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucnRjQ29uZmlnKTtcbiAgICBpZiAoKF9hID0gdGhpcy5zaWduYWxPcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZTJlZUVuYWJsZWQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdFMkVFIC0gc2V0dGluZyB1cCB0cmFuc3BvcnRzIHdpdGggaW5zZXJ0YWJsZSBzdHJlYW1zJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIC8vICB0aGlzIG1ha2VzIHN1cmUgdGhhdCBubyBkYXRhIGlzIHNlbnQgYmVmb3JlIHRoZSB0cmFuc2Zvcm1zIGFyZSByZWFkeVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcnRjQ29uZmlnLmVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyA9IHRydWU7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBJQ0Ugc2VydmVycyBiZWZvcmUgY3JlYXRpbmcgUGVlckNvbm5lY3Rpb25cbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycyAmJiAhcnRjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgIHNlcnZlclJlc3BvbnNlLmljZVNlcnZlcnMuZm9yRWFjaChpY2VTZXJ2ZXIgPT4ge1xuICAgICAgICBjb25zdCBydGNJY2VTZXJ2ZXIgPSB7XG4gICAgICAgICAgdXJsczogaWNlU2VydmVyLnVybHNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGljZVNlcnZlci51c2VybmFtZSkgcnRjSWNlU2VydmVyLnVzZXJuYW1lID0gaWNlU2VydmVyLnVzZXJuYW1lO1xuICAgICAgICBpZiAoaWNlU2VydmVyLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgICBydGNJY2VTZXJ2ZXIuY3JlZGVudGlhbCA9IGljZVNlcnZlci5jcmVkZW50aWFsO1xuICAgICAgICB9XG4gICAgICAgIHJ0Y0ljZVNlcnZlcnMucHVzaChydGNJY2VTZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgICBydGNDb25maWcuaWNlU2VydmVycyA9IHJ0Y0ljZVNlcnZlcnM7XG4gICAgfVxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uICYmIHNlcnZlclJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb24uZm9yY2VSZWxheSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5FTkFCTEVEKSB7XG4gICAgICBydGNDb25maWcuaWNlVHJhbnNwb3J0UG9saWN5ID0gJ3JlbGF5JztcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5zZHBTZW1hbnRpY3MgPSAndW5pZmllZC1wbGFuJztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcnRjQ29uZmlnLmNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSA9ICdnYXRoZXJfY29udGludWFsbHknO1xuICAgIHJldHVybiBydGNDb25maWc7XG4gIH1cbiAgY3JlYXRlRGF0YUNoYW5uZWxzKCkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2xlYXIgb2xkIGRhdGEgY2hhbm5lbCBjYWxsYmFja3MgaWYgcmVjcmVhdGVcbiAgICBpZiAodGhpcy5sb3NzeURDKSB7XG4gICAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsaWFibGVEQykge1xuICAgICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IG51bGw7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBkYXRhIGNoYW5uZWxzXG4gICAgdGhpcy5sb3NzeURDID0gdGhpcy5wY01hbmFnZXIuY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwobG9zc3lEYXRhQ2hhbm5lbCwge1xuICAgICAgLy8gd2lsbCBkcm9wIG9sZGVyIHBhY2tldHMgdGhhdCBhcnJpdmVcbiAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICBtYXhSZXRyYW5zbWl0czogMFxuICAgIH0pO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKHJlbGlhYmxlRGF0YUNoYW5uZWwsIHtcbiAgICAgIG9yZGVyZWQ6IHRydWVcbiAgICB9KTtcbiAgICAvLyBhbHNvIGhhbmRsZSBtZXNzYWdlcyBvdmVyIHRoZSBwdWIgY2hhbm5lbCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgLy8gaGFuZGxlIGRhdGFjaGFubmVsIGVycm9yc1xuICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICAvLyBzZXQgdXAgZGMgYnVmZmVyIHRocmVzaG9sZCwgc2V0IHRvIDY0a0IgKG90aGVyd2lzZSAwIGJ5IGRlZmF1bHQpXG4gICAgdGhpcy5sb3NzeURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XG4gICAgdGhpcy5yZWxpYWJsZURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XG4gICAgLy8gaGFuZGxlIGJ1ZmZlciBhbW91bnQgbG93IGV2ZW50c1xuICAgIHRoaXMubG9zc3lEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgICB0aGlzLnJlbGlhYmxlREMub25idWZmZXJlZGFtb3VudGxvdyA9IHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3c7XG4gIH1cbiAgY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzQWRkVHJhY2soKSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBjb25zdCBzZW5kZXIgPSB5aWVsZCB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdSZXF1aXJlZCB3ZWJSVEMgQVBJcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIHN0b3JlIFJUQ1J0cFNlbmRlclxuICAgICAgaWYgKHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnQ2Fubm90IHN0cmVhbSBvbiB0aGlzIGRldmljZScpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xuICAgICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbXMucHVzaCh0cmFjay5tZWRpYVN0cmVhbSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICB0cmFjay5jb2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHtcbiAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknLFxuICAgICAgICBzdHJlYW1zXG4gICAgICB9O1xuICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgIH1cbiAgICAgIC8vIGFkZFRyYW5zY2VpdmVyIGZvciByZWFjdC1uYXRpdmUgaXMgYXN5bmMuIHdlYiBpcyBzeW5jaHJvbm91cywgYnV0IGF3YWl0IHdvbid0IGVmZmVjdCBpdC5cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0geWllbGQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2subWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seSdcbiAgICAgIH07XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgfVxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlcihzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgaWYgKCFvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJhY2suc2V0U2ltdWxjYXN0VHJhY2tTZW5kZXIob3B0cy52aWRlb0NvZGVjLCB0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVSVENSdHBTZW5kZXIodHJhY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrKTtcbiAgICB9KTtcbiAgfVxuICBhdHRlbXB0UmVjb25uZWN0KHJlYXNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBndWFyZCBmb3IgYXR0ZW1wdGluZyByZWNvbm5lY3Rpb24gbXVsdGlwbGUgdGltZXMgd2hpbGUgb25lIGF0dGVtcHQgaXMgc3RpbGwgbm90IGZpbmlzaGVkXG4gICAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0KSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignYWxyZWFkeSBhdHRlbXB0aW5nIHJlY29ubmVjdCwgcmV0dXJuaW5nIGVhcmx5JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVDb25uZWN0aW9uKSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5ESVNBQkxFRCB8fFxuICAgICAgLy8gc2lnbmFsaW5nIHN0YXRlIGNvdWxkIGNoYW5nZSB0byBjbG9zZWQgZHVlIHRvIGhhcmR3YXJlIHNsZWVwXG4gICAgICAvLyB0aG9zZSBjb25uZWN0aW9ucyBjYW5ub3QgYmUgcmVzdW1lZFxuICAgICAgKChfYyA9IChfYiA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3VycmVudFN0YXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBQQ1RyYW5zcG9ydFN0YXRlLk5FVykgPT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5mdWxsUmVjb25uZWN0T25OZXh0KSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdW1lQ29ubmVjdGlvbihyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzICs9IDE7XG4gICAgICAgIGxldCByZWNvdmVyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnJlY292ZXJhYmxlIGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAvLyB1bnJlY292ZXJhYmxlXG4gICAgICAgICAgcmVjb3ZlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghKGUgaW5zdGFuY2VvZiBTaWduYWxSZWNvbm5lY3RFcnJvcikpIHtcbiAgICAgICAgICAvLyBjYW5ub3QgcmVzdW1lXG4gICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3JlY29ubmVjdCcsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiY291bGQgbm90IHJlY292ZXIgY29ubmVjdGlvbiBhZnRlciBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cywgXCIgYXR0ZW1wdHMsIFwiKS5jb25jYXQoRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQsIFwibXMuIGdpdmluZyB1cFwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRSZXRyeURlbGF5KGNvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb25uZWN0UG9saWN5Lm5leHRSZXRyeURlbGF5SW5Ncyhjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdlbmNvdW50ZXJlZCBlcnJvciBpbiByZWNvbm5lY3QgcG9saWN5JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8vIGVycm9yIGluIHVzZXIgY29kZSB3aXRoIHByb3ZpZGVkIHJlY29ubmVjdCBwb2xpY3ksIHN0b3AgcmVjb25uZWN0aW5nXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdGFydENvbm5lY3Rpb24ocmVnaW9uVXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgICAgIC8vIHBlcm1hbmVudCBmYWlsdXJlLCBkb24ndCBhdHRlbXB0IHJlY29ubmVjdGlvblxuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB1cmwgb3IgdG9rZW4gbm90IHNhdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcInJlY29ubmVjdGluZywgYXR0ZW1wdDogXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGluZyk7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuaXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgICAgIGxldCBqb2luUmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnNpZ25hbE9wdHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2F0dGVtcHRlZCBjb25uZWN0aW9uIHJlc3RhcnQsIHdpdGhvdXQgc2lnbmFsIG9wdGlvbnMgcHJlc2VudCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW4gY2FzZSBhIHJlZ2lvblVybCBpcyBwYXNzZWQsIHRoZSByZWdpb24gVVJMIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmpvaW4ocmVnaW9uVXJsICE9PSBudWxsICYmIHJlZ2lvblVybCAhPT0gdm9pZCAwID8gcmVnaW9uVXJsIDogdGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMuc2lnbmFsT3B0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2ltdWxhdGVkIGZhaWx1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudC5zZXRSZWNvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICB5aWVsZCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XG4gICAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICAgIGlmICh0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoJ1NpZ25hbCBjb25uZWN0aW9uIGdvdCBzZXZlcmVkIGR1cmluZyByZWNvbm5lY3QnKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXRBdHRlbXB0cygpO1xuICAgICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG5leHRSZWdpb25VcmwgPSB5aWVsZCAoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgaWYgKG5leHRSZWdpb25VcmwpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKG5leHRSZWdpb25VcmwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBtb3JlIHJlZ2lvbnMgdG8gdHJ5IChvciB3ZSdyZSBub3Qgb24gY2xvdWQpXG4gICAgICAgICAgKF9jID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc2V0QXR0ZW1wdHMoKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy51cmwgfHwgIXRoaXMudG9rZW4pIHtcbiAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB1cmwgb3IgdG9rZW4gbm90IHNhdmVkJyk7XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIHB1Ymxpc2hlciByZWNvbm5lY3RcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBhbmQgc3Vic2NyaWJlciBjb25uZWN0aW9ucyB1bnNldCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuaW5mbyhcInJlc3VtaW5nIHNpZ25hbCBjb25uZWN0aW9uLCBhdHRlbXB0IFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN1bWluZyk7XG4gICAgICBsZXQgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgICByZXMgPSB5aWVsZCB0aGlzLmNsaWVudC5yZWNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMucGFydGljaXBhbnRTaWQsIHJlYXNvbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKGVycm9yLm1lc3NhZ2UsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdG9rZW4gbWlnaHQgYmUgZXhwaXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHRoaXMubWFrZVJUQ0NvbmZpZ3VyYXRpb24ocmVzKTtcbiAgICAgICAgdGhpcy5wY01hbmFnZXIudXBkYXRlQ29uZmlndXJhdGlvbihydGNDb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignRGlkIG5vdCByZWNlaXZlIHJlY29ubmVjdCByZXNwb25zZScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xuICAgICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2ltdWxhdGVkIGZhaWx1cmUnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnRyaWdnZXJJY2VSZXN0YXJ0KCk7XG4gICAgICB5aWVsZCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XG4gICAgICAvLyByZS1jaGVjayBzaWduYWwgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyBlbmdpbmUgYXMgcmVzdW1lZFxuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoJ1NpZ25hbCBjb25uZWN0aW9uIGdvdCBzZXZlcmVkIGR1cmluZyByZWNvbm5lY3QnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XG4gICAgICAvLyByZWNyZWF0ZSBwdWJsaXNoIGRhdGFjaGFubmVsIGlmIGl0J3MgaWQgaXMgbnVsbFxuICAgICAgLy8gKGZvciBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY4OClcbiAgICAgIGlmICgoKF9hID0gdGhpcy5yZWxpYWJsZURDKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJyAmJiB0aGlzLnJlbGlhYmxlREMuaWQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc3VtZSBzdWNjZXNzXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1lZCk7XG4gICAgfSk7XG4gIH1cbiAgd2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGltZW91dCwgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5lbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yUENSZWNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5SZWNvbm5lY3Rpbmc7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnd2FpdGluZyBmb3IgcGVlciBjb25uZWN0aW9uIHRvIHJlY29ubmVjdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBzbGVlcChtaW5SZWNvbm5lY3RXYWl0KTsgLy8gRklYTUUgc2V0VGltZW91dCBhZ2FpbiBub3QgaWRlYWwgZm9yIGEgY29ubmVjdGlvbiBjcml0aWNhbCBwYXRoXG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5lbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24odW5kZWZpbmVkLCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUT0RPIGRvIHdlIG5lZWQgYSBgZmFpbGVkYCBzdGF0ZSBoZXJlIGZvciB0aGUgUEM/XG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiY291bGQgbm90IGVzdGFibGlzaCBQQyBjb25uZWN0aW9uLCBcIi5jb25jYXQoZS5tZXNzYWdlKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGlzaFJwY1Jlc3BvbnNlKGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCwgcGF5bG9hZCwgZXJyb3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdycGNSZXNwb25zZScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBScGNSZXNwb25zZSh7XG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICB2YWx1ZTogZXJyb3IgPyB7XG4gICAgICAgICAgICAgIGNhc2U6ICdlcnJvcicsXG4gICAgICAgICAgICAgIHZhbHVlOiBlcnJvci50b1Byb3RvKClcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdwYXlsb2FkJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQgIT09IG51bGwgJiYgcGF5bG9hZCAhPT0gdm9pZCAwID8gcGF5bG9hZCA6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHB1Ymxpc2hScGNBY2soZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbZGVzdGluYXRpb25JZGVudGl0eV0sXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAncnBjQWNrJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY0Fjayh7XG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbXNnID0gcGFja2V0LnRvQmluYXJ5KCk7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgZG8gaGF2ZSBhIGRhdGEgY29ubmVjdGlvblxuICAgICAgeWllbGQgdGhpcy5lbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCk7XG4gICAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xuICAgICAgaWYgKGRjKSB7XG4gICAgICAgIGRjLnNlbmQobXNnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGtpbmQpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JCdWZmZXJTdGF0dXNMb3coa2luZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5pc0J1ZmZlclN0YXR1c0xvdyhraW5kKSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbkNsb3NpbmcgPSAoKSA9PiByZWplY3QoJ0VuZ2luZSBjbG9zZWQnKTtcbiAgICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uQ2xvc2luZyk7XG4gICAgICAgIHdoaWxlICghdGhpcy5kY0J1ZmZlclN0YXR1cy5nZXQoa2luZCkpIHtcbiAgICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgb25DbG9zaW5nKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKGtpbmRfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGxldCBzdWJzY3JpYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnN1YnNjcmliZXJQcmltYXJ5O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFfdGhpczIucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gc3Vic2NyaWJlciA/IF90aGlzMi5wY01hbmFnZXIuc3Vic2NyaWJlciA6IF90aGlzMi5wY01hbmFnZXIucHVibGlzaGVyO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnROYW1lID0gc3Vic2NyaWJlciA/ICdTdWJzY3JpYmVyJyA6ICdQdWJsaXNoZXInO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJcIi5jb25jYXQodHJhbnNwb3J0TmFtZSwgXCIgY29ubmVjdGlvbiBub3Qgc2V0XCIpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5lZWROZWdvdGlhdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXN1YnNjcmliZXIgJiYgIV90aGlzMi5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICBfdGhpczIuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gICAgICAgICAgbmVlZE5lZ290aWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5lZWROZWdvdGlhdGlvbiAmJiAhc3Vic2NyaWJlciAmJiAhX3RoaXMyLnBjTWFuYWdlci5wdWJsaXNoZXIuaXNJQ0VDb25uZWN0ZWQgJiYgX3RoaXMyLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkgIT09ICdjaGVja2luZycpIHtcbiAgICAgICAgICBuZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkTmVnb3RpYXRpb24pIHtcbiAgICAgICAgICAvLyBzdGFydCBuZWdvdGlhdGlvblxuICAgICAgICAgIF90aGlzMi5uZWdvdGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRDaGFubmVsID0gX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKCh0YXJnZXRDaGFubmVsID09PSBudWxsIHx8IHRhcmdldENoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldENoYW5uZWwucmVhZHlTdGF0ZSkgPT09ICdvcGVuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWl0IHVudGlsIElDRSBjb25uZWN0ZWRcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgX3RoaXMyLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgICAgd2hpbGUgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIDwgZW5kVGltZSkge1xuICAgICAgICAgIGlmICh0cmFuc3BvcnQuaXNJQ0VDb25uZWN0ZWQgJiYgKChfYSA9IF90aGlzMi5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3Vic2NyaWJlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiY291bGQgbm90IGVzdGFibGlzaCBcIi5jb25jYXQodHJhbnNwb3J0TmFtZSwgXCIgY29ubmVjdGlvbiwgc3RhdGU6IFwiKS5jb25jYXQodHJhbnNwb3J0LmdldElDRUNvbm5lY3Rpb25TdGF0ZSgpKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5lbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKGtpbmQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2U7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHZlcmlmeVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHByaW1hcnkgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBzaWduYWwgaXMgY29ubmVjdGVkXG4gICAgaWYgKCF0aGlzLmNsaWVudC53cyB8fCB0aGlzLmNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgbmVnb3RpYXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBvYnNlcnZlIHNpZ25hbCBzdGF0ZVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHJlamVjdChuZXcgTmVnb3RpYXRpb25FcnJvcignUEMgbWFuYWdlciBpcyBjbG9zZWQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnJlcXVpcmVQdWJsaXNoZXIoKTtcbiAgICAgICAgLy8gZG9uJ3QgbmVnb3RpYXRlIHdpdGhvdXQgYW55IHRyYW5zY2VpdmVycyBvciBkYXRhIGNoYW5uZWwsIGl0IHdpbGwgZ2VuZXJhdGUgc2RwIHdpdGhvdXQgaWNlIGZyYWcgdGhlbiBuZWdvdGlhdGUgZmFpbGVkXG4gICAgICAgIGlmICh0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkubGVuZ3RoID09IDAgJiYgIXRoaXMubG9zc3lEQyAmJiAhdGhpcy5yZWxpYWJsZURDKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlZCA9ICgpID0+IHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZW5naW5lIGRpc2Nvbm5lY3RlZCB3aGlsZSBuZWdvdGlhdGlvbiB3YXMgb25nb2luZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICByZWplY3QoJ2Nhbm5vdCBuZWdvdGlhdGUgb24gY2xvc2VkIGVuZ2luZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub24oRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcbiAgICAgICAgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLm9uY2UoUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsIHJ0cFR5cGVzID0+IHtcbiAgICAgICAgICBjb25zdCBydHBNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgcnRwVHlwZXMuZm9yRWFjaChydHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZWMgPSBydHAuY29kZWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChpc1ZpZGVvQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICAgIHJ0cE1hcC5zZXQocnRwLnBheWxvYWQsIGNvZGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLm5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTmVnb3RpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCduZWdvdGlhdGlvbicsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWIpIHtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5RENTdWI7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlRENTdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3MsIGxvY2FsVHJhY2tzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdzeW5jIHN0YXRlIGNhbm5vdCBiZSBzZW50IHdpdGhvdXQgcGVlciBjb25uZWN0aW9uIHNldHVwJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNBbnN3ZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldExvY2FsRGVzY3JpcHRpb24oKTtcbiAgICBjb25zdCBwcmV2aW91c09mZmVyID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlci5nZXRSZW1vdGVEZXNjcmlwdGlvbigpO1xuICAgIC8qIDEuIGF1dG9zdWJzY3JpYmUgb24sIHNvIHN1YnNjcmliZWQgdHJhY2tzID0gYWxsIHRyYWNrcyAtIHVuc3ViIHRyYWNrcyxcbiAgICAgICAgICBpbiB0aGlzIGNhc2UsIHdlIHNlbmQgdW5zdWIgdHJhY2tzLCBzbyBzZXJ2ZXIgYWRkIGFsbCB0cmFja3MgdG8gdGhpc1xuICAgICAgICAgIHN1YnNjcmliZSBwYyBhbmQgdW5zdWIgc3BlY2lhbCB0cmFja3MgZnJvbSBpdC5cbiAgICAgICAyLiBhdXRvc3Vic2NyaWJlIG9mZiwgd2Ugc2VuZCBzdWJzY3JpYmVkIHRyYWNrcy5cbiAgICAqL1xuICAgIGNvbnN0IGF1dG9TdWJzY3JpYmUgPSAoX2IgPSAoX2EgPSB0aGlzLnNpZ25hbE9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvU3Vic2NyaWJlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgIGNvbnN0IHRyYWNrU2lkcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IHRyYWNrU2lkc0Rpc2FibGVkID0gbmV3IEFycmF5KCk7XG4gICAgcmVtb3RlVHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgaWYgKHRyYWNrLmlzRGVzaXJlZCAhPT0gYXV0b1N1YnNjcmliZSkge1xuICAgICAgICB0cmFja1NpZHMucHVzaCh0cmFjay50cmFja1NpZCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYWNrLmlzRW5hYmxlZCkge1xuICAgICAgICB0cmFja1NpZHNEaXNhYmxlZC5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNsaWVudC5zZW5kU3luY1N0YXRlKG5ldyBTeW5jU3RhdGUoe1xuICAgICAgYW5zd2VyOiBwcmV2aW91c0Fuc3dlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICBzZHA6IHByZXZpb3VzQW5zd2VyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNBbnN3ZXIudHlwZVxuICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICBvZmZlcjogcHJldmlvdXNPZmZlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICBzZHA6IHByZXZpb3VzT2ZmZXIuc2RwLFxuICAgICAgICB0eXBlOiBwcmV2aW91c09mZmVyLnR5cGVcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgdHJhY2tTaWRzLFxuICAgICAgICBzdWJzY3JpYmU6ICFhdXRvU3Vic2NyaWJlLFxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrczogW11cbiAgICAgIH0pLFxuICAgICAgcHVibGlzaFRyYWNrczogZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8obG9jYWxUcmFja3MpLFxuICAgICAgZGF0YUNoYW5uZWxzOiB0aGlzLmRhdGFDaGFubmVsc0luZm8oKSxcbiAgICAgIHRyYWNrU2lkc0Rpc2FibGVkXG4gICAgfSkpO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBmYWlsTmV4dCgpIHtcbiAgICAvLyBkZWJ1Z2dpbmcgbWV0aG9kIHRvIGZhaWwgdGhlIG5leHQgcmVjb25uZWN0L3Jlc3VtZSBhdHRlbXB0XG4gICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IHRydWU7XG4gIH1cbiAgZGF0YUNoYW5uZWxzSW5mbygpIHtcbiAgICBjb25zdCBpbmZvcyA9IFtdO1xuICAgIGNvbnN0IGdldEluZm8gPSAoZGMsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKChkYyA9PT0gbnVsbCB8fCBkYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGMuaWQpICE9PSB1bmRlZmluZWQgJiYgZGMuaWQgIT09IG51bGwpIHtcbiAgICAgICAgaW5mb3MucHVzaChuZXcgRGF0YUNoYW5uZWxJbmZvKHtcbiAgICAgICAgICBsYWJlbDogZGMubGFiZWwsXG4gICAgICAgICAgaWQ6IGRjLmlkLFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1ksIHRydWUpLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsIHRydWUpLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgcmV0dXJuIGluZm9zO1xuICB9XG4gIGNsZWFyUmVjb25uZWN0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgY2xlYXJQZW5kaW5nUmVjb25uZWN0KCkge1xuICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gIH1cbiAgcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XG4gICAgfVxuICB9XG4gIGRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBTaWduYWxSZWNvbm5lY3RFcnJvciBleHRlbmRzIEVycm9yIHt9XG5mdW5jdGlvbiBzdXBwb3J0T3B0aW9uYWxEYXRhY2hhbm5lbChwcm90b2NvbCkge1xuICByZXR1cm4gcHJvdG9jb2wgIT09IHVuZGVmaW5lZCAmJiBwcm90b2NvbCA+IDEzO1xufVxuZnVuY3Rpb24gYXBwbHlVc2VyRGF0YUNvbXBhdChuZXdPYmosIG9sZE9iaikge1xuICBjb25zdCBwYXJ0aWNpcGFudElkZW50aXR5ID0gbmV3T2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPyBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA6IG9sZE9iai5wYXJ0aWNpcGFudElkZW50aXR5O1xuICBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIG9sZE9iai5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcy5sZW5ndGggIT09IDAgPyBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzIDogb2xkT2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IGRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgb2xkT2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IGRlc3RpbmF0aW9uSWRlbnRpdGllcztcbn1cblxuY2xhc3MgUmVnaW9uVXJsUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgdGhpcy5sYXN0VXBkYXRlQXQgPSAwO1xuICAgIHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUgPSAzMDAwO1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICAgIHRoaXMuc2VydmVyVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICB1cGRhdGVUb2tlbih0b2tlbikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICBpc0Nsb3VkKCkge1xuICAgIHJldHVybiBpc0Nsb3VkKHRoaXMuc2VydmVyVXJsKTtcbiAgfVxuICBnZXRTZXJ2ZXJVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyVXJsO1xuICB9XG4gIGdldE5leHRCZXN0UmVnaW9uVXJsKGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Nsb3VkKCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3JlZ2lvbiBhdmFpbGFiaWxpdHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIExpdmVLaXQgQ2xvdWQgZG9tYWlucycpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlZ2lvblNldHRpbmdzIHx8IERhdGUubm93KCkgLSB0aGlzLmxhc3RVcGRhdGVBdCA+IHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUpIHtcbiAgICAgICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IHlpZWxkIHRoaXMuZmV0Y2hSZWdpb25TZXR0aW5ncyhhYm9ydFNpZ25hbCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb25zTGVmdCA9IHRoaXMucmVnaW9uU2V0dGluZ3MucmVnaW9ucy5maWx0ZXIocmVnaW9uID0+ICF0aGlzLmF0dGVtcHRlZFJlZ2lvbnMuZmluZChhdHRlbXB0ZWQgPT4gYXR0ZW1wdGVkLnVybCA9PT0gcmVnaW9uLnVybCkpO1xuICAgICAgaWYgKHJlZ2lvbnNMZWZ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dFJlZ2lvbiA9IHJlZ2lvbnNMZWZ0WzBdO1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMucHVzaChuZXh0UmVnaW9uKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIm5leHQgcmVnaW9uOiBcIi5jb25jYXQobmV4dFJlZ2lvbi5yZWdpb24pKTtcbiAgICAgICAgcmV0dXJuIG5leHRSZWdpb24udXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRBdHRlbXB0cygpIHtcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMgPSBbXTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmV0Y2hSZWdpb25TZXR0aW5ncyhzaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3NSZXNwb25zZSA9IHlpZWxkIGZldGNoKFwiXCIuY29uY2F0KGdldENsb3VkQ29uZmlnVXJsKHRoaXMuc2VydmVyVXJsKSwgXCIvcmVnaW9uc1wiKSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KHRoaXMudG9rZW4pXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCByZWdpb25TZXR0aW5ncyA9IHlpZWxkIHJlZ2lvblNldHRpbmdzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiByZWdpb25TZXR0aW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiBcIi5jb25jYXQocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXNUZXh0KSwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSA/IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkIDogQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsIHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMocmVnaW9ucykge1xuICAgIHRoaXMucmVnaW9uU2V0dGluZ3MgPSByZWdpb25zO1xuICAgIHRoaXMubGFzdFVwZGF0ZUF0ID0gRGF0ZS5ub3coKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvdWRDb25maWdVcmwoc2VydmVyVXJsKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwucHJvdG9jb2wucmVwbGFjZSgnd3MnLCAnaHR0cCcpLCBcIi8vXCIpLmNvbmNhdChzZXJ2ZXJVcmwuaG9zdCwgXCIvc2V0dGluZ3NcIik7XG59XG5cbmNsYXNzIEJhc2VTdHJlYW1SZWFkZXIge1xuICBnZXQgaW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5mbztcbiAgfVxuICBjb25zdHJ1Y3RvcihpbmZvLCBzdHJlYW0sIHRvdGFsQnl0ZVNpemUpIHtcbiAgICB0aGlzLnJlYWRlciA9IHN0cmVhbTtcbiAgICB0aGlzLnRvdGFsQnl0ZVNpemUgPSB0b3RhbEJ5dGVTaXplO1xuICAgIHRoaXMuX2luZm8gPSBpbmZvO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XG4gIH1cbn1cbmNsYXNzIEJ5dGVTdHJlYW1SZWFkZXIgZXh0ZW5kcyBCYXNlU3RyZWFtUmVhZGVyIHtcbiAgaGFuZGxlQ2h1bmtSZWNlaXZlZChjaHVuaykge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gY2h1bmsuY29udGVudC5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGN1cnJlbnRQcm9ncmVzcyA9IHRoaXMudG90YWxCeXRlU2l6ZSA/IHRoaXMuYnl0ZXNSZWNlaXZlZCAvIHRoaXMudG90YWxCeXRlU2l6ZSA6IHVuZGVmaW5lZDtcbiAgICAoX2EgPSB0aGlzLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGN1cnJlbnRQcm9ncmVzcyk7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnJlYWRlci5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSB5aWVsZCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNodW5rUmVjZWl2ZWQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5jb250ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvcnNcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHJldHVybigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlYWRBbGwoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICBsZXQgY2h1bmtzID0gbmV3IFNldCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXModGhpcyksIF9mOyBfZiA9IHlpZWxkIF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgIGNodW5rcy5hZGQoY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2h1bmtzKTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRvIHJlYWQgY2h1bmtzIGZyb20gYSBSZWFkYWJsZVN0cmVhbSBhbmQgcHJvdmlkZSB0aGVtIGluIGEgc3RydWN0dXJlZCBmb3JtYXQuXG4gKi9cbmNsYXNzIFRleHRTdHJlYW1SZWFkZXIgZXh0ZW5kcyBCYXNlU3RyZWFtUmVhZGVyIHtcbiAgLyoqXG4gICAqIEEgVGV4dFN0cmVhbVJlYWRlciBpbnN0YW5jZSBjYW4gYmUgdXNlZCBhcyBhbiBBc3luY0l0ZXJhdG9yIHRoYXQgcmV0dXJucyB0aGUgZW50aXJlIHN0cmluZ1xuICAgKiB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkIHVwIHRvIHRoZSBjdXJyZW50IHBvaW50IGluIHRpbWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbmZvLCBzdHJlYW0sIHRvdGFsQ2h1bmtDb3VudCkge1xuICAgIHN1cGVyKGluZm8sIHN0cmVhbSwgdG90YWxDaHVua0NvdW50KTtcbiAgICB0aGlzLnJlY2VpdmVkQ2h1bmtzID0gbmV3IE1hcCgpO1xuICB9XG4gIGhhbmRsZUNodW5rUmVjZWl2ZWQoY2h1bmspIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaW5kZXggPSBiaWdJbnRUb051bWJlcihjaHVuay5jaHVua0luZGV4KTtcbiAgICBjb25zdCBwcmV2aW91c0NodW5rQXRJbmRleCA9IHRoaXMucmVjZWl2ZWRDaHVua3MuZ2V0KGluZGV4KTtcbiAgICBpZiAocHJldmlvdXNDaHVua0F0SW5kZXggJiYgcHJldmlvdXNDaHVua0F0SW5kZXgudmVyc2lvbiA+IGNodW5rLnZlcnNpb24pIHtcbiAgICAgIC8vIHdlIGhhdmUgYSBuZXdlciB2ZXJzaW9uIGFscmVhZHksIGRyb3BwaW5nIHRoZSBvbGQgb25lXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjZWl2ZWRDaHVua3Muc2V0KGluZGV4LCBjaHVuayk7XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGNodW5rLmNvbnRlbnQuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnRvdGFsQnl0ZVNpemUgPyB0aGlzLmJ5dGVzUmVjZWl2ZWQgLyB0aGlzLnRvdGFsQnl0ZVNpemUgOiB1bmRlZmluZWQ7XG4gICAgKF9hID0gdGhpcy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjdXJyZW50UHJvZ3Jlc3MpO1xuICB9XG4gIC8qKlxuICAgKiBBc3luYyBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB1c2FnZSBvZiBgZm9yIGF3YWl0Li4ub2ZgIHN5bnRheC5cbiAgICogWWllbGRzIHN0cnVjdHVyZWQgY2h1bmtzIGZyb20gdGhlIHN0cmVhbS5cbiAgICpcbiAgICovXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHlpZWxkIHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2h1bmtSZWNlaXZlZCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRlY29kZXIuZGVjb2RlKHZhbHVlLmNvbnRlbnQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvcnNcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHJldHVybigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlYWRBbGwoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICBsZXQgZmluYWxTdHJpbmcgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSBfX2FzeW5jVmFsdWVzKHRoaXMpLCBfZjsgX2YgPSB5aWVsZCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICBmaW5hbFN0cmluZyArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgZV8yID0ge1xuICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9lKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5hbFN0cmluZztcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBCYXNlU3RyZWFtV3JpdGVyIHtcbiAgY29uc3RydWN0b3Iod3JpdGFibGVTdHJlYW0sIGluZm8sIG9uQ2xvc2UpIHtcbiAgICB0aGlzLndyaXRhYmxlU3RyZWFtID0gd3JpdGFibGVTdHJlYW07XG4gICAgdGhpcy5kZWZhdWx0V3JpdGVyID0gd3JpdGFibGVTdHJlYW0uZ2V0V3JpdGVyKCk7XG4gICAgdGhpcy5vbkNsb3NlID0gb25DbG9zZTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG4gIHdyaXRlKGNodW5rKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFdyaXRlci53cml0ZShjaHVuayk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHlpZWxkIHRoaXMuZGVmYXVsdFdyaXRlci5jbG9zZSgpO1xuICAgICAgdGhpcy5kZWZhdWx0V3JpdGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAoX2EgPSB0aGlzLm9uQ2xvc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUZXh0U3RyZWFtV3JpdGVyIGV4dGVuZHMgQmFzZVN0cmVhbVdyaXRlciB7fVxuY2xhc3MgQnl0ZVN0cmVhbVdyaXRlciBleHRlbmRzIEJhc2VTdHJlYW1Xcml0ZXIge31cblxuY2xhc3MgUmVtb3RlVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwga2luZCwgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TXV0ZWQobXV0ZWQpIHtcbiAgICBpZiAodGhpcy5pc011dGVkICE9PSBtdXRlZCkge1xuICAgICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgICB0aGlzLmVtaXQobXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNZWRpYVN0cmVhbShzdHJlYW0pIHtcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhY2sgaXMgZmluaXNoZWRcbiAgICB0aGlzLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuICAgIGNvbnN0IG9uUmVtb3ZlVHJhY2sgPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgb25SZW1vdmVUcmFjayk7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmVyICYmICdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlci5wbGF5b3V0RGVsYXlIaW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgb25SZW1vdmVUcmFjayk7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5zdGFydE1vbml0b3IoKTtcbiAgICAvLyB1c2UgYGVuYWJsZWRgIG9mIHRyYWNrIHRvIGVuYWJsZSByZS11c2Ugb2YgdHJhbnNjZWl2ZXJcbiAgICBzdXBlci5lbmFibGUoKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcbiAgICAvLyB1c2UgYGVuYWJsZWRgIG9mIHRyYWNrIHRvIGVuYWJsZSByZS11c2Ugb2YgdHJhbnNjZWl2ZXJcbiAgICBzdXBlci5kaXNhYmxlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIFJUQ1N0YXRzUmVwb3J0IGZvciB0aGUgUmVtb3RlVHJhY2sncyB1bmRlcmx5aW5nIFJUQ1J0cFJlY2VpdmVyXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDU3RhdHNSZXBvcnRcbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZTxSVENTdGF0c1JlcG9ydD4gfCB1bmRlZmluZWRcbiAgICovXG4gIGdldFJUQ1N0YXRzUmVwb3J0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnJlY2VpdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gc2V0IGEgcGxheW91dCBkZWxheSAoaW4gc2Vjb25kcykgZm9yIHRoaXMgdHJhY2suXG4gICAqIEEgaGlnaGVyIHZhbHVlIGFsbG93cyBmb3IgbW9yZSBidWZmZXJpbmcgb2YgdGhlIHRyYWNrIGluIHRoZSBicm93c2VyXG4gICAqIGFuZCB3aWxsIHJlc3VsdCBpbiBhIGRlbGF5IG9mIG1lZGlhIGJlaW5nIHBsYXllZCBiYWNrIG9mIGBkZWxheUluU2Vjb25kc2BcbiAgICovXG4gIHNldFBsYXlvdXREZWxheShkZWxheUluU2Vjb25kcykge1xuICAgIGlmICh0aGlzLnJlY2VpdmVyKSB7XG4gICAgICBpZiAoJ3BsYXlvdXREZWxheUhpbnQnIGluIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5wbGF5b3V0RGVsYXlIaW50ID0gZGVsYXlJblNlY29uZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdQbGF5b3V0IGRlbGF5IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ0Nhbm5vdCBzZXQgcGxheW91dCBkZWxheSwgdHJhY2sgYWxyZWFkeSBlbmRlZCcpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5b3V0IGRlbGF5IChpbiBzZWNvbmRzKSBvZiB0aGlzIHRyYWNrLlxuICAgKi9cbiAgZ2V0UGxheW91dERlbGF5KCkge1xuICAgIGlmICh0aGlzLnJlY2VpdmVyKSB7XG4gICAgICBpZiAoJ3BsYXlvdXREZWxheUhpbnQnIGluIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ1BsYXlvdXQgZGVsYXkgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cud2FybignQ2Fubm90IGdldCBwbGF5b3V0IGRlbGF5LCB0cmFjayBhbHJlYWR5IGVuZGVkJyk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCF0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm1vbml0b3JSZWNlaXZlcigpLCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzU3luY2hyb25pemF0aW9uU291cmNlcygpKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyVGltZVN5bmNVcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJUaW1lU3luY1VwZGF0ZSgpIHtcbiAgICBjb25zdCBsb29wID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy50aW1lU3luY0hhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBsb29wKCkpO1xuICAgICAgY29uc3Qgc291cmNlcyA9IChfYSA9IHRoaXMucmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzKClbMF07XG4gICAgICBpZiAoc291cmNlcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgIHJ0cFRpbWVzdGFtcFxuICAgICAgICB9ID0gc291cmNlcztcbiAgICAgICAgaWYgKHJ0cFRpbWVzdGFtcCAmJiB0aGlzLnJ0cFRpbWVzdGFtcCAhPT0gcnRwVGltZXN0YW1wKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVGltZVN5bmNVcGRhdGUsIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJ0cFRpbWVzdGFtcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucnRwVGltZXN0YW1wID0gcnRwVGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBsb29wKCk7XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlQXVkaW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYXVkaW9Db250ZXh0LCBhdWRpb091dHB1dCwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5BdWRpbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMubW9uaXRvclJlY2VpdmVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gW107XG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIGZvciBhbGwgYXR0YWNoZWQgYXVkaW8gZWxlbWVudHNcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICB2YXIgX2E7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAoX2EgPSB0aGlzLmdhaW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodm9sdW1lLCAwLCAwLjEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwudm9sdW1lID0gdm9sdW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLl9zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50Vm9sdW1lID0gdm9sdW1lO1xuICB9XG4gIC8qKlxuICAgKiBnZXRzIHRoZSB2b2x1bWUgb2YgYXR0YWNoZWQgYXVkaW8gZWxlbWVudHMgKGxvdWRlc3QpXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQudm9sdW1lID4gaGlnaGVzdFZvbHVtZSkge1xuICAgICAgICBoaWdoZXN0Vm9sdW1lID0gZWxlbWVudC52b2x1bWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZ2hlc3RWb2x1bWU7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxzIHNldFNpbmtJZCBvbiBhbGwgYXR0YWNoZWQgZWxlbWVudHMsIGlmIHN1cHBvcnRlZFxuICAgKiBAcGFyYW0gZGV2aWNlSWQgYXVkaW8gb3V0cHV0IGRldmljZVxuICAgKi9cbiAgc2V0U2lua0lkKGRldmljZUlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2lua0lkID0gZGV2aWNlSWQ7XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLmF0dGFjaGVkRWxlbWVudHMubWFwKGVsbSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoZWxtKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIHJldHVybiBlbG0uc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBhdHRhY2goZWxlbWVudCkge1xuICAgIGNvbnN0IG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVsZW1lbnQuc2V0U2lua0lkKHRoaXMuc2lua0lkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYXVkaW8gY29udGV4dCBtYXBwaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQudm9sdW1lID0gMDtcbiAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdm9sdW1lIHNldHRpbmcgaXMgYmVpbmcgYXBwbGllZCB0byB0aGUgbmV3bHkgYXR0YWNoZWQgZWxlbWVudFxuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy5lbGVtZW50Vm9sdW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZGV0YWNoZWQ7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaCgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQgPSBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgYW55IGF0dGFjaGVkIGVsZW1lbnRzIGFmdGVyIGRldGFjaGluZywgY29ubmVjdCB3ZWJhdWRpbyB0byB0aGUgZmlyc3QgZWxlbWVudCB0aGF0J3MgbGVmdFxuICAgICAgLy8gZGlzY29ubmVjdCB3ZWJhdWRpbyBvdGhlcndpc2VcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXRhY2hlZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICBpZiAoYXVkaW9Db250ZXh0ICYmIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyhhdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHBhcmFtIHtBdWRpb05vZGVbXX0gbm9kZXMgLSBBbiBhcnJheSBvZiBXZWJBdWRpbyBub2Rlcy4gVGhlc2Ugbm9kZXMgc2hvdWxkIG5vdCBiZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciB3aGVuIHBhc3NlZCwgYXMgdGhlIHNkayB3aWxsIHRha2UgY2FyZSBvZiBjb25uZWN0aW5nIHRoZW0gaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheS5cbiAgICovXG4gIHNldFdlYkF1ZGlvUGx1Z2lucyhub2Rlcykge1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IG5vZGVzO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RXZWJBdWRpbyhjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICAvLyBAdHMtaWdub3JlIGF0dGFjaGVkIGVsZW1lbnRzIGFsd2F5cyBoYXZlIGEgc3JjT2JqZWN0IHNldFxuICAgIHRoaXMuc291cmNlTm9kZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZWxlbWVudC5zcmNPYmplY3QpO1xuICAgIGxldCBsYXN0Tm9kZSA9IHRoaXMuc291cmNlTm9kZTtcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGxhc3ROb2RlLmNvbm5lY3Qobm9kZSk7XG4gICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5nYWluTm9kZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIGxhc3ROb2RlLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XG4gICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGhpcy5lbGVtZW50Vm9sdW1lLCAwLCAwLjEpO1xuICAgIH1cbiAgICAvLyB0cnkgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGlmIGl0IGlzbid0IHJ1bm5pbmcgYWxyZWFkeVxuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgIGNvbnRleHQucmVzdW1lKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBuZXcgRXJyb3IoXCJBdWRpbyBDb250ZXh0IGNvdWxkbid0IGJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0V2ViQXVkaW8oKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2EgPSB0aGlzLmdhaW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgIChfYiA9IHRoaXMuc291cmNlTm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmdhaW5Ob2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRSZWNlaXZlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgcmVjZWl2ZXJTdGF0cztcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBjb25jZWFsZWRTYW1wbGVzOiB2LmNvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgICBjb25jZWFsbWVudEV2ZW50czogdi5jb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxlZFNhbXBsZXM6IHYuc2lsZW50Q29uY2VhbGVkU2FtcGxlcyxcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxtZW50RXZlbnRzOiB2LnNpbGVudENvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgICAgdG90YWxBdWRpb0VuZXJneTogdi50b3RhbEF1ZGlvRW5lcmd5LFxuICAgICAgICAgICAgdG90YWxTYW1wbGVzRHVyYXRpb246IHYudG90YWxTYW1wbGVzRHVyYXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuY2xhc3MgUmVtb3RlVmlkZW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5WaWRlbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudEluZm9zID0gW107XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSA9IHIoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG4gIH1cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXaGVuIHVzaW5nIGFkYXB0aXZlU3RyZWFtLCB5b3UgbmVlZCB0byB1c2UgcmVtb3RlVmlkZW9UcmFjay5hdHRhY2goKSB0byBhZGQgdGhlIHRyYWNrIHRvIGEgSFRNTFZpZGVvRWxlbWVudCwgb3RoZXJ3aXNlIHlvdXIgdmlkZW8gdHJhY2tzIG1pZ2h0IG5ldmVyIHN0YXJ0XG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgc3VwZXIuc2V0TXV0ZWQobXV0ZWQpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgLy8gZGV0YWNoIG9yIGF0dGFjaFxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gSXQncyBwb3NzaWJsZSBhdHRhY2ggaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIGFuIGVsZW1lbnQuIFdoZW4gdGhhdCdzXG4gICAgLy8gdGhlIGNhc2UsIHdlJ2Qgd2FudCB0byBhdm9pZCBhZGRpbmcgZHVwbGljYXRlIGVsZW1lbnRJbmZvc1xuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogT2JzZXJ2ZSBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcyB3aGVuIGFkYXB0aXZlIHN0cmVhbWluZy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbGVtZW50SW5mb3MucHVzaChlbGVtZW50SW5mbyk7XG4gICAgICBlbGVtZW50SW5mby5vYnNlcnZlKCk7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXG4gICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcbiAgICAgIC8vIHRoZSB0YWIgY29tZXMgaW50byBmb2N1cyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3Zpc2liaWxpdHkgcmVzaXplIG9ic2VydmVyIG5vdCB0cmlnZ2VyZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcCBvYnNlcnZpbmcgYW4gRWxlbWVudEluZm8gZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBlbGVtZW50SW5mb1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhlbGVtZW50SW5mbykge1xuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8gaWdub3JlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbyk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIGluZm8uc3RvcE9ic2VydmluZygpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gIT09IGVsZW1lbnRJbmZvKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGRldGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgIHJldHVybiBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGRldGFjaGVkRWxlbWVudHMgPSBzdXBlci5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkRWxlbWVudHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXREZWNvZGVySW1wbGVtZW50YXRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29kZXJJbXBsZW1lbnRhdGlvbjtcbiAgfVxuICBnZXRSZWNlaXZlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgcmVjZWl2ZXJTdGF0cztcbiAgICAgIGxldCBjb2RlY0lEID0gJyc7XG4gICAgICBsZXQgY29kZWNzID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XG4gICAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIGZyYW1lc0RlY29kZWQ6IHYuZnJhbWVzRGVjb2RlZCxcbiAgICAgICAgICAgIGZyYW1lc0Ryb3BwZWQ6IHYuZnJhbWVzRHJvcHBlZCxcbiAgICAgICAgICAgIGZyYW1lc1JlY2VpdmVkOiB2LmZyYW1lc1JlY2VpdmVkLFxuICAgICAgICAgICAgcGFja2V0c1JlY2VpdmVkOiB2LnBhY2tldHNSZWNlaXZlZCxcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgZGVjb2RlckltcGxlbWVudGF0aW9uOiB2LmRlY29kZXJJbXBsZW1lbnRhdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSAnY29kZWMnKSB7XG4gICAgICAgICAgY29kZWNzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjZWl2ZXJTdGF0cyAmJiBjb2RlY0lEICE9PSAnJyAmJiBjb2RlY3MuZ2V0KGNvZGVjSUQpKSB7XG4gICAgICAgIHJlY2VpdmVyU3RhdHMubWltZVR5cGUgPSBjb2RlY3MuZ2V0KGNvZGVjSUQpLm1pbWVUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gICAgfSk7XG4gIH1cbiAgc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHJldHVybjtcbiAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBsYXN0VmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuZWxlbWVudEluZm9zLnJlZHVjZSgocHJldiwgaW5mbykgPT4gTWF0aC5tYXgocHJldiwgaW5mby52aXNpYmlsaXR5Q2hhbmdlZEF0IHx8IDApLCAwKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kUGF1c2UgPSAoKF9iID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2VWaWRlb0luQmFja2dyb3VuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWVcbiAgICApID8gdGhpcy5pc0luQmFja2dyb3VuZCA6IGZhbHNlO1xuICAgIGNvbnN0IGlzUGlQTW9kZSA9IHRoaXMuZWxlbWVudEluZm9zLnNvbWUoaW5mbyA9PiBpbmZvLnBpY3R1cmVJblBpY3R1cmUpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMuZWxlbWVudEluZm9zLnNvbWUoaW5mbyA9PiBpbmZvLnZpc2libGUpICYmICFiYWNrZ3JvdW5kUGF1c2UgfHwgaXNQaVBNb2RlO1xuICAgIGlmICh0aGlzLmxhc3RWaXNpYmxlID09PSBpc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1Zpc2libGUgJiYgRGF0ZS5ub3coKSAtIGxhc3RWaXNpYmlsaXR5Q2hhbmdlIDwgUkVBQ1RJT05fREVMQVkpIHtcbiAgICAgIC8vIGRlbGF5IGhpZGRlbiBldmVudHNcbiAgICAgIENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH0sIFJFQUNUSU9OX0RFTEFZKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0VmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgaXNWaXNpYmxlLCB0aGlzKTtcbiAgfVxuICB1cGRhdGVEaW1lbnNpb25zKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBjb25zdCBwaXhlbERlbnNpdHkgPSB0aGlzLmdldFBpeGVsRGVuc2l0eSgpO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiB0aGlzLmVsZW1lbnRJbmZvcykge1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRXaWR0aCA9IGluZm8ud2lkdGgoKSAqIHBpeGVsRGVuc2l0eTtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50SGVpZ2h0ID0gaW5mby5oZWlnaHQoKSAqIHBpeGVsRGVuc2l0eTtcbiAgICAgIGlmIChjdXJyZW50RWxlbWVudFdpZHRoICsgY3VycmVudEVsZW1lbnRIZWlnaHQgPiBtYXhXaWR0aCArIG1heEhlaWdodCkge1xuICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRFbGVtZW50V2lkdGg7XG4gICAgICAgIG1heEhlaWdodCA9IGN1cnJlbnRFbGVtZW50SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKChfYSA9IHRoaXMubGFzdERpbWVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgPT09IG1heFdpZHRoICYmICgoX2IgPSB0aGlzLmxhc3REaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSA9PT0gbWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdERpbWVuc2lvbnMgPSB7XG4gICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICBoZWlnaHQ6IG1heEhlaWdodFxuICAgIH07XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5sYXN0RGltZW5zaW9ucywgdGhpcyk7XG4gIH1cbiAgZ2V0UGl4ZWxEZW5zaXR5KCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwaXhlbERlbnNpdHkgPSAoX2EgPSB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5waXhlbERlbnNpdHk7XG4gICAgaWYgKHBpeGVsRGVuc2l0eSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgIHJldHVybiBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgfSBlbHNlIGlmICghcGl4ZWxEZW5zaXR5KSB7XG4gICAgICAvLyB3aGVuIHVuc2V0LCB3ZSdsbCBwaWNrIGEgc2FuZSBkZWZhdWx0IGhlcmUuXG4gICAgICAvLyBmb3IgaGlnaGVyIHBpeGVsIGRlbnNpdHkgZGV2aWNlcyAobW9iaWxlIHBob25lcywgZXRjKSwgd2UnbGwgdXNlIDJcbiAgICAgIC8vIG90aGVyd2lzZSBpdCBkZWZhdWx0cyB0byAxXG4gICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgICAgaWYgKGRldmljZVBpeGVsUmF0aW8gPiAyKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXhlbERlbnNpdHk7XG4gIH1cbn1cbmNsYXNzIEhUTUxFbGVtZW50SW5mbyB7XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGlQIHx8IHRoaXMuaXNJbnRlcnNlY3Rpbmc7XG4gIH1cbiAgZ2V0IHBpY3R1cmVJblBpY3R1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaVA7XG4gIH1cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdmlzaWJsZSkge1xuICAgIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZCA9IGVudHJ5ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBpc0ludGVyc2VjdGluZ1xuICAgICAgfSA9IGVudHJ5O1xuICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0ludGVyc2VjdGluZztcbiAgICAgICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkVudGVyUGlQID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAoX2IgPSAoX2EgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2luZG93KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICAgICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XG4gICAgICAoX2MgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25MZWF2ZVBpUCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xuICAgICAgKF9hID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSB2aXNpYmxlICE9PSBudWxsICYmIHZpc2libGUgIT09IHZvaWQgMCA/IHZpc2libGUgOiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQpO1xuICAgIHRoaXMuaXNQaVAgPSBpc1dlYigpICYmIGlzRWxlbWVudEluUGlQKGVsZW1lbnQpO1xuICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IDA7XG4gIH1cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuICBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgb2JzZXJ2ZSgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBtYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSBjdXJyZW50IHZpc2libGUgc3RhdGUgb25jZSB3ZSBzdGFydCB0byBvYnNlcnZlXG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzRWxlbWVudEluVmlld3BvcnQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5oYW5kbGVSZXNpemUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50LmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gdGhpcy5vblZpc2liaWxpdHlDaGFuZ2VkO1xuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGdldFJlc2l6ZU9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uRW50ZXJQaVApO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICAgIChfYSA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FbnRlclBpUCk7XG4gICAgKF9jID0gKF9iID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpbmRvdykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxuICBzdG9wT2JzZXJ2aW5nKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgKF9hID0gZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIChfYiA9IGdldFJlc2l6ZU9ic2VydmVyKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgICAoX2MgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXInLCB0aGlzLm9uRW50ZXJQaVApO1xuICAgIChfZSA9IChfZCA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC53aW5kb3cpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRWxlbWVudEluUGlQKGVsKSB7XG4gIHZhciBfYSwgX2I7XG4gIC8vIFNpbXBsZSB2aWRlbyBQaVBcbiAgaWYgKGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50ID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIC8vIERvY3VtZW50IFBpUFxuICBpZiAoKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpbmRvdykgcmV0dXJuIGlzRWxlbWVudEluVmlld3BvcnQoZWwsIChfYiA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aW5kb3cpO1xuICByZXR1cm4gZmFsc2U7XG59XG4vLyBkb2VzIG5vdCBhY2NvdW50IGZvciBvY2NsdXNpb24gYnkgb3RoZXIgZWxlbWVudHMgb3Igb3BhY2l0eSBwcm9wZXJ0eVxuZnVuY3Rpb24gaXNFbGVtZW50SW5WaWV3cG9ydChlbCwgd2luKSB7XG4gIGNvbnN0IHZpZXdwb3J0V2luZG93ID0gd2luIHx8IHdpbmRvdztcbiAgbGV0IHRvcCA9IGVsLm9mZnNldFRvcDtcbiAgbGV0IGxlZnQgPSBlbC5vZmZzZXRMZWZ0O1xuICBjb25zdCB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gIGNvbnN0IHtcbiAgICBoaWRkZW5cbiAgfSA9IGVsO1xuICBjb25zdCB7XG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHdoaWxlIChlbC5vZmZzZXRQYXJlbnQpIHtcbiAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB0b3AgKz0gZWwub2Zmc2V0VG9wO1xuICAgIGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcbiAgfVxuICByZXR1cm4gdG9wIDwgdmlld3BvcnRXaW5kb3cucGFnZVlPZmZzZXQgKyB2aWV3cG9ydFdpbmRvdy5pbm5lckhlaWdodCAmJiBsZWZ0IDwgdmlld3BvcnRXaW5kb3cucGFnZVhPZmZzZXQgKyB2aWV3cG9ydFdpbmRvdy5pbm5lcldpZHRoICYmIHRvcCArIGhlaWdodCA+IHZpZXdwb3J0V2luZG93LnBhZ2VZT2Zmc2V0ICYmIGxlZnQgKyB3aWR0aCA+IHZpZXdwb3J0V2luZG93LnBhZ2VYT2Zmc2V0ICYmICFoaWRkZW4gJiYgZGlzcGxheSAhPT0gJ25vbmUnO1xufVxuXG5jbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihraW5kLCBpZCwgbmFtZSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWV0YWRhdGFNdXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmhhbmRsZU11dGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuTXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zID09PSBudWxsIHx8IGxvZ2dlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUHVibGljYXRpb24pO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gdGhpcy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMudHJhY2tTaWQgPSBpZDtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICAvLyBmb3J3YXJkIGV2ZW50c1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRoaXMpKTtcbiAgfVxuICBnZXQgaXNNdXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YU11dGVkO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGdldCBpc0VuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgfVxuICAvKipcbiAgICogYW4gW0F1ZGlvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYW4gYXVkaW8gdHJhY2tcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIGlmIChpc0F1ZGlvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogYW4gW1ZpZGVvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYSB2aWRlbyB0cmFja1xuICAgKi9cbiAgZ2V0IHZpZGVvVHJhY2soKSB7XG4gICAgaWYgKGlzVmlkZW9UcmFjayh0aGlzLnRyYWNrKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgdGhpcy50cmFja1NpZCA9IGluZm8uc2lkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gaW5mby5uYW1lO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suc291cmNlRnJvbVByb3RvKGluZm8uc291cmNlKTtcbiAgICB0aGlzLm1pbWVUeXBlID0gaW5mby5taW1lVHlwZTtcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIGluZm8ud2lkdGggPiAwKSB7XG4gICAgICB0aGlzLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBpbmZvLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGluZm8uaGVpZ2h0XG4gICAgICB9O1xuICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb24gPSBpbmZvLmVuY3J5cHRpb247XG4gICAgdGhpcy50cmFja0luZm8gPSBpbmZvO1xuICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGUgcHVibGljYXRpb24gaW5mbycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgaW5mb1xuICAgIH0pKTtcbiAgfVxufVxuKGZ1bmN0aW9uIChUcmFja1B1YmxpY2F0aW9uKSB7XG4gIChmdW5jdGlvbiAoU3Vic2NyaXB0aW9uU3RhdHVzKSB7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiRGVzaXJlZFwiXSA9IFwiZGVzaXJlZFwiO1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlN1YnNjcmliZWRcIl0gPSBcInN1YnNjcmliZWRcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJVbnN1YnNjcmliZWRcIl0gPSBcInVuc3Vic2NyaWJlZFwiO1xuICB9KShUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyB8fCAoVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMgPSB7fSkpO1xuICAoZnVuY3Rpb24gKFBlcm1pc3Npb25TdGF0dXMpIHtcbiAgICBQZXJtaXNzaW9uU3RhdHVzW1wiQWxsb3dlZFwiXSA9IFwiYWxsb3dlZFwiO1xuICAgIFBlcm1pc3Npb25TdGF0dXNbXCJOb3RBbGxvd2VkXCJdID0gXCJub3RfYWxsb3dlZFwiO1xuICB9KShUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyA9IHt9KSk7XG59KShUcmFja1B1YmxpY2F0aW9uIHx8IChUcmFja1B1YmxpY2F0aW9uID0ge30pKTtcblxuY2xhc3MgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBzdHJlYW1QYXVzZWQ7XG4gIH1cbiAgY29uc3RydWN0b3Ioa2luZCwgdGksIHRyYWNrLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnRyYWNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkKTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gICAgdGhpcy5zZXRUcmFjayh0cmFjayk7XG4gIH1cbiAgc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzTXV0ZWQoKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrLmlzTXV0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc011dGVkO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIHJldHVybiBzdXBlci5hdWRpb1RyYWNrO1xuICB9XG4gIGdldCB2aWRlb1RyYWNrKCkge1xuICAgIHJldHVybiBzdXBlci52aWRlb1RyYWNrO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBNdXRlIHRoZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgKi9cbiAgbXV0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tdXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVubXV0ZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgKi9cbiAgdW5tdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubXV0ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIG1lZGlhIHN0cmVhbSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvbiBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgKiBhbmQgc2lnbmFscyBcIm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBwYXVzZSB0aGUgc3RyZWFtIHdpdGhvdXQgcGF1c2luZyB0aGUgbG9jYWwgbWVkaWEgc3RyZWFtIHRyYWNrXG4gICAqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2VVcHN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIHNlbmRpbmcgdGhlIG1lZGlhIHN0cmVhbSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvbiB0byB0aGUgc2VydmVyIGFmdGVyIGEgY2FsbCB0byBbW3BhdXNlVXBzdHJlYW0oKV1dXG4gICAqIGFuZCBzaWduYWxzIFwidW5tdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50cyAodW5sZXNzIHRoZSB0cmFjayBpcyBleHBsaWNpdGx5IG11dGVkKVxuICAgKi9cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVVcHN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIGdldFRyYWNrRmVhdHVyZXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpc0F1ZGlvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy50cmFjay5nZXRTb3VyY2VUcmFja1NldHRpbmdzKCk7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGlmIChzZXR0aW5ncy5hdXRvR2FpbkNvbnRyb2wpIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0FVVE9fR0FJTl9DT05UUk9MKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5lY2hvQ2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9FQ0hPX0NBTkNFTExBVElPTik7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3Mubm9pc2VTdXBwcmVzc2lvbikge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9JU0VfU1VQUFJFU1NJT04pO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLmNoYW5uZWxDb3VudCAmJiBzZXR0aW5ncy5jaGFubmVsQ291bnQgPiAxKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9TVEVSRU8pO1xuICAgICAgfVxuICAgICAgaWYgKCEoKF9hID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHR4KSkge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9fRFRYKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYWNrLmVuaGFuY2VkTm9pc2VDYW5jZWxsYXRpb24pIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTik7XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShmZWF0dXJlcy52YWx1ZXMoKSk7XG4gICAgfSBlbHNlIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBsb2NhbCB2aWRlbyBhbmQgYXVkaW8gdHJhY2sgYXQgdGhlIHNhbWUgdGltZS4gV2hlbiBhY3F1aXJpbmcgYm90aFxuICogYXVkaW8gYW5kIHZpZGVvIHRyYWNrcyB0b2dldGhlciwgaXQnbGwgZGlzcGxheSBhIHNpbmdsZSBwZXJtaXNzaW9uIHByb21wdCB0b1xuICogdGhlIHVzZXIgaW5zdGVhZCBvZiB0d28gc2VwYXJhdGUgb25lcy5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVHJhY2tzKG9wdGlvbnMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBvcHRpb25zID0ge307XG4gICAgbGV0IGF0dGVtcHRFeGFjdE1hdGNoID0gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9Qcm9jZXNzb3IsXG4gICAgICB2aWRlb1Byb2Nlc3NvcixcbiAgICAgIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yOiBpbnRlcm5hbE9wdGlvbnNcbiAgICB9ID0gZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICBsZXQgcmV0cnlBdWRpb09wdGlvbnMgPSBpbnRlcm5hbE9wdGlvbnMuYXVkaW87XG4gICAgbGV0IHJldHJ5VmlkZW9PcHRpb25zID0gaW50ZXJuYWxPcHRpb25zLnZpZGVvO1xuICAgIGlmIChhdWRpb1Byb2Nlc3NvciAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvLnByb2Nlc3NvciA9IGF1ZGlvUHJvY2Vzc29yO1xuICAgIH1cbiAgICBpZiAodmlkZW9Qcm9jZXNzb3IgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGludGVybmFsT3B0aW9ucy52aWRlby5wcm9jZXNzb3IgPSB2aWRlb1Byb2Nlc3NvcjtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHVzZXIgcGFzc2VzIGEgZGV2aWNlIGlkIGFzIGEgc3RyaW5nLCB3ZSBkZWZhdWx0IHRvIGV4YWN0IG1hdGNoXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpby5kZXZpY2VJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGRldmljZUlkID0gaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkO1xuICAgICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkID0ge1xuICAgICAgICBleGFjdDogZGV2aWNlSWRcbiAgICAgIH07XG4gICAgICBhdHRlbXB0RXhhY3RNYXRjaCA9IHRydWU7XG4gICAgICByZXRyeUF1ZGlvT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxPcHRpb25zLmF1ZGlvKSwge1xuICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgIGlkZWFsOiBkZXZpY2VJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGludGVybmFsT3B0aW9ucy52aWRlbyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGV2aWNlSWQgPSBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQ7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPSB7XG4gICAgICAgIGV4YWN0OiBkZXZpY2VJZFxuICAgICAgfTtcbiAgICAgIGF0dGVtcHRFeGFjdE1hdGNoID0gdHJ1ZTtcbiAgICAgIHJldHJ5VmlkZW9PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbE9wdGlvbnMudmlkZW8pLCB7XG4gICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgaWRlYWw6IGRldmljZUlkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPIGlmIGludGVybmFsIG9wdGlvbnMgZG9uJ3QgaGF2ZSBkZXZpY2UgSWQgc3BlY2lmaWVkLCBzZXQgaXQgdG8gJ2RlZmF1bHQnXG4gICAgaWYgKGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSB8fCB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJiAhaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPSB7XG4gICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09IHRydWUgfHwgdHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgIWludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCkge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvID0ge1xuICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhpbnRlcm5hbE9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xuICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHByb21pc2Ugb24gRGV2aWNlTWFuYWdlciBhbmQgYXdhaXQgaXQgaW4gZ2V0TG9jYWxEZXZpY2VzKClcbiAgICAvLyB3b3JrcyBhcm91bmQgaU9TIFNhZmFyaSBCdWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgIGNvbnN0IG1lZGlhUHJvbWlzZSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLmF1ZGlvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCdhdWRpb2lucHV0JykpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCd2aWRlb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCd2aWRlb2lucHV0JykpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbWVkaWFQcm9taXNlO1xuICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHN0cmVhbS5nZXRUcmFja3MoKS5tYXAobWVkaWFTdHJlYW1UcmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgICAgIGxldCB0cmFja09wdGlvbnMgPSBpc0F1ZGlvID8gb3B0cy5hdWRpbyA6IG9wdHMudmlkZW87XG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgICAgIHRyYWNrT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBjb25zdHJhaW50cyB3aXRoIHRoZSBkZXZpY2UgaWQgdGhlIHVzZXIgZ2F2ZSBwZXJtaXNzaW9ucyB0byBpbiB0aGUgcGVybWlzc2lvbiBwcm9tcHRcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGVhY2ggdHJhY2sgcmVzdGFydCAoZS5nLiBtdXRlIC0gdW5tdXRlKSB3aWxsIHRyeSB0byBpbml0aWFsaXplIHRoZSBkZXZpY2UgYWdhaW4gLT4gY2F1c2luZyBhZGRpdGlvbmFsIHBlcm1pc3Npb24gcHJvbXB0c1xuICAgICAgICBjb25zdCBuZXdEZXZpY2VJZCA9IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICAgICAgaWYgKCh0cmFja0NvbnN0cmFpbnRzID09PSBudWxsIHx8IHRyYWNrQ29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrQ29uc3RyYWludHMuZGV2aWNlSWQpICYmIHVud3JhcENvbnN0cmFpbnQodHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCkgIT09IG5ld0RldmljZUlkKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCA9IG5ld0RldmljZUlkO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmFja0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgIGRldmljZUlkOiBuZXdEZXZpY2VJZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSAmJiBhdWRpb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnNldFByb2Nlc3NvcihhdWRpb1Byb2Nlc3Nvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSAmJiB2aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnNldFByb2Nlc3Nvcih2aWRlb1Byb2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWF0dGVtcHRFeGFjdE1hdGNoKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFja3MoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBhdWRpbzogcmV0cnlBdWRpb09wdGlvbnMsXG4gICAgICAgIHZpZGVvOiByZXRyeVZpZGVvT3B0aW9uc1xuICAgICAgfSksIGxvZ2dlck9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBbW0xvY2FsVmlkZW9UcmFja11dIHdpdGggZ2V0VXNlck1lZGlhKClcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVmlkZW9UcmFjayhvcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgdmlkZW86IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tzWzBdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsQXVkaW9UcmFjayhvcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgICAgYXVkaW86IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHRydWUsXG4gICAgICB2aWRlbzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tzWzBdO1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHNjcmVlbiBjYXB0dXJlIHRyYWNrcyB3aXRoIGdldERpc3BsYXlNZWRpYSgpLlxuICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyhvcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTcoKSkge1xuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gU2NyZWVuU2hhcmVQcmVzZXRzLmgxMDgwZnBzMzAucmVzb2x1dGlvbjtcbiAgICB9XG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBjb25zdHJhaW50cyA9IHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHNjcmVlblZpZGVvID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFja3NbMF0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIHNjcmVlblZpZGVvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICBjb25zdCBsb2NhbFRyYWNrcyA9IFtzY3JlZW5WaWRlb107XG4gICAgaWYgKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gIH0pO1xufVxuXG52YXIgQ29ubmVjdGlvblF1YWxpdHk7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25RdWFsaXR5KSB7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiRXhjZWxsZW50XCJdID0gXCJleGNlbGxlbnRcIjtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJHb29kXCJdID0gXCJnb29kXCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiUG9vclwiXSA9IFwicG9vclwiO1xuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgYSBwYXJ0aWNpcGFudCBoYXMgdGVtcG9yYXJpbHkgKG9yIHBlcm1hbmVudGx5KSBsb3N0IGNvbm5lY3Rpb24gdG8gTGl2ZUtpdC5cbiAgICogRm9yIHBlcm1hbmVudCBkaXNjb25uZWN0aW9uIGEgYFBhcnRpY2lwYW50RGlzY29ubmVjdGVkYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgYWZ0ZXIgYSB0aW1lb3V0XG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkxvc3RcIl0gPSBcImxvc3RcIjtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG59KShDb25uZWN0aW9uUXVhbGl0eSB8fCAoQ29ubmVjdGlvblF1YWxpdHkgPSB7fSkpO1xuZnVuY3Rpb24gcXVhbGl0eUZyb21Qcm90byhxKSB7XG4gIHN3aXRjaCAocSkge1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5FWENFTExFTlQ6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuRXhjZWxsZW50O1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5HT09EOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkdvb2Q7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLlBPT1I6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuUG9vcjtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuTE9TVDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Mb3N0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuVW5rbm93bjtcbiAgfVxufVxuY2xhc3MgUGFydGljaXBhbnQgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgfVxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuc2l6ZSA+IDAgJiYgQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5ldmVyeSh0ciA9PiB0ci5pc0VuY3J5cHRlZCk7XG4gIH1cbiAgZ2V0IGlzQWdlbnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFnZW50KSB8fCB0aGlzLmtpbmQgPT09IFBhcnRpY2lwYW50SW5mb19LaW5kLkFHRU5UO1xuICB9XG4gIGdldCBraW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9raW5kO1xuICB9XG4gIC8qKiBwYXJ0aWNpcGFudCBhdHRyaWJ1dGVzLCBzaW1pbGFyIHRvIG1ldGFkYXRhLCBidXQgYXMgYSBrZXkvdmFsdWUgbWFwICovXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2F0dHJpYnV0ZXMpKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgbGV0IGtpbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IFBhcnRpY2lwYW50SW5mb19LaW5kLlNUQU5EQVJEO1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBhdWRpbyBsZXZlbCBiZXR3ZWVuIDAtMS4wLCAxIGJlaW5nIGxvdWRlc3QsIDAgYmVpbmcgc29mdGVzdCAqL1xuICAgIHRoaXMuYXVkaW9MZXZlbCA9IDA7XG4gICAgLyoqIGlmIHBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBzcGVha2luZyAqL1xuICAgIHRoaXMuaXNTcGVha2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkuVW5rbm93bjtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucyA9PT0gbnVsbCB8fCBsb2dnZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBhcnRpY2lwYW50KTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9raW5kID0ga2luZDtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzICE9PSB2b2lkIDAgPyBhdHRyaWJ1dGVzIDoge307XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHNvdXJjZSBmaWx0ZXIsIGZvciBleGFtcGxlLCBnZXR0aW5nXG4gICAqIHRoZSB1c2VyJ3MgY2FtZXJhIHRyYWNrIHdpdGggZ2V0VHJhY2tCeVNvdXJjZShUcmFjay5Tb3VyY2UuQ2FtZXJhKS5cbiAgICovXG4gIGdldFRyYWNrUHVibGljYXRpb24oc291cmNlKSB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMpIHtcbiAgICAgIGlmIChwdWIuc291cmNlID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHRyYWNrJ3MgbmFtZS5cbiAgICovXG4gIGdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSkge1xuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrUHVibGljYXRpb25zKSB7XG4gICAgICBpZiAocHViLnRyYWNrTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICB9XG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNNaWNyb3Bob25lRW5hYmxlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNTY3JlZW5TaGFyZUVuYWJsZWQoKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLlNjcmVlblNoYXJlKTtcbiAgICByZXR1cm4gISF0cmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tICovXG4gIGdldCBqb2luZWRBdCgpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGhpcy5wYXJ0aWNpcGFudEluZm8uam9pbmVkQXQudG9TdHJpbmcoKSkgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRoZSB1cGRhdGUgY291bGQgYmUgYXBwbGllZCBvdXQgb2Ygb3JkZXIgZHVlIHRvIGF3YWl0XG4gICAgLy8gZHVyaW5nIHJlY29ubmVjdCBzZXF1ZW5jZXMuIHdoZW4gdGhhdCBoYXBwZW5zLCBpdCdzIHBvc3NpYmxlIGZvciBzZXJ2ZXJcbiAgICAvLyB0byBoYXZlIHNlbnQgbW9yZSByZWNlbnQgdmVyc2lvbiBvZiBwYXJ0aWNpcGFudCBpbmZvIHdoaWxlIEpTIGlzIHdhaXRpbmdcbiAgICAvLyB0byBwcm9jZXNzIHRoZSBleGlzdGluZyBwYXlsb2FkLlxuICAgIC8vIHdoZW4gdGhlIHBhcnRpY2lwYW50IHNpZCByZW1haW5zIHRoZSBzYW1lLCBhbmQgd2UgYWxyZWFkeSBoYXZlIGEgbGF0ZXIgdmVyc2lvblxuICAgIC8vIG9mIHRoZSBwYXlsb2FkLCB0aGV5IGNhbiBiZSBzYWZlbHkgc2tpcHBlZFxuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SW5mbyAmJiB0aGlzLnBhcnRpY2lwYW50SW5mby5zaWQgPT09IGluZm8uc2lkICYmIHRoaXMucGFydGljaXBhbnRJbmZvLnZlcnNpb24gPiBpbmZvLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pZGVudGl0eSA9IGluZm8uaWRlbnRpdHk7XG4gICAgdGhpcy5zaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLl9zZXROYW1lKGluZm8ubmFtZSk7XG4gICAgdGhpcy5fc2V0TWV0YWRhdGEoaW5mby5tZXRhZGF0YSk7XG4gICAgdGhpcy5fc2V0QXR0cmlidXRlcyhpbmZvLmF0dHJpYnV0ZXMpO1xuICAgIGlmIChpbmZvLnBlcm1pc3Npb24pIHtcbiAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMoaW5mby5wZXJtaXNzaW9uKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoaXMgbGFzdCBzbyBzZXRNZXRhZGF0YSBjYW4gZGV0ZWN0IGNoYW5nZXNcbiAgICB0aGlzLnBhcnRpY2lwYW50SW5mbyA9IGluZm87XG4gICAgdGhpcy5sb2cudHJhY2UoJ3VwZGF0ZSBwYXJ0aWNpcGFudCBpbmZvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBpbmZvXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIG1ldGFkYXRhIGZyb20gc2VydmVyXG4gICAqKi9cbiAgX3NldE1ldGFkYXRhKG1kKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMubWV0YWRhdGEgIT09IG1kO1xuICAgIGNvbnN0IHByZXZNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1kO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhKTtcbiAgICB9XG4gIH1cbiAgX3NldE5hbWUobmFtZSkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm5hbWUgIT09IG5hbWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIG1ldGFkYXRhIGZyb20gc2VydmVyXG4gICAqKi9cbiAgX3NldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGRpZmYgPSBkaWZmQXR0cmlidXRlcyh0aGlzLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIGlmIChPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdHRyaWJ1dGVzQ2hhbmdlZCwgZGlmZik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2gpIHx8IHBlcm1pc3Npb25zLmNhblN1YnNjcmliZSAhPT0gKChfYiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5TdWJzY3JpYmUpIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSAoKF9jID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhblB1Ymxpc2hEYXRhKSB8fCBwZXJtaXNzaW9ucy5oaWRkZW4gIT09ICgoX2QgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGlkZGVuKSB8fCBwZXJtaXNzaW9ucy5yZWNvcmRlciAhPT0gKChfZSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWNvcmRlcikgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5QdWJsaXNoU291cmNlc1tpbmRleF0pO1xuICAgIH0pIHx8IHBlcm1pc3Npb25zLmNhblN1YnNjcmliZU1ldHJpY3MgIT09ICgoX2YgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FuU3Vic2NyaWJlTWV0cmljcyk7XG4gICAgdGhpcy5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRJc1NwZWFraW5nKHNwZWFraW5nKSB7XG4gICAgaWYgKHNwZWFraW5nID09PSB0aGlzLmlzU3BlYWtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NwZWFraW5nID0gc3BlYWtpbmc7XG4gICAgaWYgKHNwZWFraW5nKSB7XG4gICAgICB0aGlzLmxhc3RTcG9rZUF0ID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuSXNTcGVha2luZ0NoYW5nZWQsIHNwZWFraW5nKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldENvbm5lY3Rpb25RdWFsaXR5KHEpIHtcbiAgICBjb25zdCBwcmV2UXVhbGl0eSA9IHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gcXVhbGl0eUZyb21Qcm90byhxKTtcbiAgICBpZiAocHJldlF1YWxpdHkgIT09IHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGN0eCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHRyYWNrID0+IGlzQXVkaW9UcmFjayh0cmFjay50cmFjaykgJiYgdHJhY2sudHJhY2suc2V0QXVkaW9Db250ZXh0KGN0eCkpO1xuICB9XG4gIGFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pIHtcbiAgICAvLyBmb3J3YXJkIHB1YmxpY2F0aW9uIGRyaXZlbiBldmVudHNcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50Lk11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCBwdWIgPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICBwdWIudHJhY2suc2lkID0gcHVibGljYXRpb24udHJhY2tTaWQ7XG4gICAgfVxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXMpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGlmICghcGVybXMucGFydGljaXBhbnRTaWQgJiYgIXBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhY2sgcGVybWlzc2lvbiwgbXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBvZiBwYXJ0aWNpcGFudElkZW50aXR5IGFuZCBwYXJ0aWNpcGFudFNpZCcpO1xuICB9XG4gIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKHtcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5OiAoX2EgPSBwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICBwYXJ0aWNpcGFudFNpZDogKF9iID0gcGVybXMucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgIGFsbFRyYWNrczogKF9jID0gcGVybXMuYWxsb3dBbGwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlLFxuICAgIHRyYWNrU2lkczogcGVybXMuYWxsb3dlZFRyYWNrU2lkcyB8fCBbXVxuICB9KTtcbn1cblxuY29uc3QgU1RSRUFNX0NIVU5LX1NJWkUgPSAxNTAwMDtcbmNsYXNzIExvY2FsUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSwgZW5naW5lLCBvcHRpb25zLCByb29tUnBjSGFuZGxlcnMpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMuZW5naW5lLmxvZ0NvbnRleHRcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gdHJ1ZTtcbiAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzID0gW107XG4gICAgdGhpcy5wZW5kaW5nQWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVjb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oZS5tZXNzYWdlLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5yZWNvbm5lY3RGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWplY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAnR290IGRpc2Nvbm5lY3RlZCBkdXJpbmcgcmVjb25uZWN0aW9uIGF0dGVtcHQnKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWFzb24sXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3QgPSB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgIGlmICh0YXJnZXRSZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZWFzb24gIT09IFJlcXVlc3RSZXNwb25zZV9SZWFzb24uT0spIHtcbiAgICAgICAgICB0YXJnZXRSZXF1ZXN0LnJlamVjdChuZXcgU2lnbmFsUmVxdWVzdEVycm9yKG1lc3NhZ2UsIHJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEYXRhUGFja2V0ID0gcGFja2V0ID0+IHtcbiAgICAgIHN3aXRjaCAocGFja2V0LnZhbHVlLmNhc2UpIHtcbiAgICAgICAgY2FzZSAncnBjUmVzcG9uc2UnOlxuICAgICAgICAgIGxldCBycGNSZXNwb25zZSA9IHBhY2tldC52YWx1ZS52YWx1ZTtcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IG51bGw7XG4gICAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgICBpZiAocnBjUmVzcG9uc2UudmFsdWUuY2FzZSA9PT0gJ3BheWxvYWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcnBjUmVzcG9uc2UudmFsdWUudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChycGNSZXNwb25zZS52YWx1ZS5jYXNlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBlcnJvciA9IFJwY0Vycm9yLmZyb21Qcm90byhycGNSZXNwb25zZS52YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdScGNSZXNwb25zZShycGNSZXNwb25zZS5yZXF1ZXN0SWQsIHBheWxvYWQsIGVycm9yKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnBjQWNrJzpcbiAgICAgICAgICBsZXQgcnBjQWNrID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdScGNBY2socnBjQWNrLnJlcXVlc3RJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLFxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLCB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucy5tYXAocCA9PiB0cmFja1Blcm1pc3Npb25Ub1Byb3RvKHApKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5vblRyYWNrVW5tdXRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc1Vwc3RyZWFtUGF1c2VkKTtcbiAgICB9O1xuICAgIC8vIHdoZW4gdGhlIGxvY2FsIHRyYWNrIGNoYW5nZXMgaW4gbXV0ZSBzdGF0dXMsIHdlJ2xsIG5vdGlmeSBzZXJ2ZXIgYXMgc3VjaFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLm9uVHJhY2tNdXRlZCA9ICh0cmFjaywgbXV0ZWQpID0+IHtcbiAgICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suc2lkKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmdpbmUudXBkYXRlTXV0ZVN0YXR1cyh0cmFjay5zaWQsIG11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkID0gdHJhY2sgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHBhdXNlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSByZXN1bWVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzTXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSA9IHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5nZXQodHJhY2suc2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3QgdXBkYXRlIGxvY2FsIGF1ZGlvIHRyYWNrIHNldHRpbmdzLCBtaXNzaW5nIHB1YmxpY2F0aW9uIGZvciB0cmFjayBcIi5jb25jYXQodHJhY2suc2lkKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrU2lkLCBwdWIuZ2V0VHJhY2tGZWF0dXJlcygpKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgIHZhciBfZCwgX2U7XG4gICAgICBpZiAoISgoX2QgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZHluYWNhc3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHN1YnNjcmliZWQgcXVhbGl0eSB1cGRhdGUgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZS5zdWJzY3JpYmVkQ29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFwdWIudmlkZW9UcmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDb2RlY3MgPSB5aWVsZCBwdWIudmlkZW9UcmFjay5zZXRQdWJsaXNoaW5nQ29kZWNzKHVwZGF0ZS5zdWJzY3JpYmVkQ29kZWNzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIG5ld0NvZGVjc18xID0gX19hc3luY1ZhbHVlcyhuZXdDb2RlY3MpLCBuZXdDb2RlY3NfMV8xOyBuZXdDb2RlY3NfMV8xID0geWllbGQgbmV3Q29kZWNzXzEubmV4dCgpLCBfYSA9IG5ld0NvZGVjc18xXzEuZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgIF9jID0gbmV3Q29kZWNzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IF9jO1xuICAgICAgICAgICAgaWYgKGlzQmFja3VwQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaCBcIi5jb25jYXQoY29kZWMsIFwiIGZvciBcIikuY29uY2F0KHB1Yi52aWRlb1RyYWNrLnNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSk7XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrKHB1Yi52aWRlb1RyYWNrLCBjb2RlYywgcHViLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBuZXdDb2RlY3NfMS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKG5ld0NvZGVjc18xKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1cGRhdGUuc3Vic2NyaWJlZFF1YWxpdGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIChfZSA9IHB1Yi52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2V0UHVibGlzaGluZ0xheWVycyh1cGRhdGUuc3Vic2NyaWJlZFF1YWxpdGllcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSB1bnB1Ymxpc2hlZCA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHVucHVibGlzaGVkLnRyYWNrU2lkKTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgdW5wdWJsaXNoZWQgZXZlbnQgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICB0cmFja1NpZDogdW5wdWJsaXNoZWQudHJhY2tTaWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSB8fCB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgbG9jYWwgdHJhY2sgZHVlIHRvIFRyYWNrRW5kZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zID0geWllbGQgbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGVybWlzc2lvbiBxdWVyeSBmb3IgY2FtZXJhIGFuZCBtaWNyb3Bob25lIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBuYW1lOiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgPyAnY2FtZXJhJyA6ICdtaWNyb3Bob25lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihcInVzZXIgaGFzIHJldm9rZWQgYWNjZXNzIHRvIFwiLmNvbmNhdCh0cmFjay5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGdyYW50ZWQgY2hhbmdlIGFmdGVyIHBlcm1pc3Npb25zIHdlcmUgZGVuaWVkIHRvIHRyeSBhbmQgcmVzdW1lIHRoZW5cbiAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zLnN0YXRlICE9PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRVc2VyTWVkaWEgUGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9ucyBxdWVyeSBmYWlscyBmb3IgZmlyZWZveCwgd2UgY29udGludWUgYW5kIHRyeSB0byByZXN0YXJ0IHRoZSB0cmFja1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd0cmFjayBlbmRlZCwgYXR0ZW1wdGluZyB0byB1c2UgYSBkaWZmZXJlbnQgZGV2aWNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCBkZXZpY2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgIHlpZWxkIHRyYWNrLnJlc3RhcnRUcmFjayh7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6ICdkZWZhdWx0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlpZWxkIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVzdGFydCB0cmFjaywgbXV0aW5nIGluc3RlYWRcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLnJvb21PcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNldHVwRW5naW5lKGVuZ2luZSk7XG4gICAgdGhpcy5hY3RpdmVEZXZpY2VNYXAgPSBuZXcgTWFwKFtbJ2F1ZGlvaW5wdXQnLCAnZGVmYXVsdCddLCBbJ3ZpZGVvaW5wdXQnLCAnZGVmYXVsdCddLCBbJ2F1ZGlvb3V0cHV0JywgJ2RlZmF1bHQnXV0pO1xuICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucnBjSGFuZGxlcnMgPSByb29tUnBjSGFuZGxlcnM7XG4gIH1cbiAgZ2V0IGxhc3RDYW1lcmFFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFFcnJvcjtcbiAgfVxuICBnZXQgbGFzdE1pY3JvcGhvbmVFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5taWNyb3Bob25lRXJyb3I7XG4gIH1cbiAgZ2V0IGlzRTJFRUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICB9XG4gIGdldFRyYWNrUHVibGljYXRpb24oc291cmNlKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIGdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgKHRyYWNrU2lkLCBtdXRlZCkgPT4ge1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgcHViLm11dGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Yi51bm11dGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5Db25uZWN0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZykub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlcXVlc3RSZXNwb25zZSwgdGhpcy5oYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UpLm9uKEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgdGhpcy5oYW5kbGVEYXRhUGFja2V0KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMucmVxdWVzdE1ldGFkYXRhVXBkYXRlKHtcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBuYW1lIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnNcbiAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAqL1xuICBzZXROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xuICAgICAgICBuYW1lXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9yIHVwZGF0ZSBwYXJ0aWNpcGFudCBhdHRyaWJ1dGVzLiBJdCB3aWxsIG1ha2UgdXBkYXRlcyBvbmx5IHRvIGtleXMgdGhhdFxuICAgKiBhcmUgcHJlc2VudCBpbiBgYXR0cmlidXRlc2AsIGFuZCB3aWxsIG5vdCBvdmVycmlkZSBvdGhlcnMuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBhdHRyaWJ1dGVzIHRvIHVwZGF0ZVxuICAgKi9cbiAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMucmVxdWVzdE1ldGFkYXRhVXBkYXRlKHtcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdE1ldGFkYXRhVXBkYXRlKF9hKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQge1xuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGlzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YSgoX2EgPSBtZXRhZGF0YSAhPT0gbnVsbCAmJiBtZXRhZGF0YSAhPT0gdm9pZCAwID8gbWV0YWRhdGEgOiB0aGlzLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgKF9iID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogdGhpcy5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgcmVqZWN0OiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICBpc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2hpbGUgKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lIDwgNTAwMCAmJiAhaXNSZWplY3RlZCkge1xuICAgICAgICAgICAgICBpZiAoKCFuYW1lIHx8IHRoaXMubmFtZSA9PT0gbmFtZSkgJiYgKCFtZXRhZGF0YSB8fCB0aGlzLm1ldGFkYXRhID09PSBtZXRhZGF0YSkgJiYgKCFhdHRyaWJ1dGVzIHx8IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmV2ZXJ5KF9yZWYyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJycgJiYgIXRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChuZXcgU2lnbmFsUmVxdWVzdEVycm9yKCdSZXF1ZXN0IHRvIHVwZGF0ZSBsb2NhbCBtZXRhZGF0YSB0aW1lZCBvdXQnLCAnVGltZW91dEVycm9yJykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0Q2FtZXJhRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuQ2FtZXJhLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRNaWNyb3Bob25lRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHN1cGVyLnNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICBpZiAoY2hhbmdlZCAmJiBwcmV2UGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEUyRUVFbmFibGVkKGVuYWJsZWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgICB5aWVsZCB0aGlzLnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRUcmFja0VuYWJsZWQoc291cmNlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVuYWJsZWRcbiAgICAgIH0pKTtcbiAgICAgIGlmICh0aGlzLnJlcHVibGlzaFByb21pc2UpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZXB1Ymxpc2hQcm9taXNlO1xuICAgICAgfVxuICAgICAgbGV0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB5aWVsZCB0cmFjay51bm11dGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbG9jYWxUcmFja3M7XG4gICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFjayA9IHlpZWxkIHRoaXMud2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmdUcmFjaykge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCd3YWl0aW5nIGZvciBwZW5kaW5nIHB1YmxpY2F0aW9uIHByb21pc2UgdGltZWQgb3V0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHBlbmRpbmdUcmFjayA9PT0gbnVsbCB8fCBwZW5kaW5nVHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdUcmFjay51bm11dGUoKTtcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nVHJhY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvOiAoX2EgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgICBhdWRpbzogKF9iID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlU2NyZWVuVHJhY2tzKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3Ioc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2NhbFRyYWNrcyA9PT0gbnVsbCB8fCBsb2NhbFRyYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYWxUcmFja3MuZm9yRWFjaCh0ciA9PiB7XG4gICAgICAgICAgICAgIHRyLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3B1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sobG9jYWxUcmFjaykpKTtcbiAgICAgICAgICAgICAgcHVibGlzaFByb21pc2VzLnB1c2godGhpcy5wdWJsaXNoVHJhY2sobG9jYWxUcmFjaywgcHVibGlzaE9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrcyA9IHlpZWxkIFByb21pc2UuYWxsKHB1Ymxpc2hQcm9taXNlcyk7XG4gICAgICAgICAgICAvLyBmb3Igc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9ucyBpbmNsdWRpbmcgYXVkaW8sIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0aGUgc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9uLCBub3QgdGhlIHNjcmVlbiBzaGFyZSBhdWRpbyBvbmVcbiAgICAgICAgICAgIC8vIHJldmlzaXQgaWYgd2Ugd2FudCB0byByZXR1cm4gYW4gYXJyYXkgb2YgdHJhY2tzIGluc3RlYWQgZm9yIHYyXG4gICAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICAgICAgdHIuc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEodHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLnRyYWNrKSAmJiB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBubyB0cmFjayBhdmFpbGFibGUgeWV0IGZpcnN0IHdhaXQgZm9yIHBlbmRpbmcgcHVibGlzaGluZyBwcm9taXNlcyBvZiB0aGF0IHNvdXJjZSB0byBzZWUgaWYgaXQgYmVjb21lcyBhdmFpbGFibGVcbiAgICAgICAgICB0cmFjayA9IHlpZWxkIHRoaXMud2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnd2FpdGluZyBmb3IgcGVuZGluZyBwdWJsaWNhdGlvbiBwcm9taXNlIHRpbWVkIG91dCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLnRyYWNrKSB7XG4gICAgICAgICAgLy8gc2NyZWVuc2hhcmUgY2Fubm90IGJlIG11dGVkLCB1bnB1Ymxpc2ggaW5zdGVhZFxuICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgICAgdHJhY2sgPSB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvVHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pO1xuICAgICAgICAgICAgaWYgKHNjcmVlbkF1ZGlvVHJhY2sgJiYgc2NyZWVuQXVkaW9UcmFjay50cmFjaykge1xuICAgICAgICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cbiAgICovXG4gIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFjay5Tb3VyY2UuQ2FtZXJhKSB8fCB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkpIHtcbiAgICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMucHVibGlzaFRyYWNrKHRyYWNrKSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGxvY2FsIGNhbWVyYSBhbmQvb3IgbWljcm9waG9uZSB0cmFja3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGNyZWF0ZVRyYWNrcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBvcHRpb25zID0ge307XG4gICAgICBjb25zdCBtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdWRpb0NhcHR1cmVEZWZhdWx0cywgKF9iID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKG1lcmdlZE9wdGlvbnNXaXRoUHJvY2Vzc29ycywge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9jYWxUcmFja3MgPSB0cmFja3MubWFwKHRyYWNrID0+IHtcbiAgICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cmFjay5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxNygpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxuICAgICAgICAvLyBkdWUgdG8gZW5jb2RpbmcgYSBodWdlIHZpZGVvLiBFbmNvZGluZyBzdWNoIGxhcmdlIHN1cmZhY2VzIGlzIHJlYWxseSBleHBlbnNpdmVcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSBTYWZhcmkgMTcgaGFzIGEgYnV0IGFuZCBjYW5ub3QgYmUgY29uc3RyYWluZWQgYnkgZGVmYXVsdFxuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgaWYgKG9wdGlvbnMuY29udGVudEhpbnQpIHtcbiAgICAgICAgc2NyZWVuVmlkZW8ubWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9IG9wdGlvbnMuY29udGVudEhpbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbFRyYWNrcyA9IFtzY3JlZW5WaWRlb107XG4gICAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB0aGlzLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGEgbmV3IHRyYWNrIHRvIHRoZSByb29tXG4gICAqIEBwYXJhbSB0cmFja1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgcHVibGlzaFRyYWNrKHRyYWNrLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBwdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayh0cmFja18xLCBvcHRpb25zXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAodHJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IGlzUmVwdWJsaXNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICB0cmFjay5zZXRBdWRpb0NvbnRleHQoX3RoaXMyLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgKF9hID0gX3RoaXMyLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb21pc2U7XG4gICAgICAgIGlmIChfdGhpczIucmVwdWJsaXNoUHJvbWlzZSAmJiAhaXNSZXB1Ymxpc2gpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczIucmVwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5oYXModHJhY2spKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSB3YW50IHRvIGFjY2VzcyBjb25zdHJhaW50cyBkaXJlY3RseSBhcyBgdHJhY2subWVkaWFTdHJlYW1UcmFja2BcbiAgICAgICAgICAvLyBtaWdodCBiZSBwb2ludGluZyB0byBhIG5vbi1kZXZpY2UgdHJhY2sgKGUuZy4gcHJvY2Vzc2VkIHRyYWNrKSBhbHJlYWR5XG4gICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suY29uc3RyYWludHM7XG4gICAgICAgICAgbGV0IGRldmljZUtpbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc3dpdGNoICh0cmFjay5zb3VyY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICAgIGRldmljZUtpbmQgPSAnYXVkaW9pbnB1dCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICBkZXZpY2VLaW5kID0gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV2aWNlS2luZCAmJiBfdGhpczIuYWN0aXZlRGV2aWNlTWFwLmhhcyhkZXZpY2VLaW5kKSkge1xuICAgICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uc3RyYWludHMpLCB7XG4gICAgICAgICAgICAgIGRldmljZUlkOiBfdGhpczIuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgcmF3IG1lZGlhIHRyYWNrIGludG8gYXVkaW8gb3IgdmlkZW8gdHJhY2tcbiAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgIHN3aXRjaCAodHJhY2sua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgX3RoaXMyLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgIGxvZ2dlck5hbWU6IF90aGlzMi5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwge1xuICAgICAgICAgICAgICAgIGxvZ2dlck5hbWU6IF90aGlzMi5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKFwidW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kIFwiLmNvbmNhdCh0cmFjay5raW5kKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNrLnVwZGF0ZUxvZ2dlck9wdGlvbnMoe1xuICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IF90aGlzMi5sb2dDb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXMgaXQgYWxyZWFkeSBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICAgIF90aGlzMi50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgICAgIF90aGlzMi5sb2cud2FybigndHJhY2sgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQsIHNraXBwaW5nJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbikpKTtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1N0ZXJlb0lucHV0ID0gJ2NoYW5uZWxDb3VudCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgYGNoYW5uZWxDb3VudGAgb24gZ2V0U2V0dGluZ3MoKSBpcyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgZm9yIFNhZmFyaSwgYnV0IGlzIGdlbmVyYWxseSB0aGUgYmVzdCB3YXkgdG8gZGV0ZXJtaW5lIGEgc3RlcmVvIHRyYWNrIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrU2V0dGluZ3MvY2hhbm5lbENvdW50XG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5jaGFubmVsQ291bnQgPT09IDIgfHwgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpLmNoYW5uZWxDb3VudCA9PT0gMjtcbiAgICAgICAgY29uc3QgaXNTdGVyZW8gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2VTdGVyZW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlzU3RlcmVvSW5wdXQ7XG4gICAgICAgIC8vIGRpc2FibGUgZHR4IGZvciBzdGVyZW8gdHJhY2sgaWYgbm90IGVuYWJsZWQgZXhwbGljaXRseVxuICAgICAgICBpZiAoaXNTdGVyZW8pIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZHR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzMi5sb2cuaW5mbyhcIk9wdXMgRFRYIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5yZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKFwiT3B1cyBSRUQgd2lsbCBiZSBkaXNhYmxlZCBmb3Igc3RlcmVvIHRyYWNrcyBieSBkZWZhdWx0LiBFbmFibGUgdGhlbSBleHBsaWNpdGx5IHRvIG1ha2UgaXQgd29yay5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIChfYyA9IG9wdGlvbnMuZHR4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBvcHRpb25zLmR0eCA9IGZhbHNlO1xuICAgICAgICAgIChfZCA9IG9wdGlvbnMucmVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBvcHRpb25zLnJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5yb29tT3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSAmJiBfdGhpczIucm9vbU9wdGlvbnMuZTJlZSkge1xuICAgICAgICAgIF90aGlzMi5sb2cuaW5mbyhcIkVuZC10by1lbmQgZW5jcnlwdGlvbiBpcyBzZXQgdXAsIHNpbXVsY2FzdCBwdWJsaXNoaW5nIHdpbGwgYmUgZGlzYWJsZWQgb24gU2FmYXJpIHZlcnNpb25zIGFuZCBpT1MgYnJvd3NlcnMgcnVubmluZyBpT1MgPCB2MTcuMlwiLCBPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCkpO1xuICAgICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuc291cmNlKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gb3B0cy5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMyLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLmNsaWVudC5jdXJyZW50U3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlZmVycmluZyB0cmFjayBwdWJsaWNhdGlvbiB1bnRpbCBzaWduYWwgaXMgY29ubmVjdGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgdHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgY29uc3Qgb25TaWduYWxDb25uZWN0ZWQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0geWllbGQgdGhpcy5wdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgb25TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ3B1Ymxpc2hpbmcgcmVqZWN0ZWQgYXMgZW5naW5lIG5vdCBjb25uZWN0ZWQgd2l0aGluIHRpbWVvdXQnLCA0MDgpKTtcbiAgICAgICAgICAgICAgfSwgMTUwMDApO1xuICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5vbmNlKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgb25TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgb25TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ3B1Ymxpc2hpbmcgcmVqZWN0ZWQgYXMgZW5naW5lIGNsb3NlZCcsIDQ5OSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuc2V0KHRyYWNrLCBwdWJsaXNoUHJvbWlzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCBwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmRlbGV0ZSh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBoYXNQZXJtaXNzaW9uc1RvUHVibGlzaCh0cmFjaykge1xuICAgIGlmICghdGhpcy5wZXJtaXNzaW9ucykge1xuICAgICAgdGhpcy5sb2cud2Fybignbm8gcGVybWlzc2lvbnMgcHJlc2VudCBmb3IgcHVibGlzaGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FuUHVibGlzaCxcbiAgICAgIGNhblB1Ymxpc2hTb3VyY2VzXG4gICAgfSA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgaWYgKGNhblB1Ymxpc2ggJiYgKGNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCA9PT0gMCB8fCBjYW5QdWJsaXNoU291cmNlcy5tYXAoc291cmNlID0+IGdldFRyYWNrU291cmNlRnJvbVByb3RvKHNvdXJjZSkpLmluY2x1ZGVzKHRyYWNrLnNvdXJjZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sb2cud2FybignaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zIHRvIHB1Ymxpc2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICAgIGlmICghdGhpcy5oYXNQZXJtaXNzaW9uc1RvUHVibGlzaCh0cmFjaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFB1Ymxpc2hUcmFja0Vycm9yKCdmYWlsZWQgdG8gcHVibGlzaCB0cmFjaywgaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJywgNDAzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmluZChwdWJsaXNoZWRUcmFjayA9PiBpc0xvY2FsVHJhY2sodHJhY2spICYmIHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gdHJhY2suc291cmNlKTtcbiAgICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFwicHVibGlzaGluZyBhIHNlY29uZCB0cmFjayB3aXRoIHRoZSBzYW1lIHNvdXJjZTogXCIuY29uY2F0KHRyYWNrLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRyYWNrLnN0b3BPbk11dGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIGlzRmlyZUZveCgpKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggc2ltdWxjYXN0ZWQgc2NyZWVuIHNoYXJlXG4gICAgICAgIC8vIHdlIGZyZXF1ZW50bHkgZ2V0IG5vIGRhdGEgb24gbGF5ZXIgMCB3aGVuIGVuYWJsZWRcbiAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlcXVpcmUgZnVsbCBBVjEvVlA5IFNWQyBzdXBwb3J0IHByaW9yIHRvIHVzaW5nIGl0XG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSAnYXYxJyAmJiAhc3VwcG9ydHNBVjEoKSkge1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSAndnA5JyAmJiAhc3VwcG9ydHNWUDkoKSkge1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gZGVmYXVsdFZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYSBzdXBwb3J0ZWQgY29kZWMgaWYgaXQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcy5zb21lKGMgPT4gb3B0cy52aWRlb0NvZGVjID09PSBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhjLm1pbWUpKSkge1xuICAgICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjc1swXS5taW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICAgIC8vIGhhbmRsZSB0cmFjayBhY3Rpb25zXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSk7XG4gICAgICAvLyBjcmVhdGUgdHJhY2sgcHVibGljYXRpb24gZnJvbSB0cmFja1xuICAgICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcbiAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxuICAgICAgICBkaXNhYmxlRHR4OiAhKChfYSA9IG9wdHMuZHR4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKSxcbiAgICAgICAgZW5jcnlwdGlvbjogdGhpcy5lbmNyeXB0aW9uVHlwZSxcbiAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcbiAgICAgICAgZGlzYWJsZVJlZDogdGhpcy5pc0UyRUVFbmFibGVkIHx8ICEoKF9iID0gb3B0cy5yZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpLFxuICAgICAgICBzdHJlYW06IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zdHJlYW0sXG4gICAgICAgIGJhY2t1cENvZGVjUG9saWN5OiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYmFja3VwQ29kZWNQb2xpY3lcbiAgICAgIH0pO1xuICAgICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cbiAgICAgIGxldCBlbmNvZGluZ3M7XG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICBsZXQgZGltcyA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaW1zID0geWllbGQgdHJhY2sud2FpdEZvckRpbWVuc2lvbnMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcbiAgICAgICAgICAvLyBzbyB1c2luZyBkZWZhdWx0IGRpbXMgYWNjb3JkaW5nIHRvIHB1Ymxpc2ggc2V0dGluZ3NcbiAgICAgICAgICBjb25zdCBkZWZhdWx0UmVzID0gKF9kID0gKF9jID0gdGhpcy5yb29tT3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc29sdXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb247XG4gICAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBkZWZhdWx0UmVzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBkZWZhdWx0UmVzLmhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gbG9nIGZhaWx1cmVcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBzaG91bGQgYmUgZGVmaW5lZCBmb3IgdmlkZW9cbiAgICAgICAgcmVxLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgICAgcmVxLmhlaWdodCA9IGRpbXMuaGVpZ2h0O1xuICAgICAgICAvLyBmb3Igc3ZjIGNvZGVjcywgZGlzYWJsZSBzaW11bGNhc3QgYW5kIHVzZSB2cDggZm9yIGJhY2t1cCBjb2RlY1xuICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgICAgICAvLyB2cDkgc3ZjIHdpdGggc2NyZWVuc2hhcmUgY2Fubm90IGVuY29kZSBtdWx0aXBsZSBzcGF0aWFsIGxheWVyc1xuICAgICAgICAgICAgICAvLyBkb2luZyBzbyByZWR1Y2VzIHB1Ymxpc2ggcmVzb2x1dGlvbiB0byBtaW5pbWFsIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICAgIC8vIENocm9tZSBkb2VzIG5vdCBhbGxvdyBtb3JlIHRoYW4gNSBmcHMgd2l0aCBMMVQzLCBhbmQgaXQgaGFzIGVuY29kaW5nIGJ1Z3Mgd2l0aCBMM1QzXG4gICAgICAgICAgICAgIC8vIEl0IGhhcyBhIGRpZmZlcmVudCBwYXRoIGZvciBzY3JlZW5zaGFyZSBoYW5kbGluZyBhbmQgaXQgc2VlbXMgdG8gYmUgdW50ZXN0ZWQvYnVnZ3lcbiAgICAgICAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kLCB3ZSBhcmUgc2V0dGluZyBjb250ZW50SGludCB0byBmb3JjZSBpdCB0byBnbyB0aHJvdWdoIHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vIHBhdGggYXMgcmVndWxhciBjYW1lcmEgdmlkZW8uIFdoaWxlIHRoaXMgaXMgbm90IG9wdGltYWwsIGl0IGRlbGl2ZXJzIHRoZSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAvLyB0aGF0IHdlIG5lZWRcbiAgICAgICAgICAgICAgaWYgKCdjb250ZW50SGludCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY29udGVudEhpbnQgPSAnbW90aW9uJztcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdmb3JjaW5nIGNvbnRlbnRIaW50IHRvIG1vdGlvbiBmb3Igc2NyZWVuc2hhcmUgd2l0aCBTVkMgY29kZWNzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgc2NhbGFiaWxpdHlNb2RlIHRvICdMM1QzX0tFWScgYnkgZGVmYXVsdFxuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAoX2UgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ0wzVDNfS0VZJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjID0ge1xuICAgICAgICAgICAgICBjb2RlYzogZGVmYXVsdFZpZGVvQ29kZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjICYmIHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgJiZcbiAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCBjb2RlY3NcbiAgICAgICAgICByZXEuZW5jcnlwdGlvbiA9PT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcbiAgICAgICAgICAgIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCByZXF1aXJlcyBkeW5hY2FzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcy5wdXNoKG5ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICAgIGNvZGVjOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxuICAgICAgICAgICAgICBjaWQ6ICcnXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncywgaXNTVkNDb2RlYyhvcHRzLnZpZGVvQ29kZWMpKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICBlbmNvZGluZ3MgPSBbe1xuICAgICAgICAgIG1heEJpdHJhdGU6IChfZiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYXhCaXRyYXRlLFxuICAgICAgICAgIHByaW9yaXR5OiAoX2ggPSAoX2cgPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucHJpb3JpdHkpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICdoaWdoJyxcbiAgICAgICAgICBuZXR3b3JrUHJpb3JpdHk6IChfayA9IChfaiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5wcmlvcml0eSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogJ2hpZ2gnXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWdvdGlhdGUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoIXRoaXMuZW5naW5lLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwY01hbmFnZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suc2VuZGVyID0geWllbGQgdGhpcy5lbmdpbmUuY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgKF9hID0gb3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjayk7XG4gICAgICAgICAgdHJhY2suc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgaWYgKGlzRmlyZUZveCgpICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICAgIC8qIFJlZmVyIHRvIFJGQyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc1ODcjc2VjdGlvbi02LjEsXG4gICAgICAgICAgICAgICBsaXZla2l0LXNlcnZlciB1c2VzIG1heGF2ZXJhZ2ViaXRyYXRlPTUxMDAwMCBpbiB0aGUgYW5zd2VyIHNkcCB0byBwZXJtaXQgY2xpZW50IHRvXG4gICAgICAgICAgICAgICBwdWJsaXNoIGhpZ2ggcXVhbGl0eSBhdWRpbyB0cmFjay4gQnV0IGZpcmVmb3ggYWx3YXlzIHVzZXMgdGhpcyB2YWx1ZSBhcyB0aGUgYWN0dWFsXG4gICAgICAgICAgICAgICBiaXRyYXRlcywgY2F1c2luZyB0aGUgYXVkaW8gYml0cmF0ZXMgdG8gcmlzZSB0byA1MTBLYnBzIGluIGFueSBzdGVyZW8gY2FzZSB1bmV4cGVjdGVkbHkuXG4gICAgICAgICAgICAgICBTbyB0aGUgY2xpZW50IG5lZWQgdG8gbW9kaWZ5IG1heGF2ZXJyYWdlYml0cmF0ZXMgaW4gYW5zd2VyIHNkcCB0byB1c2VyIHByb3ZpZGVkIHZhbHVlIHRvXG4gICAgICAgICAgICAgICBmaXggdGhlIGlzc3VlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgdHJhY2tUcmFuc2NlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xuICAgICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFjay5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICAgIGNvZGVjOiAnb3B1cycsXG4gICAgICAgICAgICAgICAgbWF4YnI6ICgoX2IgPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhCaXRyYXRlKSA/IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMCA6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFjay5jb2RlYyAmJiBpc1NWQ0NvZGVjKHRyYWNrLmNvZGVjKSAmJiAoKF9jID0gZW5jb2RpbmdzWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4Qml0cmF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xuICAgICAgICAgICAgICBjaWQ6IHJlcS5jaWQsXG4gICAgICAgICAgICAgIGNvZGVjOiB0cmFjay5jb2RlYyxcbiAgICAgICAgICAgICAgbWF4YnI6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBsZXQgdGk7XG4gICAgICBpZiAodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcmV0cyA9IHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpLCBuZWdvdGlhdGUoKV0pO1xuICAgICAgICB0aSA9IHJldHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aSA9IHlpZWxkIHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XG4gICAgICAgIC8vIHNlcnZlciBtaWdodCBub3Qgc3VwcG9ydCB0aGUgY29kZWMgdGhlIGNsaWVudCBoYXMgcmVxdWVzdGVkLCBpbiB0aGF0IGNhc2UsIGZhbGxiYWNrXG4gICAgICAgIC8vIHRvIGEgc3VwcG9ydGVkIGNvZGVjXG4gICAgICAgIGxldCBwcmltYXJ5Q29kZWNNaW1lO1xuICAgICAgICB0aS5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJpbWFyeUNvZGVjTWltZSA9IGNvZGVjLm1pbWVUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmltYXJ5Q29kZWNNaW1lICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQ29kZWMgPSBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhwcmltYXJ5Q29kZWNNaW1lKTtcbiAgICAgICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZmFsbGluZyBiYWNrIHRvIHNlcnZlciBzZWxlY3RlZCBjb2RlYycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgICAgY29kZWM6IHVwZGF0ZWRDb2RlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdXBkYXRlZENvZGVjO1xuICAgICAgICAgICAgLy8gcmVjb21wdXRlIGVuY29kaW5ncyBzaW5jZSBiaXRyYXRlcy9ldGMgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHJlcS53aWR0aCwgcmVxLmhlaWdodCwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIG5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGljYXRpb24gPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKHRyYWNrLmtpbmQsIHRpLCB0cmFjaywge1xuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICB9KTtcbiAgICAgIC8vIHNhdmUgb3B0aW9ucyBmb3Igd2hlbiBpdCBuZWVkcyB0byBiZSByZXB1Ymxpc2hlZCBhZ2FpblxuICAgICAgcHVibGljYXRpb24ub3B0aW9ucyA9IG9wdHM7XG4gICAgICB0cmFjay5zaWQgPSB0aS5zaWQ7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hpbmcgXCIuY29uY2F0KHRyYWNrLmtpbmQsIFwiIHdpdGggZW5jb2RpbmdzXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICB0cmFja0luZm86IHRpXG4gICAgICB9KSk7XG4gICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRyYWNrLnN0YXJ0TW9uaXRvcih0aGlzLmVuZ2luZS5jbGllbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgLy8gc2VuZCBldmVudCBmb3IgcHVibGljYXRpb25cbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9KTtcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsXG4gICAqIHB1Ymxpc2ggYWRkaXRpb25hbCBjb2RlYyB0byBleGlzdGluZyB0cmFja1xuICAgKi9cbiAgcHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIC8vIFRPRE8gcmVtb3ZlIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCB0cmFja3NcbiAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpcyBpdCBub3QgcHVibGlzaGVkPyBpZiBzbyBza2lwXG4gICAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWV4aXN0aW5nUHVibGljYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgcHVibGlzaGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBhIHZpZGVvIHRyYWNrJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBlbmNvZGluZ3MgPSBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3ModHJhY2ssIHZpZGVvQ29kZWMsIG9wdHMpO1xuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcImJhY2t1cCBjb2RlYyBoYXMgYmVlbiBkaXNhYmxlZCwgaWdub3JpbmcgcmVxdWVzdCB0byBhZGQgYWRkaXRpb25hbCBjb2RlYyBmb3IgdHJhY2tcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaW11bGNhc3RUcmFjayA9IHRyYWNrLmFkZFNpbXVsY2FzdFRyYWNrKHZpZGVvQ29kZWMsIGVuY29kaW5ncyk7XG4gICAgICBpZiAoIXNpbXVsY2FzdFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIHR5cGU6IFRyYWNrLmtpbmRUb1Byb3RvKHRyYWNrLmtpbmQpLFxuICAgICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICAgIHNpZDogdHJhY2suc2lkLFxuICAgICAgICBzaW11bGNhc3RDb2RlY3M6IFt7XG4gICAgICAgICAgY29kZWM6IG9wdHMudmlkZW9Db2RlYyxcbiAgICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncyk7XG4gICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lZ290aWF0ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJldHMgPSB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKSwgbmVnb3RpYXRlKCldKTtcbiAgICAgIGNvbnN0IHRpID0gcmV0c1swXTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaGVkIFwiLmNvbmNhdCh2aWRlb0NvZGVjLCBcIiBmb3IgdHJhY2sgXCIpLmNvbmNhdCh0cmFjay5zaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICB0cmFja0luZm86IHRpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgdW5wdWJsaXNoVHJhY2sodHJhY2ssIHN0b3BPblVucHVibGlzaCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKGlzTG9jYWxUcmFjayh0cmFjaykpIHtcbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2UgPSB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcbiAgICAgICAgaWYgKHB1Ymxpc2hQcm9taXNlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbygnYXdhaXRpbmcgcHVibGlzaCBwcm9taXNlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVucHVibGlzaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICB5aWVsZCBwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbG9vayB0aHJvdWdoIGFsbCBwdWJsaXNoZWQgdHJhY2tzIHRvIGZpbmQgdGhlIHJpZ2h0IG9uZXNcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRQdWJsaWNhdGlvbkZvclRyYWNrKHRyYWNrKTtcbiAgICAgIGNvbnN0IHB1YkxvZ0NvbnRleHQgPSBwdWJsaWNhdGlvbiA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VucHVibGlzaGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCkpO1xuICAgICAgaWYgKCFwdWJsaWNhdGlvbiB8fCAhcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgd2FzIG5vdCB1bnB1Ymxpc2hlZCBiZWNhdXNlIG5vIHB1YmxpY2F0aW9uIHdhcyBmb3VuZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCkpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdHJhY2sgPSBwdWJsaWNhdGlvbi50cmFjaztcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLm9uVHJhY2tVbm11dGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1SZXN1bWVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlLCB0aGlzLm9uVHJhY2tGZWF0dXJlVXBkYXRlKTtcbiAgICAgIGlmIChzdG9wT25VbnB1Ymxpc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdG9wT25VbnB1Ymxpc2ggPSAoX2IgPSAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9wT25VbnB1Ymxpc2gpIHtcbiAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2suc3RvcE1vbml0b3IoKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZWdvdGlhdGlvbk5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgdHJhY2tTZW5kZXIgPSB0cmFjay5zZW5kZXI7XG4gICAgICB0cmFjay5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5lbmdpbmUucGNNYW5hZ2VyICYmIHRoaXMuZW5naW5lLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgPCBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCAmJiB0cmFja1NlbmRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xuICAgICAgICAgICAgLy8gaWYgc2VuZGVyIGlzIG5vdCBjdXJyZW50bHkgc2VuZGluZyAoYWZ0ZXIgcmVwbGFjZVRyYWNrKG51bGwpKVxuICAgICAgICAgICAgLy8gcmVtb3ZlVHJhY2sgd291bGQgaGF2ZSBubyBlZmZlY3QuXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgd2UgZW5kIHVwIHN1Y2Nlc3NmdWxseSByZW1vdmluZyB0aGUgdHJhY2ssIG1hbnVhbGx5IHNldFxuICAgICAgICAgICAgLy8gdGhlIHRyYW5zY2VpdmVyIHRvIGluYWN0aXZlXG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFja1NlbmRlcikge1xuICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVuZ2luZS5yZW1vdmVUcmFjayh0cmFja1NlbmRlcikpIHtcbiAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCB0cmFja0luZm9dIG9mIHRyYWNrLnNpbXVsY2FzdENvZGVjcykge1xuICAgICAgICAgICAgICBpZiAodHJhY2tJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZS5yZW1vdmVUcmFjayh0cmFja0luZm8uc2VuZGVyKSkge1xuICAgICAgICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja0luZm8uc2VuZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5zaW11bGNhc3RDb2RlY3MuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdmYWlsZWQgdG8gdW5wdWJsaXNoIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9KTtcbiAgfVxuICB1bnB1Ymxpc2hUcmFja3ModHJhY2tzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spKSk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIodHJhY2sgPT4gISF0cmFjayk7XG4gICAgfSk7XG4gIH1cbiAgcmVwdWJsaXNoQWxsVHJhY2tzKG9wdGlvbnNfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGxldCByZXN0YXJ0VHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChfdGhpczMucmVwdWJsaXNoUHJvbWlzZSkge1xuICAgICAgICAgIHlpZWxkIF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzMywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUHVicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgICAgICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgcHViLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHB1Yi5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwobG9jYWxQdWJzLm1hcChwdWIgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaywgZmFsc2UpO1xuICAgICAgICAgICAgICBpZiAocmVzdGFydFRyYWNrcyAmJiAhdHJhY2suaXNNdXRlZCAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvICYmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykgfHwgaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSAmJiAhdHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBnZW5lcmFsbHkgd2UgbmVlZCB0byByZXN0YXJ0IHRoZSB0cmFjayBiZWZvcmUgcHVibGlzaGluZywgb2Z0ZW4gYSBmdWxsIHJlY29ubmVjdFxuICAgICAgICAgICAgICAgIC8vIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbXB1dGVyIGhhZCBnb25lIHRvIHNsZWVwLlxuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIGV4aXN0aW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgICB0cmFjazogcHViLnRyYWNrU2lkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVwdWJsaXNoUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgeWllbGQgX3RoaXMzLnJlcHVibGlzaFByb21pc2U7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgZGF0YSBwYXlsb2FkIHRvIHRoZSByb29tLiBEYXRhIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGVhY2hcbiAgICogcGFydGljaXBhbnQgaW4gdGhlIHJvb20gaWYgdGhlIGRlc3RpbmF0aW9uIGZpZWxkIGluIHB1Ymxpc2hPcHRpb25zIGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIFVpbnQ4QXJyYXkgb2YgdGhlIHBheWxvYWQuIFRvIHNlbmQgc3RyaW5nIGRhdGEsIHVzZSBUZXh0RW5jb2Rlci5lbmNvZGVcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uYWxseSBzcGVjaWZ5IGEgYHJlbGlhYmxlYCwgYHRvcGljYCBhbmQgYGRlc3RpbmF0aW9uYFxuICAgKi9cbiAgcHVibGlzaERhdGEoZGF0YV8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBvcHRpb25zLnJlbGlhYmxlID8gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFIDogRGF0YVBhY2tldF9LaW5kLkxPU1NZO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgICAgICAgY29uc3QgdG9waWMgPSBvcHRpb25zLnRvcGljO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2FzZTogJ3VzZXInLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBVc2VyUGFja2V0KHtcbiAgICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogX3RoaXM0LmlkZW50aXR5LFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgIHRvcGljXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIF90aGlzNC5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaCBTSVAgRFRNRiBtZXNzYWdlIHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBAcGFyYW0gY29kZSBEVE1GIGNvZGVcbiAgICogQHBhcmFtIGRpZ2l0IERUTUYgZGlnaXRcbiAgICovXG4gIHB1Ymxpc2hEdG1mKGNvZGUsIGRpZ2l0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdzaXBEdG1mJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFNpcERUTUYoe1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGRpZ2l0OiBkaWdpdFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIHNlbmRDaGF0TWVzc2FnZSh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIG1lc3NhZ2U6IHRleHQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYXR0YWNoZWRGaWxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzXG4gICAgICB9O1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdjaGF0TWVzc2FnZScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBDaGF0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1zZyksIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cudGltZXN0YW1wKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNoYXRNZXNzYWdlLCBtc2cpO1xuICAgICAgcmV0dXJuIG1zZztcbiAgICB9KTtcbiAgfVxuICBlZGl0Q2hhdE1lc3NhZ2UoZWRpdFRleHQsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBtc2cgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsTWVzc2FnZSksIHtcbiAgICAgICAgbWVzc2FnZTogZWRpdFRleHQsXG4gICAgICAgIGVkaXRUaW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdjaGF0TWVzc2FnZScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBDaGF0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1zZyksIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cudGltZXN0YW1wKSxcbiAgICAgICAgICAgIGVkaXRUaW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UobXNnLmVkaXRUaW1lc3RhbXApXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZyk7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH0pO1xuICB9XG4gIHNlbmRUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgY29uc3QgdGV4dEluQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgICBjb25zdCB0b3RhbFRleHRMZW5ndGggPSB0ZXh0SW5CeXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgY29uc3QgZmlsZUlkcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRhY2htZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoKSA9PiBjcnlwdG8ucmFuZG9tVVVJRCgpKTtcbiAgICAgIGNvbnN0IHByb2dyZXNzZXMgPSBuZXcgQXJyYXkoZmlsZUlkcyA/IGZpbGVJZHMubGVuZ3RoICsgMSA6IDEpLmZpbGwoMCk7XG4gICAgICBjb25zdCBoYW5kbGVQcm9ncmVzcyA9IChwcm9ncmVzcywgaWR4KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcHJvZ3Jlc3Nlc1tpZHhdID0gcHJvZ3Jlc3M7XG4gICAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBwcm9ncmVzc2VzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XG4gICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB0b3RhbFByb2dyZXNzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbVRleHQoe1xuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdG90YWxTaXplOiB0b3RhbFRleHRMZW5ndGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgdG9waWM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYyxcbiAgICAgICAgYXR0YWNoZWRTdHJlYW1JZHM6IGZpbGVJZHMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHdyaXRlci53cml0ZSh0ZXh0KTtcbiAgICAgIC8vIHNldCB0ZXh0IHBhcnQgb2YgcHJvZ3Jlc3MgdG8gMVxuICAgICAgaGFuZGxlUHJvZ3Jlc3MoMSwgMCk7XG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzKSAmJiBmaWxlSWRzKSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKG9wdGlvbnMuYXR0YWNobWVudHMubWFwKChmaWxlLCBpZHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEZpbGUoZmlsZUlkc1tpZHhdLCBmaWxlLCB7XG4gICAgICAgICAgICB0b3BpYzogb3B0aW9ucy50b3BpYyxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICBvblByb2dyZXNzOiBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZVByb2dyZXNzKHByb2dyZXNzLCBpZHggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cml0ZXIuaW5mbztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWwgQ0FVVElPTiwgbWlnaHQgZ2V0IHJlbW92ZWQgaW4gYSBtaW5vciByZWxlYXNlXG4gICAqL1xuICBzdHJlYW1UZXh0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHN0cmVhbUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0cmVhbUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHRvcGljOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9waWMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICBzaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG90YWxTaXplLFxuICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBEYXRhU3RyZWFtX0hlYWRlcih7XG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBtaW1lVHlwZTogaW5mby5taW1lVHlwZSxcbiAgICAgICAgdG9waWM6IGluZm8udG9waWMsXG4gICAgICAgIHRpbWVzdGFtcDogbnVtYmVyVG9CaWdJbnQoaW5mby50aW1lc3RhbXApLFxuICAgICAgICB0b3RhbExlbmd0aDogbnVtYmVyVG9CaWdJbnQob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvdGFsU2l6ZSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGluZm8uYXR0cmlidXRlcyxcbiAgICAgICAgY29udGVudEhlYWRlcjoge1xuICAgICAgICAgIGNhc2U6ICd0ZXh0SGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fVGV4dEhlYWRlcih7XG4gICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICAgIGF0dGFjaGVkU3RyZWFtSWRzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNoZWRTdHJlYW1JZHMsXG4gICAgICAgICAgICByZXBseVRvU3RyZWFtSWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXBseVRvU3RyZWFtSWQsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUpID09PSAndXBkYXRlJyA/IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZS5VUERBVEUgOiBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUuQ1JFQVRFXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3N0cmVhbUhlYWRlcicsXG4gICAgICAgICAgdmFsdWU6IGhlYWRlclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIGxldCBjaHVua0lkID0gMDtcbiAgICAgIGNvbnN0IGxvY2FsUCA9IHRoaXM7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgIC8vIEltcGxlbWVudCB0aGUgc2lua1xuICAgICAgICB3cml0ZSh0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGV4dEJ5dGVDaHVuayBvZiBzcGxpdFV0ZjgodGV4dCwgU1RSRUFNX0NIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgICAgIHlpZWxkIGxvY2FsUC5lbmdpbmUud2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBEYXRhU3RyZWFtX0NodW5rKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0Qnl0ZUNodW5rLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgIGNodW5rSW5kZXg6IG51bWJlclRvQmlnSW50KGNodW5rSWQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBjaHVua1BhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1DaHVuaycsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB5aWVsZCBsb2NhbFAuZW5naW5lLnNlbmREYXRhUGFja2V0KGNodW5rUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgICAgICBjaHVua0lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IERhdGFTdHJlYW1fVHJhaWxlcih7XG4gICAgICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtVHJhaWxlcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWlsZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBsb2NhbFAuZW5naW5lLnNlbmREYXRhUGFja2V0KHRyYWlsZXJQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0KGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTaW5rIGVycm9yOicsIGVycik7XG4gICAgICAgICAgLy8gVE9ETyBoYW5kbGUgYWJvcnRzIHRvIHNpZ25hbCBzb21ldGhpbmcgdG8gcmVjZWl2ZXIgc2lkZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxldCBvbkVuZ2luZUNsb3NlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgbG9jYWxQLmVuZ2luZS5vbmNlKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpO1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFRleHRTdHJlYW1Xcml0ZXIod3JpdGFibGVTdHJlYW0sIGluZm8sICgpID0+IHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkVuZ2luZUNsb3NlKSk7XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0pO1xuICB9XG4gIHNlbmRGaWxlKGZpbGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgeWllbGQgdGhpcy5fc2VuZEZpbGUoc3RyZWFtSWQsIGZpbGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHN0cmVhbUlkXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIF9zZW5kRmlsZShzdHJlYW1JZCwgZmlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbUJ5dGVzKHtcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHRvdGFsU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIG1pbWVUeXBlOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGUudHlwZSxcbiAgICAgICAgdG9waWM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYyxcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZpbGUuc3RyZWFtKCkuZ2V0UmVhZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZG9uZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm4gd3JpdGVyLmluZm87XG4gICAgfSk7XG4gIH1cbiAgc3RyZWFtQnl0ZXMob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RyZWFtSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICBtaW1lVHlwZTogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgdG9waWM6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUsXG4gICAgICAgIG5hbWU6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAndW5rbm93bidcbiAgICAgIH07XG4gICAgICBjb25zdCBoZWFkZXIgPSBuZXcgRGF0YVN0cmVhbV9IZWFkZXIoe1xuICAgICAgICB0b3RhbExlbmd0aDogbnVtYmVyVG9CaWdJbnQoKF9lID0gaW5mby5zaXplKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwKSxcbiAgICAgICAgbWltZVR5cGU6IGluZm8ubWltZVR5cGUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICB0b3BpYzogaW5mby50b3BpYyxcbiAgICAgICAgdGltZXN0YW1wOiBudW1iZXJUb0JpZ0ludChEYXRlLm5vdygpKSxcbiAgICAgICAgY29udGVudEhlYWRlcjoge1xuICAgICAgICAgIGNhc2U6ICdieXRlSGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fQnl0ZUhlYWRlcih7XG4gICAgICAgICAgICBuYW1lOiBpbmZvLm5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdzdHJlYW1IZWFkZXInLFxuICAgICAgICAgIHZhbHVlOiBoZWFkZXJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICBsZXQgY2h1bmtJZCA9IDA7XG4gICAgICBjb25zdCB3cml0ZU11dGV4ID0gbmV3IF8oKTtcbiAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuZW5naW5lO1xuICAgICAgY29uc3QgbG9nID0gdGhpcy5sb2c7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHdyaXRlTXV0ZXgubG9jaygpO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2hpbGUgKGJ5dGVPZmZzZXQgPCBjaHVuay5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQ2h1bmsgPSBjaHVuay5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgU1RSRUFNX0NIVU5LX1NJWkUpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGVuZ2luZS53YWl0Rm9yQnVmZmVyU3RhdHVzTG93KERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtQ2h1bmsnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN1YkNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgICAgICAgIGNodW5rSW5kZXg6IG51bWJlclRvQmlnSW50KGNodW5rSWQpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQgZW5naW5lLnNlbmREYXRhUGFja2V0KGNodW5rUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgICAgICAgIGNodW5rSWQgKz0gMTtcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IHN1YkNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHJhaWxlciA9IG5ldyBEYXRhU3RyZWFtX1RyYWlsZXIoe1xuICAgICAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFpbGVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgZW5naW5lLnNlbmREYXRhUGFja2V0KHRyYWlsZXJQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0KGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcignU2luayBlcnJvcjonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJ5dGVXcml0ZXIgPSBuZXcgQnl0ZVN0cmVhbVdyaXRlcih3cml0YWJsZVN0cmVhbSwgaW5mbyk7XG4gICAgICByZXR1cm4gYnl0ZVdyaXRlcjtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgYW4gUlBDIGNhbGwgdG8gYSByZW1vdGUgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIGluaXRpYXRpbmcgdGhlIFJQQyBjYWxsLCBzZWUge0BsaW5rIFBlcmZvcm1ScGNQYXJhbXN9XG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHBheWxvYWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICAgKiBAdGhyb3dzIEVycm9yIG9uIGZhaWx1cmUuIERldGFpbHMgaW4gYG1lc3NhZ2VgLlxuICAgKi9cbiAgcGVyZm9ybVJwYyhfYSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICBsZXQge1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXR5LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHJlc3BvbnNlVGltZW91dCA9IDEwMDAwXG4gICAgICB9ID0gX3JlZjM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbWF4Um91bmRUcmlwTGF0ZW5jeSA9IDIwMDA7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXM1LCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGgocGF5bG9hZCkgPiBNQVhfUEFZTE9BRF9CWVRFUykge1xuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ1JFUVVFU1RfUEFZTE9BRF9UT09fTEFSR0UnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5lbmdpbmUubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucygoX2QgPSAoX2MgPSB0aGlzLmVuZ2luZS5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudmVyc2lvbiwgJzEuOC4wJykgPCAwKSB7XG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfU0VSVkVSJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoUnBjUmVxdWVzdChkZXN0aW5hdGlvbklkZW50aXR5LCBpZCwgbWV0aG9kLCBwYXlsb2FkLCByZXNwb25zZVRpbWVvdXQgLSBtYXhSb3VuZFRyaXBMYXRlbmN5KTtcbiAgICAgICAgICBjb25zdCBhY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdDT05ORUNUSU9OX1RJTUVPVVQnKSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXRJZCk7XG4gICAgICAgICAgfSwgbWF4Um91bmRUcmlwTGF0ZW5jeSk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5zZXQoaWQsIHtcbiAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFja1RpbWVvdXRJZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZGVzdGluYXRpb25JZGVudGl0eVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdSRVNQT05TRV9USU1FT1VUJykpO1xuICAgICAgICAgIH0sIHJlc3BvbnNlVGltZW91dCk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLnNldChpZCwge1xuICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3BvbnNlUGF5bG9hZCwgcmVzcG9uc2VFcnJvcikgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQWNrcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdSUEMgcmVzcG9uc2UgcmVjZWl2ZWQgYmVmb3JlIGFjaycsIGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFja1RpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2VFcnJvcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZVBheWxvYWQgIT09IG51bGwgJiYgcmVzcG9uc2VQYXlsb2FkICE9PSB2b2lkIDAgPyByZXNwb25zZVBheWxvYWQgOiAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBkZXN0aW5hdGlvbklkZW50aXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByb29tLnJlZ2lzdGVyUnBjTWV0aG9kYCBpbnN0ZWFkXG4gICAqL1xuICByZWdpc3RlclJwY01ldGhvZChtZXRob2QsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5ycGNIYW5kbGVycy5oYXMobWV0aG9kKSkge1xuICAgICAgdGhpcy5sb2cud2FybihcInlvdSdyZSBvdmVycmlkaW5nIHRoZSBSUEMgaGFuZGxlciBmb3IgbWV0aG9kIFwiLmNvbmNhdChtZXRob2QsIFwiLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvclwiKSk7XG4gICAgfVxuICAgIHRoaXMucnBjSGFuZGxlcnMuc2V0KG1ldGhvZCwgaGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgcm9vbS51bnJlZ2lzdGVyUnBjTWV0aG9kYCBpbnN0ZWFkXG4gICAqL1xuICB1bnJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCkge1xuICAgIHRoaXMucnBjSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2wgd2hvIGNhbiBzdWJzY3JpYmUgdG8gTG9jYWxQYXJ0aWNpcGFudCdzIHB1Ymxpc2hlZCB0cmFja3MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGFsbCBwYXJ0aWNpcGFudHMgY2FuIHN1YnNjcmliZS4gVGhpcyBhbGxvd3MgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlclxuICAgKiB3aG8gaXMgYWJsZSB0byBzdWJzY3JpYmUgYXQgYSBwYXJ0aWNpcGFudCBhbmQgdHJhY2sgbGV2ZWwuXG4gICAqXG4gICAqIE5vdGU6IGlmIGFjY2VzcyBpcyBnaXZlbiBhdCBhIHRyYWNrLWxldmVsIChpLmUuIGJvdGggW2FsbFBhcnRpY2lwYW50c0FsbG93ZWRdIGFuZFxuICAgKiBbUGFydGljaXBhbnRUcmFja1Blcm1pc3Npb24uYWxsVHJhY2tzQWxsb3dlZF0gYXJlIGZhbHNlKSwgYW55IG5ld2VyIHB1Ymxpc2hlZCB0cmFja3NcbiAgICogd2lsbCBub3QgZ3JhbnQgcGVybWlzc2lvbnMgdG8gYW55IHBhcnRpY2lwYW50cyBhbmQgd2lsbCByZXF1aXJlIGEgc3Vic2VxdWVudFxuICAgKiBwZXJtaXNzaW9ucyB1cGRhdGUgdG8gYWxsb3cgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYWxsUGFydGljaXBhbnRzQWxsb3dlZCBBbGxvd3MgYWxsIHBhcnRpY2lwYW50cyB0byBzdWJzY3JpYmUgYWxsIHRyYWNrcy5cbiAgICogIFRha2VzIHByZWNlZGVuY2Ugb3ZlciBbW3BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uc11dIGlmIHNldCB0byB0cnVlLlxuICAgKiAgQnkgZGVmYXVsdCB0aGlzIGlzIHNldCB0byB0cnVlLlxuICAgKiBAcGFyYW0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zIEZ1bGwgbGlzdCBvZiBpbmRpdmlkdWFsIHBlcm1pc3Npb25zIHBlclxuICAgKiAgcGFydGljaXBhbnQvdHJhY2suIEFueSBvbWl0dGVkIHBhcnRpY2lwYW50cyB3aWxsIG5vdCByZWNlaXZlIGFueSBwZXJtaXNzaW9ucy5cbiAgICovXG4gIHNldFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoYWxsUGFydGljaXBhbnRzQWxsb3dlZCkge1xuICAgIGxldCBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gYWxsUGFydGljaXBhbnRzQWxsb3dlZDtcbiAgICBpZiAoIXRoaXMuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUluY29taW5nUnBjQWNrKHJlcXVlc3RJZCkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnBlbmRpbmdBY2tzLmdldChyZXF1ZXN0SWQpO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyLnJlc29sdmUoKTtcbiAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjayByZWNlaXZlZCBmb3IgdW5leHBlY3RlZCBSUEMgcmVxdWVzdCcsIHJlcXVlc3RJZCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUluY29taW5nUnBjUmVzcG9uc2UocmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcikge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIucmVzb2x2ZShwYXlsb2FkLCBlcnJvcik7XG4gICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Jlc3BvbnNlIHJlY2VpdmVkIGZvciB1bmV4cGVjdGVkIFJQQyByZXF1ZXN0JywgcmVxdWVzdElkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaXNoUnBjUmVxdWVzdChkZXN0aW5hdGlvbklkZW50aXR5LCByZXF1ZXN0SWQsIG1ldGhvZCwgcGF5bG9hZCwgcmVzcG9uc2VUaW1lb3V0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbZGVzdGluYXRpb25JZGVudGl0eV0sXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAncnBjUmVxdWVzdCcsXG4gICAgICAgICAgdmFsdWU6IG5ldyBScGNSZXF1ZXN0KHtcbiAgICAgICAgICAgIGlkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lb3V0TXM6IHJlc3BvbnNlVGltZW91dCxcbiAgICAgICAgICAgIHZlcnNpb246IDFcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBmb3IgKGNvbnN0IFtpZCwge1xuICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGVuZGluZ0lkZW50aXR5XG4gICAgfV0gb2YgdGhpcy5wZW5kaW5nQWNrcykge1xuICAgICAgaWYgKHBlbmRpbmdJZGVudGl0eSA9PT0gcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkLCB7XG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwZW5kaW5nSWRlbnRpdHksXG4gICAgICByZXNvbHZlXG4gICAgfV0gb2YgdGhpcy5wZW5kaW5nUmVzcG9uc2VzKSB7XG4gICAgICBpZiAocGVuZGluZ0lkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgIHJlc29sdmUobnVsbCwgUnBjRXJyb3IuYnVpbHRJbignUkVDSVBJRU5UX0RJU0NPTk5FQ1RFRCcpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3MoY29kZWNzKSB7XG4gICAgdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzID0gY29kZWNzLmZpbHRlcihjID0+IGMubWltZS5zcGxpdCgnLycpWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlbycpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgaWYgKGluZm8uc2lkICE9PSB0aGlzLnNpZCkge1xuICAgICAgLy8gZHJvcCB1cGRhdGVzIHRoYXQgc3BlY2lmeSBhIHdyb25nIHNpZC5cbiAgICAgIC8vIHRoZSBzaWQgZm9yIGxvY2FsIHBhcnRpY2lwYW50IGlzIG9ubHkgZXhwbGljaXRseSBzZXQgb24gam9pbiBhbmQgZnVsbCByZWNvbm5lY3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBtdXRlIHN0YXR1cy5cbiAgICAvLyBpZiBzZXJ2ZXIncyB0cmFjayBtdXRlIHN0YXR1cyBkb2Vzbid0IG1hdGNoIGFjdHVhbCwgd2UnbGwgaGF2ZSB0byB1cGRhdGVcbiAgICAvLyB0aGUgc2VydmVyJ3MgY29weVxuICAgIGluZm8udHJhY2tzLmZvckVhY2godGkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRpLnNpZCk7XG4gICAgICBpZiAocHViKSB7XG4gICAgICAgIGNvbnN0IG11dGVkT25TZXJ2ZXIgPSBwdWIuaXNNdXRlZCB8fCAoKF9iID0gKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcHN0cmVhbVBhdXNlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpO1xuICAgICAgICBpZiAobXV0ZWRPblNlcnZlciAhPT0gdGkubXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgc2VydmVyIG11dGUgc3RhdGUgYWZ0ZXIgcmVjb25jaWxlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSksIHtcbiAgICAgICAgICAgIG11dGVkT25TZXJ2ZXJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRNdXRlVHJhY2sodGkuc2lkLCBtdXRlZE9uU2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spIHtcbiAgICBsZXQgcHVibGljYXRpb247XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgaWYgKCFsb2NhbFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgbG9va3Mgb3Zlcmx5IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGlzIG9iamVjdCB0cmVlXG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayhsb2NhbFRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayhsb2NhbFRyYWNrKSkge1xuICAgICAgICAgIGlmIChsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhY2sgPT09IGxvY2FsVHJhY2spIHtcbiAgICAgICAgcHVibGljYXRpb24gPSBwdWI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICB9XG4gIHdhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgd2FpdEZvclBlbmRpbmdUaW1lb3V0ID0gMTAwMDA7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgd2hpbGUgKERhdGUubm93KCkgPCBzdGFydFRpbWUgKyB3YWl0Rm9yUGVuZGluZ1RpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VFbnRyeSA9IEFycmF5LmZyb20odGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmVudHJpZXMoKSkuZmluZChfcmVmNCA9PiB7XG4gICAgICAgICAgbGV0IFtwZW5kaW5nVHJhY2tdID0gX3JlZjQ7XG4gICAgICAgICAgcmV0dXJuIHBlbmRpbmdUcmFjay5zb3VyY2UgPT09IHNvdXJjZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwdWJsaXNoUHJvbWlzZUVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHB1Ymxpc2hQcm9taXNlRW50cnlbMV07XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2xlZXAoMjApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgY29uc3RydWN0b3Ioa2luZCwgdGksIGF1dG9TdWJzY3JpYmUsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuYWxsb3dlZCA9IHRydWU7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5ISUdIO1xuICAgIHRoaXMuaGFuZGxlRW5kZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdHJhY2spO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gdmlzaWJsZSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImFkYXB0aXZlc3RyZWFtIHZpZGVvIHZpc2liaWxpdHkgXCIuY29uY2F0KHRoaXMudHJhY2tTaWQsIFwiLCB2aXNpYmxlPVwiKS5jb25jYXQodmlzaWJsZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmRpc2FibGVkID0gIXZpc2libGU7XG4gICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UgPSBkaW1lbnNpb25zID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gZGltZW5zaW9ucyBcIi5jb25jYXQoZGltZW5zaW9ucy53aWR0aCwgXCJ4XCIpLmNvbmNhdChkaW1lbnNpb25zLmhlaWdodCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gYXV0b1N1YnNjcmliZTtcbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgdG8gdGhpcyByZW1vdGUgdHJhY2tcbiAgICogQHBhcmFtIHN1YnNjcmliZWQgdHJ1ZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgZmFsc2UgdG8gdW5zdWJzY3JpYmVcbiAgICovXG4gIHNldFN1YnNjcmliZWQoc3Vic2NyaWJlZCkge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgIC8vIHJlc2V0IGFsbG93ZWQgc3RhdHVzIHdoZW4gZGVzaXJlZCBzdWJzY3JpcHRpb24gc3RhdGUgY2hhbmdlc1xuICAgIC8vIHNlcnZlciB3aWxsIG5vdGlmeSBjbGllbnQgdmlhIHNpZ25hbCBtZXNzYWdlIGlmIGl0J3Mgbm90IGFsbG93ZWRcbiAgICBpZiAoc3Vic2NyaWJlZCkge1xuICAgICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIHN1YnNjcmliZTogdGhpcy5zdWJzY3JpYmVkLFxuICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtuZXcgUGFydGljaXBhbnRUcmFja3Moe1xuICAgICAgICAvLyBzZW5kaW5nIGFuIGVtcHR5IHBhcnRpY2lwYW50IGlkIHNpbmNlIFRyYWNrUHVibGljYXRpb24gZG9lc24ndCBrZWVwIGl0XG4gICAgICAgIC8vIHRoaXMgaXMgZmlsbGVkIGluIGJ5IHRoZSBwYXJ0aWNpcGFudCB0aGF0IHJlY2VpdmVzIHRoaXMgbWVzc2FnZVxuICAgICAgICBwYXJ0aWNpcGFudFNpZDogJycsXG4gICAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdXG4gICAgICB9KV1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1Yik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICB9XG4gIGdldCBzdWJzY3JpcHRpb25TdGF0dXMoKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5VbnN1YnNjcmliZWQ7XG4gICAgfVxuICAgIGlmICghc3VwZXIuaXNTdWJzY3JpYmVkKSB7XG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuRGVzaXJlZDtcbiAgICB9XG4gICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlN1YnNjcmliZWQ7XG4gIH1cbiAgZ2V0IHBlcm1pc3Npb25TdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZCA/IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5BbGxvd2VkIDogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLk5vdEFsbG93ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0cmFjayBpcyBzdWJzY3JpYmVkLCBhbmQgcmVhZHkgZm9yIHBsYXliYWNrXG4gICAqL1xuICBnZXQgaXNTdWJzY3JpYmVkKCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc1N1YnNjcmliZWQ7XG4gIH1cbiAgLy8gcmV0dXJucyBjbGllbnQncyBkZXNpcmUgdG8gc3Vic2NyaWJlIHRvIGEgdHJhY2ssIGFsc28gdHJ1ZSBpZiBhdXRvU3Vic2NyaWJlIGlzIGVuYWJsZWRcbiAgZ2V0IGlzRGVzaXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVkICE9PSBmYWxzZTtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZDtcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIGRpc2FibGUgc2VydmVyIGZyb20gc2VuZGluZyBkb3duIGRhdGEgZm9yIHRoaXMgdHJhY2suIHRoaXMgaXMgdXNlZnVsIHdoZW5cbiAgICogdGhlIHBhcnRpY2lwYW50IGlzIG9mZiBzY3JlZW4sIHlvdSBtYXkgZGlzYWJsZSBzdHJlYW1pbmcgZG93biB0aGVpciB2aWRlb1xuICAgKiB0byByZWR1Y2UgYmFuZHdpZHRoIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0gZW5hYmxlZFxuICAgKi9cbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuZGlzYWJsZWQgPT09ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBmb3IgdHJhY2tzIHRoYXQgc3VwcG9ydCBzaW11bGNhc3RpbmcsIGFkanVzdCBzdWJzY3JpYmVkIHF1YWxpdHlcbiAgICpcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSB0aGUgY2xpZW50IGNhbiBhY2NlcHQuIGlmIG5ldHdvcmtcbiAgICogYmFuZHdpZHRoIGRvZXMgbm90IGFsbG93LCBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZHVjZSBxdWFsaXR5IHRvXG4gICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXG4gICAqL1xuICBzZXRWaWRlb1F1YWxpdHkocXVhbGl0eSkge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPT09IHF1YWxpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gcXVhbGl0eTtcbiAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIHNldFZpZGVvRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCgoX2EgPSB0aGlzLnZpZGVvRGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gZGltZW5zaW9ucy53aWR0aCAmJiAoKF9iID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBkaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIHNldFZpZGVvRlBTKGZwcykge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzUmVtb3RlVmlkZW9UcmFjayh0aGlzLnRyYWNrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcHMgPT09IGZwcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZwcyA9IGZwcztcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIGdldCB2aWRlb1F1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZUcmFjayA9IHRoaXMudHJhY2s7XG4gICAgaWYgKHByZXZUcmFjayA9PT0gdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZUcmFjaykge1xuICAgICAgLy8gdW5yZWdpc3RlciBsaXN0ZW5lclxuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICBwcmV2VHJhY2suZGV0YWNoKCk7XG4gICAgICBwcmV2VHJhY2suc3RvcE1vbml0b3IoKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldlRyYWNrKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc2lkID0gdGhpcy50cmFja1NpZDtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2spO1xuICAgIH1cbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRBbGxvd2VkKGFsbG93ZWQpIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgdGhpcy5hbGxvd2VkID0gYWxsb3dlZDtcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRTdWJzY3JpcHRpb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgc3VwZXIudXBkYXRlSW5mbyhpbmZvKTtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGFNdXRlZCA9IHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLnNldE11dGVkKGluZm8ubXV0ZWQpO1xuICAgIH0gZWxzZSBpZiAocHJldk1ldGFkYXRhTXV0ZWQgIT09IGluZm8ubXV0ZWQpIHtcbiAgICAgIHRoaXMuZW1pdChpbmZvLm11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfVxuICB9XG4gIGVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNTdGF0dXMpIHtcbiAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgaWYgKHByZXZpb3VzU3RhdHVzID09PSBjdXJyZW50U3RhdHVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIGN1cnJlbnRTdGF0dXMsIHByZXZpb3VzU3RhdHVzKTtcbiAgfVxuICBlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvblN0YXR1cyA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBpZiAoY3VycmVudFBlcm1pc3Npb25TdGF0dXMgIT09IHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHRoaXMucGVybWlzc2lvblN0YXR1cywgcHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdhZGFwdGl2ZSBzdHJlYW0gaXMgZW5hYmxlZCwgY2Fubm90IGNoYW5nZSB2aWRlbyB0cmFjayBzZXR0aW5ncycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0Rlc2lyZWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2Nhbm5vdCB1cGRhdGUgdHJhY2sgc2V0dGluZ3Mgd2hlbiBub3Qgc3Vic2NyaWJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBpc0FkYXB0aXZlU3RyZWFtKCkge1xuICAgIHJldHVybiBpc1JlbW90ZVZpZGVvVHJhY2sodGhpcy50cmFjaykgJiYgdGhpcy50cmFjay5pc0FkYXB0aXZlU3RyZWFtO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBlbWl0VHJhY2tVcGRhdGUoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncyh7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgZnBzOiB0aGlzLmZwc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9ucykge1xuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgfVxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVNldHRpbmdzLCBzZXR0aW5ncyk7XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGZyb21QYXJ0aWNpcGFudEluZm8oc2lnbmFsQ2xpZW50LCBwaSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVtb3RlUGFydGljaXBhbnQoc2lnbmFsQ2xpZW50LCBwaS5zaWQsIHBpLmlkZW50aXR5LCBwaS5uYW1lLCBwaS5tZXRhZGF0YSwgcGkuYXR0cmlidXRlcywgbG9nZ2VyT3B0aW9ucywgcGkua2luZCk7XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIubG9nQ29udGV4dCksIHtcbiAgICAgIHJwSUQ6IHRoaXMuc2lkLFxuICAgICAgcmVtb3RlUGFydGljaXBhbnQ6IHRoaXMuaWRlbnRpdHlcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHNpZ25hbENsaWVudCwgc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogUGFydGljaXBhbnRJbmZvX0tpbmQuU1RBTkRBUkQ7XG4gICAgc3VwZXIoc2lkLCBpZGVudGl0eSB8fCAnJywgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMsIGtpbmQpO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZvbHVtZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKSB7XG4gICAgc3VwZXIuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgLy8gcmVnaXN0ZXIgYWN0aW9uIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kIHVwZGF0ZSBzZXR0aW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViID0+IHtcbiAgICAgIHN1Yi5wYXJ0aWNpcGFudFRyYWNrcy5mb3JFYWNoKHB0ID0+IHtcbiAgICAgICAgcHQucGFydGljaXBhbnRTaWQgPSB0aGlzLnNpZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHN0YXR1cyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHN0YXR1cyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2sgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCBwcmV2aW91c1RyYWNrID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCBwcmV2aW91c1RyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBwdWJsaWNhdGlvbi50cmFja1NpZCwgZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGdldFRyYWNrUHVibGljYXRpb24oc291cmNlKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIGdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHNldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBhdWRpbyB0cmFja1xuICAgKiBieSBkZWZhdWx0LCB0aGlzIGFmZmVjdHMgdGhlIG1pY3JvcGhvbmUgcHVibGljYXRpb25cbiAgICogYSBkaWZmZXJlbnQgc291cmNlIGNhbiBiZSBwYXNzZWQgaW4gYXMgYSBzZWNvbmQgYXJndW1lbnRcbiAgICogaWYgbm8gdHJhY2sgZXhpc3RzIHRoZSB2b2x1bWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIG1pY3JvcGhvbmUgdHJhY2sgaXMgYWRkZWRcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrLnNldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9uIHRoZSBwYXJ0aWNpcGFudCdzIG1pY3JvcGhvbmUgdHJhY2tcbiAgICovXG4gIGdldFZvbHVtZSgpIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICBjb25zdCBhdWRpb1B1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgcmV0dXJuIGF1ZGlvUHVibGljYXRpb24udHJhY2suZ2V0Vm9sdW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZvbHVtZU1hcC5nZXQoc291cmNlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHNpZCwgbWVkaWFTdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCB0cmllc0xlZnQpIHtcbiAgICAvLyBmaW5kIHRoZSB0cmFjayBwdWJsaWNhdGlvblxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBtZWRpYSB0cmFjayB0byBhcnJpdmUgYmVmb3JlIHBhcnRpY2lwYW50IGluZm9cbiAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzaWQpO1xuICAgIC8vIGl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGRpZG4ndCBob25vciBvdXIgb3JpZ2luYWwgdHJhY2sgaWRcbiAgICAvLyBGaXJlRm94IHdvdWxkIHVzZSBpdHMgb3duIGxvY2FsIHV1aWQgaW5zdGVhZCBvZiBzZXJ2ZXIgdHJhY2sgaWRcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAoIXNpZC5zdGFydHNXaXRoKCdUUicpKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0eXBlXG4gICAgICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICBpZiAoIXB1YmxpY2F0aW9uICYmIG1lZGlhVHJhY2sua2luZCA9PT0gcC5raW5kLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIHdlIGNvdWxkbid0IGxvY2F0ZSB0aGUgdHJhY2ssIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgbWV0YWRhdGEgaGFzbid0XG4gICAgLy8geWV0IGFycml2ZWQuIFdhaXQgYSBiaXQgbG9uZ2VyIGZvciBpdCB0byBhcnJpdmUsIG9yIGZpcmUgYW4gZXJyb3JcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSAwKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZmluZCBwdWJsaXNoZWQgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICB0cmFja1NpZDogc2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmllc0xlZnQgPT09IHVuZGVmaW5lZCkgdHJpZXNMZWZ0ID0gMjA7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCBzaWQsIG1lZGlhU3RyZWFtLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgdHJpZXNMZWZ0IC0gMSk7XG4gICAgICB9LCAxNTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcigndW5hYmxlIHRvIHN1YnNjcmliZSBiZWNhdXNlIE1lZGlhU3RyZWFtVHJhY2sgaXMgZW5kZWQuIERvIG5vdCBjYWxsIE1lZGlhU3RyZWFtVHJhY2suc3RvcCgpJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzVmlkZW8gPSBtZWRpYVRyYWNrLmtpbmQgPT09ICd2aWRlbyc7XG4gICAgbGV0IHRyYWNrO1xuICAgIGlmIChpc1ZpZGVvKSB7XG4gICAgICB0cmFjayA9IG5ldyBSZW1vdGVWaWRlb1RyYWNrKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjayA9IG5ldyBSZW1vdGVBdWRpb1RyYWNrKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF1ZGlvT3V0cHV0KTtcbiAgICB9XG4gICAgLy8gc2V0IHRyYWNrIGluZm9cbiAgICB0cmFjay5zb3VyY2UgPSBwdWJsaWNhdGlvbi5zb3VyY2U7XG4gICAgLy8ga2VlcCBwdWJsaWNhdGlvbidzIG11dGVkIHN0YXR1c1xuICAgIHRyYWNrLmlzTXV0ZWQgPSBwdWJsaWNhdGlvbi5pc011dGVkO1xuICAgIHRyYWNrLnNldE1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICB0cmFjay5zdGFydCgpO1xuICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHRyYWNrKTtcbiAgICAvLyBzZXQgcGFydGljaXBhbnQgdm9sdW1lcyBvbiBuZXcgYXVkaW8gdHJhY2tzXG4gICAgaWYgKHRoaXMudm9sdW1lTWFwLmhhcyhwdWJsaWNhdGlvbi5zb3VyY2UpICYmIGlzUmVtb3RlVHJhY2sodHJhY2spICYmIGlzQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgIHRyYWNrLnNldFZvbHVtZSh0aGlzLnZvbHVtZU1hcC5nZXQocHVibGljYXRpb24uc291cmNlKSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBoYXNNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnBhcnRpY2lwYW50SW5mbztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQoc2lkKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHNpZCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gd2UgYXJlIGdldHRpbmcgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdHJhY2tzLCByZWNvbmNpbGUgaW4gaGVyZVxuICAgIC8vIGFuZCBzZW5kIG91dCBldmVudHMgZm9yIGNoYW5nZXNcbiAgICAvLyByZWNvbmNpbGUgdHJhY2sgcHVibGljYXRpb25zLCBwdWJsaXNoIGV2ZW50cyBvbmx5IGlmIG1ldGFkYXRhIGlzIGFscmVhZHkgdGhlcmVcbiAgICAvLyBpLmUuIGNoYW5nZXMgc2luY2UgdGhlIGxvY2FsIHBhcnRpY2lwYW50IGhhcyBqb2luZWRcbiAgICBjb25zdCB2YWxpZFRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBuZXdUcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQodGkuc2lkKTtcbiAgICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgICAgLy8gbmV3IHB1YmxpY2F0aW9uXG4gICAgICAgIGNvbnN0IGtpbmQgPSBUcmFjay5raW5kRnJvbVByb3RvKHRpLnR5cGUpO1xuICAgICAgICBpZiAoIWtpbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHVibGljYXRpb24gPSBuZXcgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbihraW5kLCB0aSwgKF9hID0gdGhpcy5zaWduYWxDbGllbnQuY29ubmVjdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvU3Vic2NyaWJlLCB7XG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgbG9nZ2VyTmFtZTogKF9iID0gdGhpcy5sb2dnZXJPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9nZ2VyTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICAgIG5ld1RyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmluZChwdWJsaXNoZWRUcmFjayA9PiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IChwdWJsaWNhdGlvbiA9PT0gbnVsbCB8fCBwdWJsaWNhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHVibGljYXRpb24uc291cmNlKSk7XG4gICAgICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgcHVibGljYXRpb24uc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicmVjZWl2ZWQgYSBzZWNvbmQgdHJhY2sgcHVibGljYXRpb24gZm9yIFwiLmNvbmNhdCh0aGlzLmlkZW50aXR5LCBcIiB3aXRoIHRoZSBzYW1lIHNvdXJjZTogXCIpLmNvbmNhdChwdWJsaWNhdGlvbi5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIG9sZFRyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSksXG4gICAgICAgICAgICBuZXdUcmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbilcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgfVxuICAgICAgdmFsaWRUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIC8vIGRldGVjdCByZW1vdmVkIHRyYWNrc1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICBpZiAoIXZhbGlkVHJhY2tzLmhhcyhwdWJsaWNhdGlvbi50cmFja1NpZCkpIHtcbiAgICAgICAgdGhpcy5sb2cudHJhY2UoJ2RldGVjdGVkIHJlbW92ZWQgdHJhY2sgb24gcmVtb3RlIHBhcnRpY2lwYW50LCB1bnB1Ymxpc2hpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pKSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGFsd2F5cyBlbWl0IGV2ZW50cyBmb3IgbmV3IHB1YmxpY2F0aW9ucywgUm9vbSB3aWxsIG5vdCBmb3J3YXJkIHRoZW0gdW5sZXNzIGl0J3MgcmVhZHlcbiAgICBuZXdUcmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdW5wdWJsaXNoVHJhY2soc2lkLCBzZW5kVW5wdWJsaXNoKSB7XG4gICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldChzaWQpO1xuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWxzbyBzZW5kIHVuc3Vic2NyaWJlLCBpZiB0cmFjayBpcyBhY3RpdmVseSBzdWJzY3JpYmVkXG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tcbiAgICB9ID0gcHVibGljYXRpb247XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5zdG9wKCk7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdHJhY2sgZnJvbSBtYXBzIG9ubHkgYWZ0ZXIgdW5zdWJzY3JpYmVkIGhhcyBiZWVuIGZpcmVkXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5kZWxldGUoc2lkKTtcbiAgICAvLyByZW1vdmUgZnJvbSB0aGUgcmlnaHQgdHlwZSBtYXBcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHNlbmRVbnB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0QXVkaW9PdXRwdXQob3V0cHV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuYXVkaW9PdXRwdXQgPSBvdXRwdXQ7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHB1Yi50cmFjaykgJiYgaXNSZW1vdGVUcmFjayhwdWIudHJhY2spKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwdWIudHJhY2suc2V0U2lua0lkKChfYSA9IG91dHB1dC5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2RlZmF1bHQnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB0aGlzLmxvZy50cmFjZSgncGFydGljaXBhbnQgZXZlbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGV2ZW50LFxuICAgICAgYXJnc1xuICAgIH0pKTtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cblxudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiU2lnbmFsUmVjb25uZWN0aW5nXCJdID0gXCJzaWduYWxSZWNvbm5lY3RpbmdcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmNvbnN0IGNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kgPSA0ICogMTAwMDtcbi8qKlxuICogSW4gTGl2ZUtpdCwgYSByb29tIGlzIHRoZSBsb2dpY2FsIGdyb3VwaW5nIGZvciBhIGxpc3Qgb2YgcGFydGljaXBhbnRzLlxuICogUGFydGljaXBhbnRzIGluIGEgcm9vbSBjYW4gcHVibGlzaCB0cmFja3MsIGFuZCBzdWJzY3JpYmUgdG8gb3RoZXJzJyB0cmFja3MuXG4gKlxuICogYSBSb29tIGZpcmVzIFtbUm9vbUV2ZW50IHwgUm9vbUV2ZW50c11dLlxuICpcbiAqIEBub0luaGVyaXREb2NcbiAqL1xuY2xhc3MgUm9vbSBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUm9vbSwgdGhlIHByaW1hcnkgY29uc3RydWN0IGZvciBhIExpdmVLaXQgc2Vzc2lvbi5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgc3VwZXIoKTtcbiAgICBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWN0aXZlbHkgc3BlYWtpbmcuIHdoZW4gdGhpcyBjaGFuZ2VzXG4gICAgICogYSBbW1Jvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWRdXSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAvKiogcmVmbGVjdHMgdGhlIHNlbmRlciBlbmNyeXB0aW9uIHN0YXR1cyBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQgKi9cbiAgICB0aGlzLmlzRTJFRUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRleHRTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJwY0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29ubmVjdCA9ICh1cmwsIHRva2VuLCBvcHRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWlzQnJvd3NlclN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIldlYlJUQyBpc24ndCBkZXRlY3RlZCwgaGF2ZSB5b3UgY2FsbGVkIHJlZ2lzdGVyR2xvYmFscz9cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJMaXZlS2l0IGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLiBUcnkgdG8gdXBkYXRlIHlvdXIgYnJvd3NlciBhbmQgbWFrZSBzdXJlIG5vIGJyb3dzZXIgZXh0ZW5zaW9ucyBhcmUgZGlzYWJsaW5nIHdlYlJUQy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEluIGNhc2UgYSBkaXNjb25uZWN0IGNhbGxlZCBoYXBwZW5lZCByaWdodCBiZWZvcmUgdGhlIGNvbm5lY3QgY2FsbCwgbWFrZSBzdXJlIHRoZSBkaXNjb25uZWN0IGlzIGNvbXBsZXRlZCBmaXJzdCBieSBhd2FpdGluZyBpdHMgbG9ja1xuICAgICAgY29uc3QgdW5sb2NrRGlzY29ubmVjdCA9IHlpZWxkIHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgaXMgcmVjb25uZWN0aW5nIG9yIGNvbm5lY3RlZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJhbHJlYWR5IGNvbm5lY3RlZCB0byByb29tIFwiLmNvbmNhdCh0aGlzLm5hbWUpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VydmVyVXJsKCkudG9TdHJpbmcoKSkgIT09IHVybCkge1xuICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3QgZmV0Y2ggd2l0aG91dCB3YWl0aW5nIGZvciBhIHJlc3BvbnNlXG4gICAgICAgIC8vIGlmIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscywgdGhpcyB3aWxsIHNwZWVkIHVwIHBpY2tpbmcgcmVnaW9uYWwgdXJsXG4gICAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcnVuc1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmZldGNoUmVnaW9uU2V0dGluZ3MoKS50aGVuKHNldHRpbmdzID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhzZXR0aW5ncyk7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3RGbiA9IChyZXNvbHZlLCByZWplY3QsIHJlZ2lvblVybCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGxpY2l0IGNyZWF0aW9uIGFzIGxvY2FsIHZhciBuZWVkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciB3aGVuIHBhc3NpbmcgaXQgdG8gYGF0dGVtcHRDb25uZWN0aW9uYCBmdXJ0aGVyIGRvd25cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgaW50ZW50aW9uIHRvIGNvbm5lY3QgaGFzIGJlZW4gc2lnbmFsbGVkIHNvIHdlIGNhbiBhbGxvdyBjYW5jZWxsaW5nIG9mIHRoZSBjb25uZWN0aW9uIHZpYSBkaXNjb25uZWN0KCkgYWdhaW5cbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCA9PT0gbnVsbCB8fCB1bmxvY2tEaXNjb25uZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyICYmIGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgJiYgZS5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFVybCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuZXh0VXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZ25hbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgKGVycm9yLnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFVybCAmJiAhKChfYiA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2lnbmFsLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJJbml0aWFsIGNvbm5lY3Rpb24gZmFpbGVkIHdpdGggQ29ubmVjdGlvbkVycm9yOiBcIi5jb25jYXQoZS5tZXNzYWdlLCBcIi4gUmV0cnlpbmcgd2l0aCBhbm90aGVyIHJlZ2lvbjogXCIpLmNvbmNhdChuZXh0VXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICAgICAgICB5aWVsZCBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCBuZXh0VXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IoZSkpO1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXNjb25uZWN0UmVhc29uID0gRGlzY29ubmVjdFJlYXNvbi5VTktOT1dOX1JFQVNPTjtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3RSZWFzb24gPSBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgZGlzY29ubmVjdFJlYXNvbik7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHRoaXMucmVnaW9uVXJsO1xuICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdEZuKHJlc29sdmUsIHJlamVjdCwgcmVnaW9uVXJsKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25GdXR1cmVzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3RTaWduYWwgPSAodXJsLCB0b2tlbiwgZW5naW5lLCBjb25uZWN0T3B0aW9ucywgcm9vbU9wdGlvbnMsIGFib3J0Q29udHJvbGxlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCBlbmdpbmUuam9pbih1cmwsIHRva2VuLCB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IGNvbm5lY3RPcHRpb25zLmF1dG9TdWJzY3JpYmUsXG4gICAgICAgIGFkYXB0aXZlU3RyZWFtOiB0eXBlb2Ygcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnID8gdHJ1ZSA6IHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtLFxuICAgICAgICBtYXhSZXRyaWVzOiBjb25uZWN0T3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgICBlMmVlRW5hYmxlZDogISF0aGlzLmUyZWVNYW5hZ2VyLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiBjb25uZWN0T3B0aW9ucy53ZWJzb2NrZXRUaW1lb3V0XG4gICAgICB9LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGxldCBzZXJ2ZXJJbmZvID0gam9pblJlc3BvbnNlLnNlcnZlckluZm87XG4gICAgICBpZiAoIXNlcnZlckluZm8pIHtcbiAgICAgICAgc2VydmVySW5mbyA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbixcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmVySW5mbyA9IHNlcnZlckluZm87XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciBcIi5jb25jYXQoT2JqZWN0LmVudHJpZXMoc2VydmVySW5mbykubWFwKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgfSkuam9pbignLCAnKSksIHtcbiAgICAgICAgcm9vbTogKF9hID0gam9pblJlc3BvbnNlLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lLFxuICAgICAgICByb29tU2lkOiAoX2IgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpZCxcbiAgICAgICAgaWRlbnRpdHk6IChfYyA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlkZW50aXR5XG4gICAgICB9KTtcbiAgICAgIGlmICghc2VydmVySW5mby52ZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFNlcnZlcigndW5rbm93biBzZXJ2ZXIgdmVyc2lvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHNlcnZlckluZm8udmVyc2lvbiA9PT0gJzAuMTUuMScgJiYgdGhpcy5vcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdkaXNhYmxpbmcgZHluYWNhc3QgZHVlIHRvIHNlcnZlciB2ZXJzaW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICAgIHJvb21PcHRpb25zLmR5bmFjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgcGkgPSBqb2luUmVzcG9uc2UucGFydGljaXBhbnQ7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkID0gcGkuc2lkO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3Moam9pblJlc3BvbnNlLmVuYWJsZWRQdWJsaXNoQ29kZWNzKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSAmJiB0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRTaWZUcmFpbGVyKGpvaW5SZXNwb25zZS5zaWZUcmFpbGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdDb3VsZCBub3Qgc2V0IFNpZlRyYWlsZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW3BpLCAuLi5qb2luUmVzcG9uc2Uub3RoZXJQYXJ0aWNpcGFudHNdKTtcbiAgICAgIGlmIChqb2luUmVzcG9uc2Uucm9vbSkge1xuICAgICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUoam9pblJlc3BvbnNlLnJvb20pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbiA9ICh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcgfHwgKChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVuZGluZ1JlY29ubmVjdCkpIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbygnUmVjb25uZWN0aW9uIGF0dGVtcHQgcmVwbGFjZWQgYnkgbmV3IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNDbG91ZCgpKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCk7XG4gICAgICB0aGlzLmNvbm5PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzKSwgb3B0cyk7XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWcpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucnRjQ29uZmlnID0gdGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3RTaWduYWwodXJsLCB0b2tlbiwgdGhpcy5lbmdpbmUsIHRoaXMuY29ubk9wdGlvbnMsIHRoaXMub3B0aW9ucywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZShqb2luUmVzcG9uc2UpO1xuICAgICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSk7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChyZXN1bHRpbmdFcnJvci5tZXNzYWdlLCBcIjogXCIpLmNvbmNhdChlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLnJlYXNvbiA9IGVyci5yZWFzb247XG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImVycm9yIHRyeWluZyB0byBlc3RhYmxpc2ggc2lnbmFsIGNvbm5lY3Rpb25cIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KSk7XG4gICAgICAgIHRocm93IHJlc3VsdGluZ0Vycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZFwiLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLndhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyBhbHNvIGhvb2sgdW5sb2FkIGV2ZW50XG4gICAgICBpZiAoaXNXZWIoKSAmJiB0aGlzLm9wdGlvbnMuZGlzY29ubmVjdE9uUGFnZUxlYXZlKSB7XG4gICAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmcmVlemUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogZGlzY29ubmVjdHMgdGhlIHJvb20sIGVtaXRzIFtbUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZF1dXG4gICAgICovXG4gICAgdGhpcy5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3NfMSA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc18xW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgWy4uLmFyZ3NfMV0sIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgbGV0IHN0b3BUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBfdGhpczIuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5sb2cuZGVidWcoJ2FscmVhZHkgZGlzY29ubmVjdGVkJywgX3RoaXMyLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oJ2Rpc2Nvbm5lY3QgZnJvbSByb29tJywgT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IF90aGlzMi5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCBfdGhpczIuaXNSZXN1bWluZykge1xuICAgICAgICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgICAgICAgX3RoaXMyLmxvZy53YXJuKCdhYm9ydCBjb25uZWN0aW9uIGF0dGVtcHQnLCBfdGhpczIubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAgIChfYSA9IF90aGlzMi5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBhYm9ydCBjb250cm9sbGVyIGRpZG4ndCBtYW5hZ2UgdG8gY2FuY2VsIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQsIHJlamVjdCB0aGUgY29ubmVjdCBwcm9taXNlIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgKF9jID0gKF9iID0gX3RoaXMyLmNvbm5lY3RGdXR1cmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWplY3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBuZXcgQ29ubmVjdGlvbkVycm9yKCdDbGllbnQgaW5pdGlhdGVkIGRpc2Nvbm5lY3QnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKSk7XG4gICAgICAgICAgICAgIF90aGlzMi5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2VuZCBsZWF2ZVxuICAgICAgICAgICAgaWYgKCEoKF9kID0gX3RoaXMyLmVuZ2luZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkpIHtcbiAgICAgICAgICAgICAgeWllbGQgX3RoaXMyLmVuZ2luZS5jbGllbnQuc2VuZExlYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbG9zZSBlbmdpbmUgKGFsc28gY2xvc2VzIGNsaWVudClcbiAgICAgICAgICAgIGlmIChfdGhpczIuZW5naW5lKSB7XG4gICAgICAgICAgICAgIHlpZWxkIF90aGlzMi5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVEaXNjb25uZWN0KHN0b3BUcmFja3MsIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCk7XG4gICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICBfdGhpczIuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5vblBhZ2VMZWF2ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmluZm8oJ1BhZ2UgbGVhdmUgZGV0ZWN0ZWQsIGRpc2Nvbm5lY3RpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cbiAgICAgKiBJbiB0aG9zZSBjYXNlcywgYXVkaW8gd2lsbCBiZSBzaWxlbnQgdW50aWwgYSBjbGljay90YXAgdHJpZ2dlcmluZyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAgICogLSBgZ2V0VXNlck1lZGlhYFxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRBdWRpbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5vcyA9PT0gJ2lPUycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlPUyBibG9ja3MgYXVkaW8gZWxlbWVudCBwbGF5YmFjayBpZlxuICAgICAgICAgKiAtIHVzZXIgaXMgbm90IHB1Ymxpc2hpbmcgYXVkaW8gdGhlbXNlbHZlcyBhbmRcbiAgICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBhcyBhIHdvcmthcm91bmQsIHdlIGNyZWF0ZSBhbiBhdWRpbyBlbGVtZW50IHdpdGggYW4gZW1wdHkgdHJhY2ssIHNvIHRoYXRcbiAgICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdWRpb0lkID0gJ2xpdmVraXQtZHVtbXktYXVkaW8tZWwnO1xuICAgICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCk7XG4gICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHRoZSBzcmNPYmplY3QgdG8gbnVsbCBvbiBwYWdlIGhpZGUgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NrIHNjcmVlbiBjb250cm9scyB0byBzaG93IHVwIGZvciBpdFxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncGFnZSB2aXNpYmxlIGFnYWluLCB0cmlnZ2VyaW5nIHN0YXJ0QXVkaW8gdG8gcmVzdW1lIHBsYXliYWNrIGFuZCB1cGRhdGUgcGxheWJhY2sgc3RhdHVzJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEF1ZGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZHVtbXlBdWRpb0VsKTtcbiAgICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID09PSBudWxsIHx8IGR1bW15QXVkaW9FbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVtbXlBdWRpb0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGR1bW15QXVkaW9FbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAodC50cmFjaykge1xuICAgICAgICAgICAgdC50cmFjay5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCksIC4uLmVsZW1lbnRzLm1hcChlID0+IHtcbiAgICAgICAgICBlLm11dGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGUucGxheSgpO1xuICAgICAgICB9KV0pO1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXJ0VmlkZW8gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIHAudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdHIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5pbmNsdWRlcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoZWxlbWVudHMubWFwKGVsID0+IGVsLnBsYXkoKSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAvLyBpbiBjYXNlIHdlIHdlbnQgZnJvbSByZXN1bWluZyB0byBmdWxsLXJlY29ubmVjdCwgbWFrZSBzdXJlIHRvIHJlZmxlY3QgaXQgb24gdGhlIGlzUmVzdW1pbmcgZmxhZ1xuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwLmlkZW50aXR5LCBwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQgPSBqb2luUmVzcG9uc2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJzaWduYWwgcmVjb25uZWN0ZWQgdG8gc2VydmVyLCByZWdpb24gXCIuY29uY2F0KGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXG4gICAgICAgIHlpZWxkIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZ1bGx5IHJlY29ubmVjdGVkIHRvIHNlcnZlclwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gcmVjb25uZWN0aW9uIGZhaWxlZCwgaGFuZGxlRGlzY29ubmVjdCBpcyBiZWluZyBpbnZva2VkIGFscmVhZHksIGp1c3QgcmV0dXJuIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgdGhpcy5lbWl0QnVmZmVyZWRFdmVudHMoKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IHBhcnRpY2lwYW50SW5mb3MgPT4ge1xuICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gcGFydGljaXBhbnQgc3RhdGUsIGFuZCBzZW5kIGV2ZW50c1xuICAgICAgcGFydGljaXBhbnRJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGl2ZUtpdCBzZXJ2ZXIgZG9lc24ndCBzZW5kIGlkZW50aXR5IGluZm8gcHJpb3IgdG8gdmVyc2lvbiAxLjUuMiBpbiBkaXNjb25uZWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gc28gd2UgdHJ5IHRvIG1hcCBhbiBlbXB0eSBpZGVudGl0eSB0byBhbiBhbHJlYWR5IGtub3duIHNJRCBtYW51YWxseVxuICAgICAgICBpZiAoaW5mby5pZGVudGl0eSA9PT0gJycpIHtcbiAgICAgICAgICBpbmZvLmlkZW50aXR5ID0gKF9hID0gdGhpcy5zaWRUb0lkZW50aXR5LmdldChpbmZvLnNpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpbmZvLmlkZW50aXR5KTtcbiAgICAgICAgLy8gd2hlbiBpdCdzIGRpc2Nvbm5lY3RlZCwgc2VuZCB1cGRhdGVzXG4gICAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpbmZvLmlkZW50aXR5LCByZW1vdGVQYXJ0aWNpcGFudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLmlkZW50aXR5LCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgICB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gc3BlYWtlcnMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XG4gICAgICBzcGVha2Vycy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBzZWVuU2lkc1tzcGVha2VyLnNpZF0gPSB0cnVlO1xuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3BlYWtlci5zaWQpO1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICBwLnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgICB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCA9IHNwZWFrZXJVcGRhdGVzID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTcGVha2VycyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocC5pZGVudGl0eSk7XG4gICAgICAgIGlmIChyZW1vdGVQYXJ0aWNpcGFudCAmJiByZW1vdGVQYXJ0aWNpcGFudC5zaWQgIT09IHAuc2lkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTcGVha2Vycy5zZXQocC5zaWQsIHApO1xuICAgICAgfSk7XG4gICAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBsZXQgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XG4gICAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHAuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG4gICAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5zZXQoc3BlYWtlci5zaWQsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgICAgYWN0aXZlU3BlYWtlcnMuc29ydCgoYSwgYikgPT4gYi5hdWRpb0xldmVsIC0gYS5hdWRpb0xldmVsKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSA9IHN0cmVhbVN0YXRlVXBkYXRlID0+IHtcbiAgICAgIHN0cmVhbVN0YXRlVXBkYXRlLnN0cmVhbVN0YXRlcy5mb3JFYWNoKHN0cmVhbVN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3RyZWFtU3RhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzdHJlYW1TdGF0ZS50cmFja1NpZCk7XG4gICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RyZWFtU3RhdGUgPSBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXdTdHJlYW1TdGF0ZSAhPT0gcHViLnRyYWNrLnN0cmVhbVN0YXRlKSB7XG4gICAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlID0gbmV3U3RyZWFtU3RhdGU7XG4gICAgICAgICAgcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHVwZGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZCh1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHViLnNldEFsbG93ZWQodXBkYXRlLmFsbG93ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvciA9IHVwZGF0ZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQocCA9PiBwLnRyYWNrUHVibGljYXRpb25zLmhhcyh1cGRhdGUudHJhY2tTaWQpKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIuc2V0U3Vic2NyaXB0aW9uRXJyb3IodXBkYXRlLmVycik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURhdGFQYWNrZXQgPSBwYWNrZXQgPT4ge1xuICAgICAgLy8gZmluZCB0aGUgcGFydGljaXBhbnRcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVXNlclBhY2tldChwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlLCBwYWNrZXQua2luZCk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAndHJhbnNjcmlwdGlvbicpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2NyaXB0aW9uKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3NpcER0bWYnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2lwRHRtZihwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdjaGF0TWVzc2FnZScpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGF0TWVzc2FnZShwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdtZXRyaWNzJykge1xuICAgICAgICB0aGlzLmhhbmRsZU1ldHJpY3MocGFja2V0LnZhbHVlLnZhbHVlLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnc3RyZWFtSGVhZGVyJykge1xuICAgICAgICB0aGlzLmhhbmRsZVN0cmVhbUhlYWRlcihwYWNrZXQudmFsdWUudmFsdWUsIHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1DaHVuaycpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTdHJlYW1DaHVuayhwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbVRyYWlsZXInKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU3RyZWFtVHJhaWxlcihwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3JwY1JlcXVlc3QnKSB7XG4gICAgICAgIGNvbnN0IHJwYyA9IHBhY2tldC52YWx1ZS52YWx1ZTtcbiAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY1JlcXVlc3QocGFja2V0LnBhcnRpY2lwYW50SWRlbnRpdHksIHJwYy5pZCwgcnBjLm1ldGhvZCwgcnBjLnBheWxvYWQsIHJwYy5yZXNwb25zZVRpbWVvdXRNcywgcnBjLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVVc2VyUGFja2V0ID0gKHBhcnRpY2lwYW50LCB1c2VyUGFja2V0LCBraW5kKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBwYXJ0aWNpcGFudCwga2luZCwgdXNlclBhY2tldC50b3BpYyk7XG4gICAgICAvLyBhbHNvIGVtaXQgb24gdGhlIHBhcnRpY2lwYW50XG4gICAgICBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBraW5kKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2lwRHRtZiA9IChwYXJ0aWNpcGFudCwgZHRtZikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaXBEVE1GUmVjZWl2ZWQsIGR0bWYsIHBhcnRpY2lwYW50KTtcbiAgICAgIC8vIGFsc28gZW1pdCBvbiB0aGUgcGFydGljaXBhbnRcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuU2lwRFRNRlJlY2VpdmVkLCBkdG1mKTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWRTZWdtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhbmRsZVRyYW5zY3JpcHRpb24gPSAoX3JlbW90ZVBhcnRpY2lwYW50LCB0cmFuc2NyaXB0aW9uKSA9PiB7XG4gICAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0cmFuc2NyaXB0aW9uLnRyYW5zY3JpYmVkUGFydGljaXBhbnRJZGVudGl0eSA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID8gdGhpcy5sb2NhbFBhcnRpY2lwYW50IDogdGhpcy5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkodHJhbnNjcmlwdGlvbi50cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgY29uc3QgcHVibGljYXRpb24gPSBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYW5zY3JpcHRpb24udHJhY2tJZCk7XG4gICAgICBjb25zdCBzZWdtZW50cyA9IGV4dHJhY3RUcmFuc2NyaXB0aW9uU2VnbWVudHModHJhbnNjcmlwdGlvbiwgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyk7XG4gICAgICBwdWJsaWNhdGlvbiA9PT0gbnVsbCB8fCBwdWJsaWNhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHVibGljYXRpb24uZW1pdChUcmFja0V2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCwgc2VnbWVudHMpO1xuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzLCBwdWJsaWNhdGlvbik7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCwgc2VnbWVudHMsIHBhcnRpY2lwYW50LCBwdWJsaWNhdGlvbik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNoYXRNZXNzYWdlID0gKHBhcnRpY2lwYW50LCBjaGF0TWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgbXNnID0gZXh0cmFjdENoYXRNZXNzYWdlKGNoYXRNZXNzYWdlKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZywgcGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVNZXRyaWNzID0gKG1ldHJpY3MsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1ldHJpY3NSZWNlaXZlZCwgbWV0cmljcywgcGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQgPSBlID0+IHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwbGF5YmFjayBhdWRpbycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlcnJvcjogZVxuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHByZXZpb3VzRGV2aWNlcyA9IERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5wcmV2aW91c0RldmljZXM7XG4gICAgICAvLyBjaGVjayBmb3IgYXZhaWxhYmxlIGRldmljZXMsIGJ1dCBkb24ndCByZXF1ZXN0IHBlcm1pc3Npb25zIGluIG9yZGVyIHRvIGF2b2lkIHByb21wdHMgZm9yIGtpbmRzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgYmVmb3JlXG4gICAgICBjb25zdCBhdmFpbGFibGVEZXZpY2VzID0geWllbGQgRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXModW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdDaHJvbWUnICYmIGJyb3dzZXIub3MgIT09ICdpT1MnKSB7XG4gICAgICAgIGZvciAobGV0IGF2YWlsYWJsZURldmljZSBvZiBhdmFpbGFibGVEZXZpY2VzKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNEZXZpY2UgPSBwcmV2aW91c0RldmljZXMuZmluZChpbmZvID0+IGluZm8uZGV2aWNlSWQgPT09IGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV2aWNlICYmIHByZXZpb3VzRGV2aWNlLmxhYmVsICE9PSAnJyAmJiBwcmV2aW91c0RldmljZS5raW5kID09PSBhdmFpbGFibGVEZXZpY2Uua2luZCAmJiBwcmV2aW91c0RldmljZS5sYWJlbCAhPT0gYXZhaWxhYmxlRGV2aWNlLmxhYmVsKSB7XG4gICAgICAgICAgICAvLyBsYWJlbCBoYXMgY2hhbmdlZCBvbiBkZXZpY2UgdGhlIHNhbWUgZGV2aWNlSWQsIGluZGljYXRpbmcgdGhhdCB0aGUgZGVmYXVsdCBkZXZpY2UgaGFzIGNoYW5nZWQgb24gdGhlIE9TIGxldmVsXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBY3RpdmVEZXZpY2UoYXZhaWxhYmxlRGV2aWNlLmtpbmQpID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgLy8gZW1pdCBhbiBhY3RpdmUgZGV2aWNlIGNoYW5nZSBldmVudCBvbmx5IGlmIHRoZSBzZWxlY3RlZCBvdXRwdXQgZGV2aWNlIGlzIGFjdHVhbGx5IG9uIGBkZWZhdWx0YFxuICAgICAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsIGF2YWlsYWJsZURldmljZS5raW5kLCBhdmFpbGFibGVEZXZpY2UuZGV2aWNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5wdXRzIGFyZSBhdXRvbWF0aWNhbGx5IGhhbmRsZWQgdmlhIFRyYWNrRXZlbnQuRW5kZWQgY2F1c2luZyBhIFRyYWNrRXZlbnQuUmVzdGFydGVkLiBIZXJlIHdlIG9ubHkgbmVlZCB0byB3b3JyeSBhYm91dCBhdWRpb291dHB1dHMgY2hhbmdpbmdcbiAgICAgIGNvbnN0IGtpbmRzID0gWydhdWRpb291dHB1dCcsICdhdWRpb2lucHV0JywgJ3ZpZGVvaW5wdXQnXTtcbiAgICAgIGZvciAobGV0IGtpbmQgb2Yga2luZHMpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlc09mS2luZCA9IGF2YWlsYWJsZURldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSBraW5kKTtcbiAgICAgICAgY29uc3QgYWN0aXZlRGV2aWNlID0gdGhpcy5nZXRBY3RpdmVEZXZpY2Uoa2luZCk7XG4gICAgICAgIGlmIChhY3RpdmVEZXZpY2UgPT09ICgoX2EgPSBwcmV2aW91c0RldmljZXMuZmlsdGVyKGluZm8gPT4gaW5mby5raW5kID09PSBraW5kKVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldmljZUlkKSkge1xuICAgICAgICAgIC8vIGluICBTYWZhcmkgdGhlIGZpcnN0IGRldmljZSBpcyBhbHdheXMgdGhlIGRlZmF1bHQsIHNvIHdlIGFzc3VtZSBhIHVzZXIgb24gdGhlIGRlZmF1bHQgZGV2aWNlIHdvdWxkIGxpa2UgdG8gc3dpdGNoIHRvIHRoZSBkZWZhdWx0IG9uY2UgaXQgY2hhbmdlc1xuICAgICAgICAgIC8vIEZGIGRvZXNuJ3QgZW1pdCBhbiBldmVudCB3aGVuIHRoZSBkZWZhdWx0IGRldmljZSBjaGFuZ2VzLCBzbyB3ZSBwZXJmb3JtIHRoZSBzYW1lIGJlc3QgZWZmb3J0IGFuZCBzd2l0Y2ggdG8gdGhlIG5ldyBkZXZpY2Ugb25jZSBjb25uZWN0ZWQgYW5kIGlmIGl0J3MgdGhlIGZpcnN0IGluIHRoZSBhcnJheVxuICAgICAgICAgIGlmIChkZXZpY2VzT2ZLaW5kLmxlbmd0aCA+IDAgJiYgKChfYiA9IGRldmljZXNPZktpbmRbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXZpY2VJZCkgIT09IGFjdGl2ZURldmljZSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZCwgZGV2aWNlc09mS2luZFswXS5kZXZpY2VJZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0JyAmJiAhaXNTYWZhcmkoKSB8fCBraW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICAgICAgICAvLyBhaXJwb2RzIG9uIFNhZmFyaSBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGF1ZGlvaW5wdXQgYXMgdGhlIHRyYWNrIGRvZXNuJ3QgZW5kIGFzIHNvb24gYXMgeW91IHRha2UgdGhlbSBvdXRcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggdG8gZmlyc3QgYXZhaWxhYmxlIGRldmljZSBpZiBwcmV2aW91c2x5IGFjdGl2ZSBkZXZpY2UgaXMgbm90IGF2YWlsYWJsZSBhbnkgbW9yZVxuICAgICAgICBpZiAoZGV2aWNlc09mS2luZC5sZW5ndGggPiAwICYmICFkZXZpY2VzT2ZLaW5kLmZpbmQoZGV2aWNlSW5mbyA9PiBkZXZpY2VJbmZvLmRldmljZUlkID09PSB0aGlzLmdldEFjdGl2ZURldmljZShraW5kKSkpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNDaGFuZ2VkKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUgPSByb29tID0+IHtcbiAgICAgIGNvbnN0IG9sZFJvb20gPSB0aGlzLnJvb21JbmZvO1xuICAgICAgdGhpcy5yb29tSW5mbyA9IHJvb207XG4gICAgICBpZiAob2xkUm9vbSAmJiBvbGRSb29tLm1ldGFkYXRhICE9PSByb29tLm1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlJvb21NZXRhZGF0YUNoYW5nZWQsIHJvb20ubWV0YWRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKChvbGRSb29tID09PSBudWxsIHx8IG9sZFJvb20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFJvb20uYWN0aXZlUmVjb3JkaW5nKSAhPT0gcm9vbS5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCwgcm9vbS5hY3RpdmVSZWNvcmRpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICB1cGRhdGUudXBkYXRlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICBpZiAoaW5mby5wYXJ0aWNpcGFudFNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChpbmZvLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgcGFydGljaXBhbnQuc2V0Q29ubmVjdGlvblF1YWxpdHkoaW5mby5xdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCA9IG1ldGFkYXRhID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCA9IG5hbWUgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsQXR0cmlidXRlc0NoYW5nZWQgPSBjaGFuZ2VkQXR0cmlidXRlcyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCA9IHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCA9IHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5tdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vblRyYWNrUHJvY2Vzc29yVXBkYXRlID0gcHJvY2Vzc29yID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHByb2Nlc3NvciA9PT0gbnVsbCB8fCBwcm9jZXNzb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3Nvci5vblB1Ymxpc2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHByb2Nlc3NvciwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHB1YiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbihUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcy5vbkxvY2FsVHJhY2tSZXN0YXJ0ZWQpO1xuICAgICAgKF9lID0gKF9kID0gKF9jID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UHJvY2Vzc29yKCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5vblB1Ymxpc2gpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kLCB0aGlzKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHB1Yi50cmFjaykpIHtcbiAgICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIHB1Yi50cmFjay5jaGVja0ZvclNpbGVuY2UoKTtcbiAgICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQsIHB1Yik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRldmljZUlkID0geWllbGQgKF9mID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZ2V0RGV2aWNlSWQoZmFsc2UpO1xuICAgICAgY29uc3QgZGV2aWNlS2luZCA9IHNvdXJjZVRvS2luZChwdWIuc291cmNlKTtcbiAgICAgIGlmIChkZXZpY2VLaW5kICYmIGRldmljZUlkICYmIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSBwdWIgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZihUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCB0aGlzLm9uVHJhY2tQcm9jZXNzb3JVcGRhdGUpO1xuICAgICAgKF9iID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub2ZmKFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tSZXN0YXJ0ZWQgPSB0cmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBkZXZpY2VJZCA9IHlpZWxkIHRyYWNrLmdldERldmljZUlkKGZhbHNlKTtcbiAgICAgIGNvbnN0IGRldmljZUtpbmQgPSBzb3VyY2VUb0tpbmQodHJhY2suc291cmNlKTtcbiAgICAgIGlmIChkZXZpY2VLaW5kICYmIGRldmljZUlkICYmIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKSkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImxvY2FsIHRyYWNrIHJlc3RhcnRlZCwgc2V0dGluZyBcIi5jb25jYXQoZGV2aWNlS2luZCwgXCIgXCIpLmNvbmNhdChkZXZpY2VJZCwgXCIgYWN0aXZlXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IHF1YWxpdHkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHksIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IgPSBlID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSBwcmV2UGVybWlzc2lvbnMgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50ID0gbXNnID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zaWRUb0lkZW50aXR5ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9vbU9wdGlvbkRlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlJvb20pO1xuICAgIHRoaXMudHJhbnNjcmlwdGlvblJlY2VpdmVkVGltZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdWRpb0RlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgIHRoaXMub3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHB1Ymxpc2hEZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpO1xuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RMb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQgPSBuZXcgTG9jYWxQYXJ0aWNpcGFudCgnJywgJycsIHRoaXMuZW5naW5lLCB0aGlzLm9wdGlvbnMsIHRoaXMucnBjSGFuZGxlcnMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KCd2aWRlb2lucHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xuICAgIH1cbiAgICBpZiAoKF9iID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkKSkuY2F0Y2goZSA9PiB0aGlzLmxvZy53YXJuKFwiQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6IFwiLmNvbmNhdChlLm1lc3NhZ2UpLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRSgpO1xuICAgIH1cbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgLy8gaW4gb3JkZXIgdG8gY2F0Y2ggZGV2aWNlIGNoYW5nZXMgcHJpb3IgdG8gcm9vbSBjb25uZWN0aW9uIHdlIG5lZWQgdG8gcmVnaXN0ZXIgdGhlIGV2ZW50IGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgKF9jID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlLCB7XG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpZiAoUm9vbS5jbGVhbnVwUmVnaXN0cnkpIHtcbiAgICAgICAgUm9vbS5jbGVhbnVwUmVnaXN0cnkucmVnaXN0ZXIodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuaGFzKHRvcGljKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGV4dCBzdHJlYW0gaGFuZGxlciBmb3IgdG9waWMgXFxcIlwiLmNvbmNhdCh0b3BpYywgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gc2V0LlwiKSk7XG4gICAgfVxuICAgIHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLnNldCh0b3BpYywgY2FsbGJhY2spO1xuICB9XG4gIHVucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYykge1xuICAgIHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLmRlbGV0ZSh0b3BpYyk7XG4gIH1cbiAgcmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuaGFzKHRvcGljKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgYnl0ZSBzdHJlYW0gaGFuZGxlciBmb3IgdG9waWMgXFxcIlwiLmNvbmNhdCh0b3BpYywgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gc2V0LlwiKSk7XG4gICAgfVxuICAgIHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzLnNldCh0b3BpYywgY2FsbGJhY2spO1xuICB9XG4gIHVucmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYykge1xuICAgIHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzLmRlbGV0ZSh0b3BpYyk7XG4gIH1cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIHRoZSBwYXJ0aWNpcGFudCBhcyBhIHJlY2VpdmVyIGZvciBjYWxscyBvZiB0aGUgc3BlY2lmaWVkIFJQQyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbmFtZSBvZiB0aGUgaW5kaWNhdGVkIFJQQyBtZXRob2RcbiAgICogQHBhcmFtIGhhbmRsZXIgLSBXaWxsIGJlIGludm9rZWQgd2hlbiBhbiBSUEMgcmVxdWVzdCBmb3IgdGhpcyBtZXRob2QgaXMgcmVjZWl2ZWRcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbWV0aG9kIGlzIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIGhhbmRsZXIgZm9yIHRoaXMgbWV0aG9kIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCAobXVzdCBjYWxsIHVucmVnaXN0ZXJScGNNZXRob2QgZmlyc3QpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogcm9vbS5sb2NhbFBhcnRpY2lwYW50Py5yZWdpc3RlclJwY01ldGhvZChcbiAgICogICAnZ3JlZXQnLFxuICAgKiAgIGFzeW5jIChkYXRhOiBScGNJbnZvY2F0aW9uRGF0YSkgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2coYFJlY2VpdmVkIGdyZWV0aW5nIGZyb20gJHtkYXRhLmNhbGxlcklkZW50aXR5fTogJHtkYXRhLnBheWxvYWR9YCk7XG4gICAqICAgICByZXR1cm4gYEhlbGxvLCAke2RhdGEuY2FsbGVySWRlbnRpdHl9IWA7XG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIGhhbmRsZXIgc2hvdWxkIHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHN0cmluZy5cbiAgICogSWYgdW5hYmxlIHRvIHJlc3BvbmQgd2l0aGluIGByZXNwb25zZVRpbWVvdXRgLCB0aGUgcmVxdWVzdCB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciBvbiB0aGUgY2FsbGVyJ3Mgc2lkZS5cbiAgICpcbiAgICogWW91IG1heSB0aHJvdyBlcnJvcnMgb2YgdHlwZSBgUnBjRXJyb3JgIHdpdGggYSBzdHJpbmcgYG1lc3NhZ2VgIGluIHRoZSBoYW5kbGVyLFxuICAgKiBhbmQgdGhleSB3aWxsIGJlIHJlY2VpdmVkIG9uIHRoZSBjYWxsZXIncyBzaWRlIHdpdGggdGhlIG1lc3NhZ2UgaW50YWN0LlxuICAgKiBPdGhlciBlcnJvcnMgdGhyb3duIGluIHlvdXIgaGFuZGxlciB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCBhcy1pcywgYW5kIHdpbGwgaW5zdGVhZCBhcnJpdmUgdG8gdGhlIGNhbGxlciBhcyBgMTUwMGAgKFwiQXBwbGljYXRpb24gRXJyb3JcIikuXG4gICAqL1xuICByZWdpc3RlclJwY01ldGhvZChtZXRob2QsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5ycGNIYW5kbGVycy5oYXMobWV0aG9kKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJSUEMgaGFuZGxlciBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1ldGhvZCBcIi5jb25jYXQobWV0aG9kLCBcIiwgdW5yZWdpc3RlclJwY01ldGhvZCBiZWZvcmUgdHJ5aW5nIHRvIHJlZ2lzdGVyIGFnYWluXCIpKTtcbiAgICB9XG4gICAgdGhpcy5ycGNIYW5kbGVycy5zZXQobWV0aG9kLCBoYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgUlBDIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBSUEMgbWV0aG9kIHRvIHVucmVnaXN0ZXJcbiAgICovXG4gIHVucmVnaXN0ZXJScGNNZXRob2QobWV0aG9kKSB7XG4gICAgdGhpcy5ycGNIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgfVxuICBoYW5kbGVJbmNvbWluZ1JwY1JlcXVlc3QoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgbWV0aG9kLCBwYXlsb2FkLCByZXNwb25zZVRpbWVvdXQsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY0FjayhjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkKTtcbiAgICAgIGlmICh2ZXJzaW9uICE9PSAxKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCBudWxsLCBScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9WRVJTSU9OJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5ycGNIYW5kbGVycy5nZXQobWV0aG9kKTtcbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgbnVsbCwgUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfTUVUSE9EJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcmVzcG9uc2VFcnJvciA9IG51bGw7XG4gICAgICBsZXQgcmVzcG9uc2VQYXlsb2FkID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgaGFuZGxlcih7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGNhbGxlcklkZW50aXR5LFxuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgcmVzcG9uc2VUaW1lb3V0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYnl0ZUxlbmd0aChyZXNwb25zZSkgPiBNQVhfUEFZTE9BRF9CWVRFUykge1xuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBScGNFcnJvci5idWlsdEluKCdSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRScpO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlJQQyBSZXNwb25zZSBwYXlsb2FkIHRvbyBsYXJnZSBmb3IgXCIuY29uY2F0KG1ldGhvZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlUGF5bG9hZCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBScGNFcnJvcikge1xuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBlcnJvciByZXR1cm5lZCBieSBSUEMgaGFuZGxlciBmb3IgXCIuY29uY2F0KG1ldGhvZCwgXCIuIFJldHVybmluZyBBUFBMSUNBVElPTl9FUlJPUiBpbnN0ZWFkLlwiKSwgZXJyb3IpO1xuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBScGNFcnJvci5idWlsdEluKCdBUFBMSUNBVElPTl9FUlJPUicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgcmVzcG9uc2VQYXlsb2FkLCByZXNwb25zZUVycm9yKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEUyRUVFbmFibGVkKGVuYWJsZWQpXSk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgIT09ICcnKSB7XG4gICAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdlMmVlIG5vdCBjb25maWd1cmVkLCBwbGVhc2Ugc2V0IGUyZWUgc2V0dGluZ3Mgd2l0aGluIHRoZSByb29tIG9wdGlvbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXR1cEUyRUUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgaWYgKCdlMmVlTWFuYWdlcicgaW4gdGhpcy5vcHRpb25zLmUyZWUpIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IHRoaXMub3B0aW9ucy5lMmVlLmUyZWVNYW5hZ2VyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IG5ldyBFMkVFTWFuYWdlcih0aGlzLm9wdGlvbnMuZTJlZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCAoZW5hYmxlZCwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgaWYgKGlzTG9jYWxQYXJ0aWNpcGFudChwYXJ0aWNpcGFudCkpIHtcbiAgICAgICAgICB0aGlzLmlzRTJFRUVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZW5hYmxlZCwgcGFydGljaXBhbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGVycm9yID0+IHRoaXMuZW1pdChSb29tRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBlcnJvcikpO1xuICAgICAgKF9hID0gdGhpcy5lMmVlTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldHVwKHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IHRoaXMubmFtZSxcbiAgICAgIHJvb21JRDogKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZCxcbiAgICAgIHBhcnRpY2lwYW50OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICBwSUQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgY3VycmVudCByb29tIGhhcyBhIHBhcnRpY2lwYW50IHdpdGggYHJlY29yZGVyOiB0cnVlYCBpbiBpdHMgSldUIGdyYW50XG4gICAqKi9cbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVSZWNvcmRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQuXG4gICAqIHJldHVybnMgb25jZSBhIHNpZCBoYXMgYmVlbiBpc3N1ZWQgYnkgdGhlIHNlcnZlci5cbiAgICovXG4gIGdldFNpZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vbUluZm8gJiYgdGhpcy5yb29tSW5mby5zaWQgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb21JbmZvLnNpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVJvb21VcGRhdGUgPSByb29tSW5mbyA9PiB7XG4gICAgICAgICAgaWYgKHJvb21JbmZvLnNpZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICAgIHJlc29sdmUocm9vbUluZm8uc2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xuICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICByZWplY3QoJ1Jvb20gZGlzY29ubmVjdGVkIGJlZm9yZSByb29tIHNlcnZlciBpZCB3YXMgYXZhaWxhYmxlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIHVzZXIgYXNzaWduZWQgbmFtZSwgZGVyaXZlZCBmcm9tIEpXVCB0b2tlbiAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gIH1cbiAgLyoqIHJvb20gbWV0YWRhdGEgKi9cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGFkYXRhO1xuICB9XG4gIGdldCBudW1QYXJ0aWNpcGFudHMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm51bVBhcnRpY2lwYW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICBnZXQgbnVtUHVibGlzaGVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUHVibGlzaGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICBtYXliZUNyZWF0ZUVuZ2luZSgpIHtcbiAgICBpZiAodGhpcy5lbmdpbmUgJiYgIXRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5naW5lID0gbmV3IFJUQ0VuZ2luZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcykub24oRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdGhpcy5oYW5kbGVSb29tVXBkYXRlKS5vbihFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkKS5vbihFbmdpbmVFdmVudC5TdHJlYW1TdGF0ZUNoYW5nZWQsIHRoaXMuaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvcikub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKS5vbihFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKSA9PiB7XG4gICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIHJlYXNvbik7XG4gICAgfSkub24oRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIHRoaXMuaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgdGhpcy5oYW5kbGVEYXRhUGFja2V0KS5vbihFbmdpbmVFdmVudC5SZXN1bWluZywgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIHRoaXMuaXNSZXN1bWluZyA9IHRydWU7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdSZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5TaWduYWxSZWNvbm5lY3RpbmcpKSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsUmVjb25uZWN0aW5nKTtcbiAgICAgIH1cbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdSZXN1bWVkIHNpZ25hbCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgdGhpcy5lbWl0QnVmZmVyZWRFdmVudHMoKTtcbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICB9XG4gICAgfSkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgKCkgPT4ge1xuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcgfHwgdGhpcy5pc1Jlc3VtaW5nKSB7XG4gICAgICAgIHRoaXMuc2VuZFN5bmNTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVzdGFydGluZykub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZCkub24oRW5naW5lRXZlbnQuT2ZmbGluZSwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgfSkub24oRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCAoc3RhdHVzLCBraW5kKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgc3Vic2NyaWJlZFNpZCA9PiB7XG4gICAgICBjb25zdCB0cmFja1B1YmxpY2F0aW9uID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25zKCkuZmluZChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgdHJhY2tTaWRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gdHJhY2tTaWQgPT09IHN1YnNjcmliZWRTaWQ7XG4gICAgICB9KTtcbiAgICAgIGlmICghdHJhY2tQdWJsaWNhdGlvbikge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgZmluZCBsb2NhbCB0cmFjayBzdWJzY3JpcHRpb24gZm9yIHN1YnNjcmliZWQgZXZlbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCB0cmFja1B1YmxpY2F0aW9uKTtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCB0cmFja1B1YmxpY2F0aW9uLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldExvY2FsRGV2aWNlcyBhYnN0cmFjdHMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzLlxuICAgKiBJbiBwYXJ0aWN1bGFyLCBpdCByZXF1ZXN0cyBkZXZpY2UgcGVybWlzc2lvbnMgYnkgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICogYW5kIG1ha2VzIHN1cmUgdGhlIHJldHVybmVkIGRldmljZSBkb2VzIG5vdCBjb25zaXN0IG9mIGR1bW15IGRldmljZXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBsb2NhbCBkZXZpY2VzXG4gICAqL1xuICBzdGF0aWMgZ2V0TG9jYWxEZXZpY2VzKGtpbmQpIHtcbiAgICBsZXQgcmVxdWVzdFBlcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyhraW5kLCByZXF1ZXN0UGVybWlzc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBwcmVwYXJlQ29ubmVjdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgbG9hZGVkLCBpbiBvcmRlclxuICAgKiB0byBzcGVlZCB1cCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBUaGlzIGZ1bmN0aW9uIHdpbGxcbiAgICogLSBwZXJmb3JtIEROUyByZXNvbHV0aW9uIGFuZCBwcmUtd2FybSB0aGUgRE5TIGNhY2hlXG4gICAqIC0gZXN0YWJsaXNoIFRMUyBjb25uZWN0aW9uIGFuZCBjYWNoZSBUTFMga2V5c1xuICAgKlxuICAgKiBXaXRoIExpdmVLaXQgQ2xvdWQsIGl0IHdpbGwgYWxzbyBkZXRlcm1pbmUgdGhlIGJlc3QgZWRnZSBkYXRhIGNlbnRlciBmb3JcbiAgICogdGhlIGN1cnJlbnQgY2xpZW50IHRvIGNvbm5lY3QgdG8gaWYgYSB0b2tlbiBpcyBwcm92aWRlZC5cbiAgICovXG4gIHByZXBhcmVDb25uZWN0aW9uKHVybCwgdG9rZW4pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlQ29ubmVjdGlvbiB0byBcIi5jb25jYXQodXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkgJiYgdG9rZW4pIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHlpZWxkIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgICAvLyB3ZSB3aWxsIG5vdCByZXBsYWNlIHRoZSByZWdpb25VcmwgaWYgYW4gYXR0ZW1wdCBoYWQgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgICAgLy8gdG8gYXZvaWQgb3ZlcnJpZGluZyByZWdpb25VcmwgYWZ0ZXIgYSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0IGhhZCBzdGFydGVkXG4gICAgICAgICAgaWYgKHJlZ2lvblVybCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHJlZ2lvblVybDtcbiAgICAgICAgICAgIHlpZWxkIGZldGNoKHRvSHR0cFVybChyZWdpb25VcmwpLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHJlcGFyZWQgY29ubmVjdGlvbiB0byBcIi5jb25jYXQocmVnaW9uVXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHVybCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHByZXBhcmUgY29ubmVjdGlvbicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmV0cmlldmVzIGEgcGFydGljaXBhbnQgYnkgaWRlbnRpdHlcbiAgICogQHBhcmFtIGlkZW50aXR5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSBpZGVudGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpZGVudGl0eSk7XG4gIH1cbiAgY2xlYXJDb25uZWN0aW9uRnV0dXJlcygpIHtcbiAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBmb3IgdGVzdGluZ1xuICAgKi9cbiAgc2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbywgYXJnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBwb3N0QWN0aW9uID0gKCkgPT4ge307XG4gICAgICBsZXQgcmVxO1xuICAgICAgc3dpdGNoIChzY2VuYXJpbykge1xuICAgICAgICBjYXNlICdzaWduYWwtcmVjb25uZWN0JzpcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZGlzY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGVha2VyJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc3BlYWtlclVwZGF0ZScsXG4gICAgICAgICAgICAgIHZhbHVlOiAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25vZGUtZmFpbHVyZSc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ25vZGVGYWlsdXJlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VydmVyLWxlYXZlJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc2VydmVyTGVhdmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWdyYXRpb24nOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdtaWdyYXRpb24nLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXN1bWUtcmVjb25uZWN0JzpcbiAgICAgICAgICB0aGlzLmVuZ2luZS5mYWlsTmV4dCgpO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUnOlxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUtbm8tbWVzc2FnZXMnOlxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuZW5naW5lLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBmdWxsLXJlY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3JjZS10Y3AnOlxuICAgICAgICBjYXNlICdmb3JjZS10bHMnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzd2l0Y2hDYW5kaWRhdGVQcm90b2NvbCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBzY2VuYXJpbyA9PT0gJ2ZvcmNlLXRscycgPyAyIDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvbkxlYXZlID0gdGhpcy5lbmdpbmUuY2xpZW50Lm9uTGVhdmU7XG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgICBvbkxlYXZlKG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgICAgICAgICAgIGFjdGlvbjogTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1RcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdWJzY3JpYmVyLWJhbmR3aWR0aCc6XG4gICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZXItYmFuZHdpZHRoIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzdWJzY3JpYmVyQmFuZHdpZHRoJyxcbiAgICAgICAgICAgICAgdmFsdWU6IG51bWJlclRvQmlnSW50KGFyZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVhdmUtZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdsZWF2ZVJlcXVlc3RGdWxsUmVjb25uZWN0JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICAgIHlpZWxkIHBvc3RBY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja0F1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG4gIGdldEFjdGl2ZURldmljZShraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBhbGwgYWN0aXZlIGRldmljZXMgdXNlZCBpbiB0aGlzIHJvb20gdG8gdGhlIGdpdmVuIGRldmljZS5cbiAgICpcbiAgICogTm90ZTogc2V0dGluZyBBdWRpb091dHB1dCBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMuIFNlZSBbc2V0U2lua0lkXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICAgKlxuICAgKiBAcGFyYW0ga2luZCB1c2UgYHZpZGVvaW5wdXRgIGZvciBjYW1lcmEgdHJhY2ssXG4gICAqICBgYXVkaW9pbnB1dGAgZm9yIG1pY3JvcGhvbmUgdHJhY2ssXG4gICAqICBgYXVkaW9vdXRwdXRgIHRvIHNldCBzcGVha2VyIGZvciBhbGwgaW5jb21pbmcgYXVkaW8gdHJhY2tzXG4gICAqIEBwYXJhbSBkZXZpY2VJZFxuICAgKi9cbiAgc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmRfMSwgZGV2aWNlSWRfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kLCBkZXZpY2VJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBsZXQgZXhhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB2YXIgX2g7XG4gICAgICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5lZWRzVXBkYXRlV2l0aG91dFRyYWNrcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkZXZpY2VDb25zdHJhaW50ID0gZXhhY3QgPyB7XG4gICAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICAgIH0gOiBkZXZpY2VJZDtcbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xuICAgICAgICAgIG5lZWRzVXBkYXRlV2l0aG91dFRyYWNrcyA9IF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuc2l6ZSA9PT0gMDtcbiAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSAoX2EgPSBfdGhpczMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZDtcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbShfdGhpczMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maWx0ZXIodHJhY2sgPT4gdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdC5hdWRpb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzID0gX3RoaXMzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5zaXplID09PSAwO1xuICAgICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IChfYiA9IF90aGlzMy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkO1xuICAgICAgICAgIF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbHRlcih0cmFjayA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gKHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHQudmlkZW9UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeSh2YWwgPT4gdmFsID09PSB0cnVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpczMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcbiAgICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKCkgJiYgIV90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4IHx8IF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4ICYmIF90aGlzMy5hdWRpb0NvbnRleHQgJiYgISgnc2V0U2lua0lkJyBpbiBfdGhpczMuYXVkaW9Db250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dpdGNoIGF1ZGlvIG91dHB1dCwgc2V0U2lua0lkIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBkZWZhdWx0YCBmb3Igd2ViIGF1ZGlvIG91dHB1dCBkb2Vzbid0IHdvcmssIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSBpZCBiZWZvcmVcbiAgICAgICAgICAgIGRldmljZUlkID0gKF9jID0geWllbGQgRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKCdhdWRpb291dHB1dCcsIGRldmljZUlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChfZCA9IChfaCA9IF90aGlzMy5vcHRpb25zKS5hdWRpb091dHB1dCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogX2guYXVkaW9PdXRwdXQgPSB7fTtcbiAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSAoX2UgPSBfdGhpczMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlIG9mIEF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgICAoX2YgPSBfdGhpczMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gc2V0IGF1ZGlvIG91dHB1dCBvbiBhbGwgYXVkaW8gZWxlbWVudHMsIGV2ZW4gaWYgd2ViQXVkaW9NaXggaXMgZW5hYmxlZCBpbiBvcmRlciB0byB3b3JrYXJvdW5kIGVjaG8gY2FuY2VsbGF0aW9uIG5vdCB3b3JraW5nIG9uIGNocm9tZSB3aXRoIG5vbi1kZWZhdWx0IG91dHB1dCBkZXZpY2VzXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MDI1MjkxMSNjb21tZW50N1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShfdGhpczMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5tYXAocCA9PiBwLnNldEF1ZGlvT3V0cHV0KHtcbiAgICAgICAgICAgICAgZGV2aWNlSWRcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzIHx8IGtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm90IGFjdGl2ZSB0cmFja3MgeWV0IG9yIHdlJ3JlIHN3aXRjaGluZyBhdWRpb291dHB1dCwgd2UgbmVlZCB0byBtYW51YWxseSB1cGRhdGUgdGhlIGFjdGl2ZSBkZXZpY2UgbWFwIGhlcmUgYXMgY2hhbmdpbmcgYXVkaW8gb3V0cHV0IHdvbid0IHJlc3VsdCBpbiBhIHRyYWNrIHJlc3RhcnRcbiAgICAgICAgICBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGtpbmQsIGtpbmQgPT09ICdhdWRpb291dHB1dCcgJiYgKChfZyA9IF90aGlzMy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZGV2aWNlSWQpIHx8IGRldmljZUlkKTtcbiAgICAgICAgICBfdGhpczMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwga2luZCwgZGV2aWNlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIHNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpIHtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5BdHRyaWJ1dGVzQ2hhbmdlZCwgdGhpcy5vbkxvY2FsQXR0cmlidXRlc0NoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcikub24oUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkLCB0aGlzLnN0YXJ0QXVkaW8pLm9uKFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQpO1xuICB9XG4gIHJlY3JlYXRlRW5naW5lKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xuICAgIC8vIGNsZWFyIG91dCBleGlzdGluZyByZW1vdGUgcGFydGljaXBhbnRzLCBzaW5jZSB0aGV5IG1heSBoYXZlIGF0dGFjaGVkXG4gICAgLy8gdGhlIG9sZCBlbmdpbmVcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eS5jbGVhcigpO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gIH1cbiAgb25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpIHtcbiAgICAvLyBkb24ndCBmaXJlIG9uU3Vic2NyaWJlZCB3aGVuIGNvbm5lY3RpbmdcbiAgICAvLyBXZWJSVEMgZmlyZXMgb25UcmFjayBhcyBzb29uIGFzIHNldFJlbW90ZURlc2NyaXB0aW9uIGlzIGNhbGxlZCBvbiB0aGUgb2ZmZXJcbiAgICAvLyBhdCB0aGF0IHRpbWUsIElDRSBjb25uZWN0aXZpdHkgaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHNvIHRoZSB0cmFjayBpcyBub3RcbiAgICAvLyB0ZWNobmljYWxseSBzdWJzY3JpYmVkLlxuICAgIC8vIFdlJ2xsIGRlZmVyIHRoZXNlIGV2ZW50cyB1bnRpbCB3aGVuIHRoZSByb29tIGlzIGNvbm5lY3RlZCBvciBldmVudHVhbGx5IGRpc2Nvbm5lY3RlZC5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcgfHwgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgY29uc3QgcmVjb25uZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIGNsZWFudXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5sb2cud2Fybignc2tpcHBpbmcgaW5jb21pbmcgdHJhY2sgYWZ0ZXIgUm9vbSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhcyBpdCBhbHJlYWR5IGVuZGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSB1bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50U2lkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuICAgIGlmIChwYXJ0aWNpcGFudFNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgdGhpcy5sb2cud2FybigndHJpZWQgdG8gY3JlYXRlIFJlbW90ZVBhcnRpY2lwYW50IGZvciBsb2NhbCBwYXJ0aWNpcGFudCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAuc2lkID09PSBwYXJ0aWNpcGFudFNpZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXCJUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCB0cmFja0lkLCBzdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgfVxuICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgIGxldCBzaG91bGRTdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2ssIHNob3VsZFN0b3BUcmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTdG9wVHJhY2tzKSB7XG4gICAgICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV0YWNoKCk7XG4gICAgICAgICAgKF9iID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChfYyA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0b3BNb25pdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICAoX2EgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaWRlbnRpdHksIHBhcnRpY2lwYW50KSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIHJlbW92ZSBhbmQgc2VuZCBldmVudFxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmRlbGV0ZShpZGVudGl0eSk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50RGlzY29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgKF9hID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICB9XG4gIGhhbmRsZVN0cmVhbUhlYWRlcihzdHJlYW1IZWFkZXIsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLmNhc2UgPT09ICdieXRlSGVhZGVyJykge1xuICAgICAgICBjb25zdCBzdHJlYW1IYW5kbGVyQ2FsbGJhY2sgPSB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5nZXQoc3RyZWFtSGVhZGVyLnRvcGljKTtcbiAgICAgICAgaWYgKCFzdHJlYW1IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnaWdub3JpbmcgaW5jb21pbmcgYnl0ZSBzdHJlYW0gZHVlIHRvIG5vIGhhbmRsZXIgZm9yIHRvcGljJywgc3RyZWFtSGVhZGVyLnRvcGljKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgaWQ6IHN0cmVhbUhlYWRlci5zdHJlYW1JZCxcbiAgICAgICAgICBuYW1lOiAoX2EgPSBzdHJlYW1IZWFkZXIuY29udGVudEhlYWRlci52YWx1ZS5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5rbm93bicsXG4gICAgICAgICAgbWltZVR5cGU6IHN0cmVhbUhlYWRlci5taW1lVHlwZSxcbiAgICAgICAgICBzaXplOiBzdHJlYW1IZWFkZXIudG90YWxMZW5ndGggPyBOdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0b3BpYzogc3RyZWFtSGVhZGVyLnRvcGljLFxuICAgICAgICAgIHRpbWVzdGFtcDogYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXG4gICAgICAgICAgYXR0cmlidXRlczogc3RyZWFtSGVhZGVyLmF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLnNldChzdHJlYW1IZWFkZXIuc3RyZWFtSWQsIHtcbiAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1IYW5kbGVyQ2FsbGJhY2sobmV3IEJ5dGVTdHJlYW1SZWFkZXIoaW5mbywgc3RyZWFtLCBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpKSwge1xuICAgICAgICAgIGlkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW1IZWFkZXIuY29udGVudEhlYWRlci5jYXNlID09PSAndGV4dEhlYWRlcicpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSGFuZGxlckNhbGxiYWNrID0gdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuZ2V0KHN0cmVhbUhlYWRlci50b3BpYyk7XG4gICAgICAgIGlmICghc3RyZWFtSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2lnbm9yaW5nIGluY29taW5nIHRleHQgc3RyZWFtIGR1ZSB0byBubyBoYW5kbGVyIGZvciB0b3BpYycsIHN0cmVhbUhlYWRlci50b3BpYyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgIGlkOiBzdHJlYW1IZWFkZXIuc3RyZWFtSWQsXG4gICAgICAgICAgbWltZVR5cGU6IHN0cmVhbUhlYWRlci5taW1lVHlwZSxcbiAgICAgICAgICBzaXplOiBzdHJlYW1IZWFkZXIudG90YWxMZW5ndGggPyBOdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0b3BpYzogc3RyZWFtSGVhZGVyLnRvcGljLFxuICAgICAgICAgIHRpbWVzdGFtcDogTnVtYmVyKHN0cmVhbUhlYWRlci50aW1lc3RhbXApLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHN0cmVhbUhlYWRlci5hdHRyaWJ1dGVzXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5zZXQoc3RyZWFtSGVhZGVyLnN0cmVhbUlkLCB7XG4gICAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXI6IHN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtSGFuZGxlckNhbGxiYWNrKG5ldyBUZXh0U3RyZWFtUmVhZGVyKGluZm8sIHN0cmVhbSwgYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSksIHtcbiAgICAgICAgICBpZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVTdHJlYW1DaHVuayhjaHVuaykge1xuICAgIGNvbnN0IGZpbGVCdWZmZXIgPSB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5nZXQoY2h1bmsuc3RyZWFtSWQpO1xuICAgIGlmIChmaWxlQnVmZmVyKSB7XG4gICAgICBpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZpbGVCdWZmZXIuY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dEJ1ZmZlciA9IHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XG4gICAgaWYgKHRleHRCdWZmZXIpIHtcbiAgICAgIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVTdHJlYW1UcmFpbGVyKHRyYWlsZXIpIHtcbiAgICBjb25zdCB0ZXh0QnVmZmVyID0gdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZ2V0KHRyYWlsZXIuc3RyZWFtSWQpO1xuICAgIGlmICh0ZXh0QnVmZmVyKSB7XG4gICAgICB0ZXh0QnVmZmVyLmluZm8uYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGV4dEJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMpLCB0cmFpbGVyLmF0dHJpYnV0ZXMpO1xuICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5kZWxldGUodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVCdWZmZXIgPSB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5nZXQodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcbiAgICAgIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpbGVCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZSh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiYgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAvLyBvdmVycmlkZSBhdWRpbyBjb250ZXh0IHdpdGggY3VzdG9tIGF1ZGlvIGNvbnRleHQgaWYgc3VwcGxpZWQgYnkgdXNlclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHRoaXMub3B0aW9ucy53ZWJBdWRpb01peC5hdWRpb0NvbnRleHQ7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvQ29udGV4dCB8fCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgLy8gYnkgdXNpbmcgYW4gQXVkaW9Db250ZXh0LCBpdCByZWR1Y2VzIGxhZyBvbiBhdWRpbyBlbGVtZW50c1xuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODExNDI5L2h0bWw1LWF1ZGlvLXRhZy1vbi1zYWZhcmktaGFzLWEtZGVsYXkvNTQxMTk4NTQjNTQxMTk4NTRcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSAoX2EgPSBnZXROZXdBdWRpb0NvbnRleHQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCkge1xuICAgICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIC8vIGZvciBpT1MgYSBuZXdseSBjcmVhdGVkIEF1ZGlvQ29udGV4dCBpcyBhbHdheXMgaW4gYHN1c3BlbmRlZGAgc3RhdGUuXG4gICAgICAgIC8vIHdlIHRyeSBvdXIgYmVzdCB0byByZXN1bWUgdGhlIGNvbnRleHQgaGVyZSwgaWYgdGhhdCBkb2Vzbid0IHdvcmssIHdlIGp1c3QgY29udGludWUgd2l0aCByZWd1bGFyIHByb2Nlc3NpbmdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW3RoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpLCBzbGVlcCgyMDApXSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb250ZXh0SXNSdW5uaW5nID0gKChfYiA9IHRoaXMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpID09PSAncnVubmluZyc7XG4gICAgICBpZiAobmV3Q29udGV4dElzUnVubmluZyAhPT0gdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgbmV3Q29udGV4dElzUnVubmluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRpY2lwYW50ID0gbmV3IFJlbW90ZVBhcnRpY2lwYW50KHRoaXMuZW5naW5lLmNsaWVudCwgJycsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgfVxuICAgIGlmICgoX2EgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXZpY2VJZCkge1xuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9PdXRwdXQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbykge1xuICAgIGlmICh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5oYXMoaWRlbnRpdHkpKSB7XG4gICAgICBjb25zdCBleGlzdGluZ1BhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGNvbnN0IHdhc1VwZGF0ZWQgPSBleGlzdGluZ1BhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgIGlmICh3YXNVcGRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5zaWRUb0lkZW50aXR5LnNldChpbmZvLnNpZCwgaW5mby5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZ1BhcnRpY2lwYW50O1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pO1xuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnNldChpZGVudGl0eSwgcGFydGljaXBhbnQpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eS5zZXQoaW5mby5zaWQsIGluZm8uaWRlbnRpdHkpO1xuICAgIC8vIGlmIHdlIGhhdmUgdmFsaWQgaW5mbyBhbmQgdGhlIHBhcnRpY2lwYW50IHdhc24ndCBpbiB0aGUgbWFwIGJlZm9yZSwgd2UgY2FuIGFzc3VtZSB0aGUgcGFydGljaXBhbnQgaXMgbmV3XG4gICAgLy8gZmlyaW5nIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgYFBhcnRpY2lwYW50Q29ubmVjdGVkYCBmaXJlcyBiZWZvcmUgdGhlIGluaXRpYWwgdHJhY2sgZXZlbnRzXG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAvLyBhbHNvIGZvcndhcmQgZXZlbnRzXG4gICAgLy8gdHJhY2tQdWJsaXNoZWQgaXMgb25seSBmaXJlZCBmb3IgdHJhY2tzIGFkZGVkIGFmdGVyIGJvdGggbG9jYWwgcGFydGljaXBhbnRcbiAgICAvLyBhbmQgcmVtb3RlIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbVxuICAgIHBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgLy8gbW9uaXRvciBwbGF5YmFjayBzdGF0dXNcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrVW5tdXRlZCwgcHViLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBjaGFuZ2VkQXR0cmlidXRlcyA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkLCBjaGFuZ2VkQXR0cmlidXRlcywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5ID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsICh0cmFja1NpZCwgZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHRyYWNrU2lkLCBwYXJ0aWNpcGFudCwgZXJyb3IpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgIH0pO1xuICAgIC8vIHVwZGF0ZSBpbmZvIGF0IHRoZSBlbmQgYWZ0ZXIgY2FsbGJhY2tzIGhhdmUgYmVlbiBzZXQgdXBcbiAgICBpZiAoaW5mbykge1xuICAgICAgcGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG4gIHNlbmRTeW5jU3RhdGUoKSB7XG4gICAgY29uc3QgcmVtb3RlVHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICBhY2MucHVzaCguLi5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIExvY2FsVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgdGhpcy5lbmdpbmUuc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3MsIGxvY2FsVHJhY2tzKTtcbiAgfVxuICAvKipcbiAgICogQWZ0ZXIgcmVzdW1pbmcsIHdlJ2xsIG5lZWQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgb2YgdGhlIGN1cnJlbnRcbiAgICogc3Vic2NyaXB0aW9uIHNldHRpbmdzLlxuICAgKi9cbiAgdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgcHViIG9mIHAudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAocHViLmlzU3Vic2NyaWJlZCAmJiBpc1JlbW90ZVB1YihwdWIpKSB7XG4gICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc2lkKSB7XG4gICAgY29uc3QgaWRlbnRpdHkgPSB0aGlzLnNpZFRvSWRlbnRpdHkuZ2V0KHNpZCk7XG4gICAgaWYgKGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gZW5zdXJlIHdlIGRpZG4ndCB0ZWFyIGl0IGRvd25cbiAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgLy8gZW5naW5lIGRldGVjdGVkIGNsb3NlLCBidXQgUm9vbSBtaXNzZWQgaXRcbiAgICAgIHRoaXMuZW5naW5lLmlzQ2xvc2VkIHx8XG4gICAgICAvLyB0cmFuc3BvcnRzIGZhaWxlZCB3aXRob3V0IG5vdGlmeWluZyBlbmdpbmVcbiAgICAgICF0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSkge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzKys7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2RldGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUgbWlzbWF0Y2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlcyxcbiAgICAgICAgICBlbmdpbmU6IHRoaXMuZW5naW5lID8ge1xuICAgICAgICAgICAgY2xvc2VkOiB0aGlzLmVuZ2luZS5pc0Nsb3NlZCxcbiAgICAgICAgICAgIHRyYW5zcG9ydHNDb25uZWN0ZWQ6IHRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChjb25zZWN1dGl2ZUZhaWx1cmVzID49IDMpIHtcbiAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBEaXNjb25uZWN0UmVhc29uLlNUQVRFX01JU01BVENIKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICB9XG4gICAgfSwgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSk7XG4gIH1cbiAgY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCk7XG4gICAgfVxuICB9XG4gIHNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIC8vIHVuY2hhbmdlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLCB0aGlzLnN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbWl0QnVmZmVyZWRFdmVudHMoKSB7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cy5mb3JFYWNoKF9yZWYzID0+IHtcbiAgICAgIGxldCBbZXYsIGFyZ3NdID0gX3JlZjM7XG4gICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH0pO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgfVxuICBlbWl0V2hlbkNvbm5lY3RlZChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcgfHwgIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLnBlbmRpbmdSZWNvbm5lY3QpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIHJvb20gaXMgcmVjb25uZWN0aW5nLCBidWZmZXIgdGhlIGV2ZW50cyBieSBmaXJpbmcgdGhlbSBsYXRlciBhZnRlciBlbWl0dGluZyBSb29tRXZlbnQuUmVjb25uZWN0ZWRcbiAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMucHVzaChbZXZlbnQsIGFyZ3NdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyB0byBwb3B1bGF0ZSBhIHJvb20gd2l0aCBzaW11bGF0ZWQgcGFydGljaXBhbnRzLlxuICAgKiBObyBhY3R1YWwgY29ubmVjdGlvbiB0byBhIHNlcnZlciB3aWxsIGJlIGVzdGFibGlzaGVkLCBhbGwgc3RhdGUgaXNcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2ltdWxhdGVQYXJ0aWNpcGFudHMob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHVibGlzaE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICB1c2VSZWFsVHJhY2tzOiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucy5wdWJsaXNoKTtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjb3VudDogOSxcbiAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgYXNwZWN0UmF0aW9zOiBbMS42NiwgMS43LCAxLjNdXG4gICAgICB9LCBvcHRpb25zLnBhcnRpY2lwYW50cyk7XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucm9vbUluZm8gPSBuZXcgUm9vbSQxKHtcbiAgICAgICAgc2lkOiAnUk1fU0lNVUxBVEVEJyxcbiAgICAgICAgbmFtZTogJ3NpbXVsYXRlZC1yb29tJyxcbiAgICAgICAgZW1wdHlUaW1lb3V0OiAwLFxuICAgICAgICBtYXhQYXJ0aWNpcGFudHM6IDAsXG4gICAgICAgIGNyZWF0aW9uVGltZTogcHJvdG9JbnQ2NC5wYXJzZShuZXcgRGF0ZSgpLmdldFRpbWUoKSksXG4gICAgICAgIG1ldGFkYXRhOiAnJyxcbiAgICAgICAgbnVtUGFydGljaXBhbnRzOiAxLFxuICAgICAgICBudW1QdWJsaXNoZXJzOiAxLFxuICAgICAgICB0dXJuUGFzc3dvcmQ6ICcnLFxuICAgICAgICBlbmFibGVkQ29kZWNzOiBbXSxcbiAgICAgICAgYWN0aXZlUmVjb3JkaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhuZXcgUGFydGljaXBhbnRJbmZvKHtcbiAgICAgICAgaWRlbnRpdHk6ICdzaW11bGF0ZWQtbG9jYWwnLFxuICAgICAgICBuYW1lOiAnbG9jYWwtbmFtZSdcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICBpZiAocHVibGlzaE9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgY29uc3QgY2FtUHViID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihUcmFjay5LaW5kLlZpZGVvLCBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLkNBTUVSQSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICBuYW1lOiAndmlkZW8tZHVtbXknXG4gICAgICAgIH0pLCBuZXcgTG9jYWxWaWRlb1RyYWNrKHB1Ymxpc2hPcHRpb25zLnVzZVJlYWxUcmFja3MgPyAoeWllbGQgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICB2aWRlbzogdHJ1ZVxuICAgICAgICB9KSkuZ2V0VmlkZW9UcmFja3MoKVswXSA6IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygxNjAgKiAoKF9hID0gcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSksIDE2MCwgdHJ1ZSwgdHJ1ZSksIHVuZGVmaW5lZCwgZmFsc2UsIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hZGRUcmFja1B1YmxpY2F0aW9uKGNhbVB1Yik7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgY2FtUHViKTtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy5hdWRpbykge1xuICAgICAgICBjb25zdCBhdWRpb1B1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oVHJhY2suS2luZC5BdWRpbywgbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5NSUNST1BIT05FLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgIH0pLCBuZXcgTG9jYWxBdWRpb1RyYWNrKHB1Ymxpc2hPcHRpb25zLnVzZVJlYWxUcmFja3MgPyAoeWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIGF1ZGlvOiB0cnVlXG4gICAgICAgIH0pKS5nZXRBdWRpb1RyYWNrcygpWzBdIDogZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCksIHVuZGVmaW5lZCwgZmFsc2UsIHRoaXMuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSksIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWRkVHJhY2tQdWJsaWNhdGlvbihhdWRpb1B1Yik7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgYXVkaW9QdWIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudE9wdGlvbnMuY291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IGluZm8gPSBuZXcgUGFydGljaXBhbnRJbmZvKHtcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIGlkZW50aXR5OiBcInNpbXVsYXRlZC1cIi5jb25jYXQoaSksXG4gICAgICAgICAgc3RhdGU6IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkUsXG4gICAgICAgICAgdHJhY2tzOiBbXSxcbiAgICAgICAgICBqb2luZWRBdDogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLmlkZW50aXR5LCBpbmZvKTtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy52aWRlbykge1xuICAgICAgICAgIGNvbnN0IGR1bW15VmlkZW8gPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soMTYwICogKChfYiA9IHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbaSAlIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3MubGVuZ3RoXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSksIDE2MCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soZHVtbXlWaWRlbywgdmlkZW9UcmFjay5zaWQsIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlWaWRlb10pLCBuZXcgUlRDUnRwUmVjZWl2ZXIoKSk7XG4gICAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIHZpZGVvVHJhY2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgICBjb25zdCBkdW1teVRyYWNrID0gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCk7XG4gICAgICAgICAgY29uc3QgYXVkaW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5NSUNST1BIT05FLFxuICAgICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soZHVtbXlUcmFjaywgYXVkaW9UcmFjay5zaWQsIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlUcmFja10pLCBuZXcgUlRDUnRwUmVjZWl2ZXIoKSk7XG4gICAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIGF1ZGlvVHJhY2tdO1xuICAgICAgICB9XG4gICAgICAgIHAudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyAvKiogQGludGVybmFsICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgLy8gYWN0aXZlIHNwZWFrZXIgdXBkYXRlcyBhcmUgdG9vIHNwYW1teVxuICAgIGlmIChldmVudCAhPT0gUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCAmJiBldmVudCAhPT0gUm9vbUV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCkge1xuICAgICAgLy8gb25seSBleHRyYWN0IGxvZ0NvbnRleHQgZnJvbSBhcmd1bWVudHMgaW4gb3JkZXIgdG8gYXZvaWQgbG9nZ2luZyB0aGUgd2hvbGUgb2JqZWN0IHRyZWVcbiAgICAgIGNvbnN0IG1pbmltaXplZEFyZ3MgPSBtYXBBcmdzKGFyZ3MpLmZpbHRlcihhcmcgPT4gYXJnICE9PSB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJyb29tIGV2ZW50IFwiLmNvbmNhdChldmVudCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgYXJnczogbWluaW1pemVkQXJnc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cblJvb20uY2xlYW51cFJlZ2lzdHJ5ID0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ICE9PSAndW5kZWZpbmVkJyAmJiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoY2xlYW51cCA9PiB7XG4gIGNsZWFudXAoKTtcbn0pO1xuZnVuY3Rpb24gbWFwQXJncyhhcmdzKSB7XG4gIHJldHVybiBhcmdzLm1hcChhcmcgPT4ge1xuICAgIGlmICghYXJnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIHJldHVybiBtYXBBcmdzKGFyZyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuICdsb2dDb250ZXh0JyBpbiBhcmcgPyBhcmcubG9nQ29udGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfSk7XG59XG5cbnZhciBDaGVja1N0YXR1cztcbihmdW5jdGlvbiAoQ2hlY2tTdGF0dXMpIHtcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJSVU5OSU5HXCJdID0gMV0gPSBcIlJVTk5JTkdcIjtcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJTS0lQUEVEXCJdID0gMl0gPSBcIlNLSVBQRURcIjtcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJTVUNDRVNTXCJdID0gM10gPSBcIlNVQ0NFU1NcIjtcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJGQUlMRURcIl0gPSA0XSA9IFwiRkFJTEVEXCI7XG59KShDaGVja1N0YXR1cyB8fCAoQ2hlY2tTdGF0dXMgPSB7fSkpO1xuY2xhc3MgQ2hlY2tlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RhdHVzID0gQ2hlY2tTdGF0dXMuSURMRTtcbiAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMucm9vbSA9IG5ldyBSb29tKG9wdGlvbnMucm9vbU9wdGlvbnMpO1xuICAgIHRoaXMuY29ubmVjdE9wdGlvbnMgPSBvcHRpb25zLmNvbm5lY3RPcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgcnVuKG9uQ29tcGxldGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5JRExFKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdjaGVjayBpcyBydW5uaW5nIGFscmVhZHknKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdHVzKENoZWNrU3RhdHVzLlJVTk5JTkcpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgLy8gc2xlZXAgZm9yIGEgYml0IHRvIGVuc3VyZSBkaXNjb25uZWN0XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IENoZWNrU3RhdHVzLlNLSVBQRUQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXModGhpcy5pc1N1Y2Nlc3MoKSA/IENoZWNrU3RhdHVzLlNVQ0NFU1MgOiBDaGVja1N0YXR1cy5GQUlMRUQpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5mbygpO1xuICAgIH0pO1xuICB9XG4gIGlzU3VjY2VzcygpIHtcbiAgICByZXR1cm4gIXRoaXMubG9ncy5zb21lKGwgPT4gbC5sZXZlbCA9PT0gJ2Vycm9yJyk7XG4gIH1cbiAgY29ubmVjdCh1cmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucm9vbS5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb29tO1xuICAgICAgfVxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdXJsID0gdGhpcy51cmw7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh1cmwsIHRoaXMudG9rZW4sIHRoaXMuY29ubmVjdE9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgICB9KTtcbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5yb29tICYmIHRoaXMucm9vbS5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJvb20uZGlzY29ubmVjdCgpO1xuICAgICAgICAvLyB3YWl0IGZvciBpdCB0byBnbyB0aHJvdWdoXG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBza2lwKCkge1xuICAgIHRoaXMuc2V0U3RhdHVzKENoZWNrU3RhdHVzLlNLSVBQRUQpO1xuICB9XG4gIHN3aXRjaFByb3RvY29sKHByb3RvY29sKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBoYXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGxldCBoYXNSZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yb29tLm9uKFJvb21FdmVudC5SZWNvbm5lY3RpbmcsICgpID0+IHtcbiAgICAgICAgaGFzUmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yb29tLm9uY2UoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIGhhc1JlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yb29tLnNpbXVsYXRlU2NlbmFyaW8oXCJmb3JjZS1cIi5jb25jYXQocHJvdG9jb2wpKTtcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICBpZiAoIWhhc1JlY29ubmVjdGluZykge1xuICAgICAgICAvLyBubyBuZWVkIHRvIHdhaXQgZm9yIHJlY29ubmVjdGlvblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB3YWl0IGZvciAxMCBzZWNvbmRzIGZvciByZWNvbm5lY3Rpb25cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgMTAwMDA7XG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKGhhc1JlY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHNsZWVwKDEwMCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVjb25uZWN0IHVzaW5nIFwiLmNvbmNhdChwcm90b2NvbCwgXCIgcHJvdG9jb2wgYWZ0ZXIgMTAgc2Vjb25kc1wiKSk7XG4gICAgfSk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBhcHBlbmRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGFwcGVuZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgZ2V0IGVuZ2luZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZ2luZTtcbiAgfVxuICBnZXRJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2dzOiB0aGlzLmxvZ3MsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb25cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGZvciBjb25uZWN0aW9ucyBxdWFsaXR5IHRvIGNsb3Nlc3RzIENsb3VkIHJlZ2lvbnMgYW5kIGRldGVybWluaW5nIHRoZSBiZXN0IHF1YWxpdHlcbiAqL1xuY2xhc3MgQ2xvdWRSZWdpb25DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDbG91ZCByZWdpb25zJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByZWdpb25Qcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgICBpZiAoIXJlZ2lvblByb3ZpZGVyLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uU3RhdHMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5VcmxzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgcmVnaW9uUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgaWYgKCFyZWdpb25VcmwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlblVybHMuaGFzKHJlZ2lvblVybCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuVXJscy5hZGQocmVnaW9uVXJsKTtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ2xvdWRSZWdpb24ocmVnaW9uVXJsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiXCIuY29uY2F0KHN0YXRzLnJlZ2lvbiwgXCIgUlRUOiBcIikuY29uY2F0KHN0YXRzLnJ0dCwgXCJtcywgZHVyYXRpb246IFwiKS5jb25jYXQoc3RhdHMuZHVyYXRpb24sIFwibXNcIikpO1xuICAgICAgICByZWdpb25TdGF0cy5wdXNoKHN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lvblN0YXRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIChhLmR1cmF0aW9uIC0gYi5kdXJhdGlvbikgKiAwLjUgKyAoYS5ydHQgLSBiLnJ0dCkgKiAwLjU7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJlc3RSZWdpb24gPSByZWdpb25TdGF0c1swXTtcbiAgICAgIHRoaXMuYmVzdFN0YXRzID0gYmVzdFJlZ2lvbjtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcImJlc3QgQ2xvdWQgcmVnaW9uOiBcIi5jb25jYXQoYmVzdFJlZ2lvbi5yZWdpb24pKTtcbiAgICB9KTtcbiAgfVxuICBnZXRJbmZvKCkge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cbiAgY2hlY2tDbG91ZFJlZ2lvbih1cmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCh1cmwpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm90b2NvbCA9PT0gJ3RjcCcpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndGNwJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb24gPSAoX2EgPSB0aGlzLnJvb20uc2VydmVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZ2lvbjtcbiAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVnaW9uIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuc3RyZWFtVGV4dCh7XG4gICAgICAgIHRvcGljOiAndGVzdCdcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gMTAwMDsgLy8gZWFjaCBjaHVuayBpcyBhYm91dCAxMDAwIGJ5dGVzXG4gICAgICBjb25zdCB0b3RhbFNpemUgPSAxMDAwMDAwOyAvLyBhcHByb3hpbWF0ZWx5IDFNQiBvZiBkYXRhXG4gICAgICBjb25zdCBudW1DaHVua3MgPSB0b3RhbFNpemUgLyBjaHVua1NpemU7IC8vIHdpbGwgeWllbGQgMTAwMCBjaHVua3NcbiAgICAgIGNvbnN0IGNodW5rRGF0YSA9ICdBJy5yZXBlYXQoY2h1bmtTaXplKTsgLy8gY3JlYXRlIGEgc3RyaW5nIG9mIDEwMDAgJ0EnIGNoYXJhY3RlcnNcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNodW5rczsgaSsrKSB7XG4gICAgICAgIHlpZWxkIHdyaXRlci53cml0ZShjaHVua0RhdGEpO1xuICAgICAgfVxuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9iID0gdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wdWJsaXNoZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGNvbnN0IHJlZ2lvblN0YXRzID0ge1xuICAgICAgICByZWdpb246IHJlZ2lvbixcbiAgICAgICAgcnR0OiAxMDAwMCxcbiAgICAgICAgZHVyYXRpb246IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIH07XG4gICAgICBzdGF0cyA9PT0gbnVsbCB8fCBzdGF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJyAmJiBzdGF0Lm5vbWluYXRlZCkge1xuICAgICAgICAgIHJlZ2lvblN0YXRzLnJ0dCA9IHN0YXQuY3VycmVudFJvdW5kVHJpcFRpbWUgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHJlZ2lvblN0YXRzO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IFRFU1RfRFVSQVRJT04gPSAxMDAwMDtcbmNsYXNzIENvbm5lY3Rpb25Qcm90b2NvbENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0Nvbm5lY3Rpb24gdmlhIFVEUCB2cyBUQ1AnO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVkcFN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgndWRwJyk7XG4gICAgICBjb25zdCB0Y3BTdGF0cyA9IHlpZWxkIHRoaXMuY2hlY2tDb25uZWN0aW9uUHJvdG9jb2woJ3RjcCcpO1xuICAgICAgdGhpcy5iZXN0U3RhdHMgPSB1ZHBTdGF0cztcbiAgICAgIC8vIHVkcCBzaG91bGQgaXMgdGhlIGJldHRlciBwcm90b2NvbCB0eXBpY2FsbHkuIGhvd2V2ZXIsIHdlJ2QgcHJlZmVyIFRDUCB3aGVuIGVpdGhlciBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAgICAgLy8gMS4gdGhlIGJhbmR3aWR0aCBsaW1pdGF0aW9uIGlzIHdvcnNlIG9uIFVEUCBieSA1MDBtc1xuICAgICAgLy8gMi4gdGhlIHBhY2tldCBsb3NzIGlzIGhpZ2hlciBvbiBVRFAgYnkgMSVcbiAgICAgIGlmICh1ZHBTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggLSB0Y3BTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggPiAwLjUgfHwgKHVkcFN0YXRzLnBhY2tldHNMb3N0IC0gdGNwU3RhdHMucGFja2V0c0xvc3QpIC8gdWRwU3RhdHMucGFja2V0c1NlbnQgPiAwLjAxKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnYmVzdCBjb25uZWN0aW9uIHF1YWxpdHkgdmlhIHRjcCcpO1xuICAgICAgICB0aGlzLmJlc3RTdGF0cyA9IHRjcFN0YXRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdiZXN0IGNvbm5lY3Rpb24gcXVhbGl0eSB2aWEgdWRwJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHRoaXMuYmVzdFN0YXRzO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwidXBzdHJlYW0gYml0cmF0ZTogXCIuY29uY2F0KChzdGF0cy5iaXRyYXRlVG90YWwgLyBzdGF0cy5jb3VudCAvIDEwMDAgLyAxMDAwKS50b0ZpeGVkKDIpLCBcIiBtYnBzXCIpKTtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIlJUVDogXCIuY29uY2F0KChzdGF0cy5ydHRUb3RhbCAvIHN0YXRzLmNvdW50ICogMTAwMCkudG9GaXhlZCgyKSwgXCIgbXNcIikpO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiaml0dGVyOiBcIi5jb25jYXQoKHN0YXRzLmppdHRlclRvdGFsIC8gc3RhdHMuY291bnQgKiAxMDAwKS50b0ZpeGVkKDIpLCBcIiBtc1wiKSk7XG4gICAgICBpZiAoc3RhdHMucGFja2V0c0xvc3QgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcInBhY2tldHMgbG9zdDogXCIuY29uY2F0KChzdGF0cy5wYWNrZXRzTG9zdCAvIHN0YXRzLnBhY2tldHNTZW50ICogMTAwKS50b0ZpeGVkKDIpLCBcIiVcIikpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwiYmFuZHdpZHRoIGxpbWl0ZWQgXCIuY29uY2F0KChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggLyAoVEVTVF9EVVJBVElPTiAvIDEwMDApICogMTAwKS50b0ZpeGVkKDIpLCBcIiVcIikpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmNwdSA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwiY3B1IGxpbWl0ZWQgXCIuY29uY2F0KChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5jcHUgLyAoVEVTVF9EVVJBVElPTiAvIDEwMDApICogMTAwKS50b0ZpeGVkKDIpLCBcIiVcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldEluZm8oKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldEluZm8oKTtcbiAgICBpbmZvLmRhdGEgPSB0aGlzLmJlc3RTdGF0cztcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuICBjaGVja0Nvbm5lY3Rpb25Qcm90b2NvbChwcm90b2NvbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIGlmIChwcm90b2NvbCA9PT0gJ3RjcCcpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndGNwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaFByb3RvY29sKCd1ZHAnKTtcbiAgICAgIH1cbiAgICAgIC8vIGNyZWF0ZSBhIGNhbnZhcyB3aXRoIGFuaW1hdGVkIGNvbnRlbnRcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gMTI4MDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSA3MjA7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgfVxuICAgICAgbGV0IGh1ZSA9IDA7XG4gICAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgICBodWUgPSAoaHVlICsgMSkgJSAzNjA7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImhzbChcIi5jb25jYXQoaHVlLCBcIiwgMTAwJSwgNTAlKVwiKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgIH07XG4gICAgICBhbmltYXRlKCk7XG4gICAgICAvLyBjcmVhdGUgdmlkZW8gdHJhY2sgZnJvbSBjYW52YXNcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKDMwKTsgLy8gMzBmcHNcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgIC8vIHB1Ymxpc2ggdG8gcm9vbVxuICAgICAgY29uc3QgcHViID0geWllbGQgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHZpZGVvVHJhY2ssIHtcbiAgICAgICAgc2ltdWxjYXN0OiBmYWxzZSxcbiAgICAgICAgZGVncmFkYXRpb25QcmVmZXJlbmNlOiAnbWFpbnRhaW4tcmVzb2x1dGlvbicsXG4gICAgICAgIHZpZGVvRW5jb2Rpbmc6IHtcbiAgICAgICAgICBtYXhCaXRyYXRlOiAyMDAwMDAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgdHJhY2sgPSBwdWIudHJhY2s7XG4gICAgICBjb25zdCBwcm90b2NvbFN0YXRzID0ge1xuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcGFja2V0c0xvc3Q6IDAsXG4gICAgICAgIHBhY2tldHNTZW50OiAwLFxuICAgICAgICBxdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9uczoge30sXG4gICAgICAgIHJ0dFRvdGFsOiAwLFxuICAgICAgICBqaXR0ZXJUb3RhbDogMCxcbiAgICAgICAgYml0cmF0ZVRvdGFsOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcbiAgICAgIC8vIGdhdGhlciBzdGF0cyBvbmNlIGEgc2Vjb25kXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0cmFjay5nZXRSVENTdGF0c1JlcG9ydCgpO1xuICAgICAgICBzdGF0cyA9PT0gbnVsbCB8fCBzdGF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5wYWNrZXRzU2VudCA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zID0gc3RhdC5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucztcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMuYml0cmF0ZVRvdGFsICs9IHN0YXQudGFyZ2V0Qml0cmF0ZTtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMuY291bnQrKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQudHlwZSA9PT0gJ3JlbW90ZS1pbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucGFja2V0c0xvc3QgPSBzdGF0LnBhY2tldHNMb3N0O1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5ydHRUb3RhbCArPSBzdGF0LnJvdW5kVHJpcFRpbWU7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLmppdHRlclRvdGFsICs9IHN0YXQuaml0dGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgMTAwMCk7XG4gICAgICAvLyB3YWl0IGEgYml0IHRvIGdhdGhlciBzdGF0c1xuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIFRFU1RfRFVSQVRJT04pKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgdmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBwcm90b2NvbFN0YXRzO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFB1Ymxpc2hBdWRpb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIGF1ZGlvJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIGNyZWF0ZUxvY2FsQXVkaW9UcmFjaygpO1xuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIGRldGVjdFNpbGVuY2UodHJhY2ssIDEwMDApO1xuICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGV0ZWN0IGF1ZGlvIGZyb20gbWljcm9waG9uZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdkZXRlY3RlZCBhdWRpbyBmcm9tIG1pY3JvcGhvbmUnKTtcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xuICAgICAgaWYgKCFzdGF0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcbiAgICAgIH1cbiAgICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIChzdGF0LmtpbmQgPT09ICdhdWRpbycgfHwgIXN0YXQua2luZCAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ2F1ZGlvJykpIHtcbiAgICAgICAgICBudW1QYWNrZXRzID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0cyBhcmUgc2VudCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwicHVibGlzaGVkIFwiLmNvbmNhdChudW1QYWNrZXRzLCBcIiBhdWRpbyBwYWNrZXRzXCIpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBQdWJsaXNoVmlkZW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCB2aWRlbyc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbFZpZGVvVHJhY2soKTtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgdmlkZW8gZnJvbSBjYW1lcmFcbiAgICAgIHlpZWxkIHRoaXMuY2hlY2tGb3JWaWRlbyh0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xuICAgICAgaWYgKCFzdGF0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcbiAgICAgIH1cbiAgICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIChzdGF0LmtpbmQgPT09ICd2aWRlbycgfHwgIXN0YXQua2luZCAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ3ZpZGVvJykpIHtcbiAgICAgICAgICBudW1QYWNrZXRzICs9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgdmlkZW8gcGFja2V0c1wiKSk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tGb3JWaWRlbyh0cmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjay5jbG9uZSgpKTtcbiAgICAgIC8vIENyZWF0ZSB2aWRlbyBlbGVtZW50IHRvIGNoZWNrIGZyYW1lc1xuICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHZpZGVvLm9ucGxheSA9ICgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAoX2IgPSAoX2EgPSBzZXR0aW5ncy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlkZW8udmlkZW9XaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTI4MDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChfZCA9IChfYyA9IHNldHRpbmdzLmhlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdmlkZW8udmlkZW9IZWlnaHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDcyMDtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgLy8gRHJhdyB2aWRlbyBmcmFtZSB0byBjYW52YXNcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xuICAgICAgICAgICAgLy8gR2V0IGltYWdlIGRhdGEgYW5kIGNoZWNrIGlmIGFsbCBwaXhlbHMgYXJlIGJsYWNrXG4gICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICBsZXQgaXNBbGxCbGFjayA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gIT09IDAgfHwgZGF0YVtpICsgMV0gIT09IDAgfHwgZGF0YVtpICsgMl0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBpc0FsbEJsYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FsbEJsYWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoJ2NhbWVyYSBhcHBlYXJzIHRvIGJlIHByb2R1Y2luZyBvbmx5IGJsYWNrIGZyYW1lcycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdyZWNlaXZlZCB2aWRlbyBmcmFtZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgfSk7XG4gICAgICB2aWRlby5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdSZXN1bWluZyBjb25uZWN0aW9uIGFmdGVyIGludGVycnVwdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgbGV0IHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgbGV0IHJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBsZXQgcmVjb25uZWN0UmVzb2x2ZXI7XG4gICAgICBjb25zdCByZWNvbm5lY3RUaW1lb3V0ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaGFuZGxlUmVjb25uZWN0aW5nID0gKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIHJvb20ub24oUm9vbUV2ZW50LlNpZ25hbFJlY29ubmVjdGluZywgaGFuZGxlUmVjb25uZWN0aW5nKS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCBoYW5kbGVSZWNvbm5lY3RpbmcpLm9uKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyKHRydWUpO1xuICAgICAgfSk7XG4gICAgICAoX2EgPSByb29tLmVuZ2luZS5jbGllbnQud3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgY29uc3Qgb25DbG9zZSA9IHJvb20uZW5naW5lLmNsaWVudC5vbkNsb3NlO1xuICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgb25DbG9zZSgnJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCByZWNvbm5lY3RUaW1lb3V0O1xuICAgICAgaWYgKCFyZWNvbm5lY3RpbmdUcmlnZ2VyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGF0dGVtcHQgdG8gcmVjb25uZWN0Jyk7XG4gICAgICB9IGVsc2UgaWYgKCFyZWNvbm5lY3RlZCB8fCByb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncmVjb25uZWN0aW9uIGlzIG9ubHkgcG9zc2libGUgaW4gUmVkaXMtYmFzZWQgY29uZmlndXJhdGlvbnMnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYWJsZSB0byByZWNvbm5lY3QnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBUVVJOQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2FuIGNvbm5lY3QgdmlhIFRVUk4nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxuICAgICAgfSk7XG4gICAgICBsZXQgaGFzVExTID0gZmFsc2U7XG4gICAgICBsZXQgaGFzVFVSTiA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1NUVU4gPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGljZVNlcnZlciBvZiBqb2luUmVzLmljZVNlcnZlcnMpIHtcbiAgICAgICAgZm9yIChsZXQgdXJsIG9mIGljZVNlcnZlci51cmxzKSB7XG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuOicpKSB7XG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm5zOicpKSB7XG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzVExTID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdzdHVuOicpKSB7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzU1RVTikge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFNUVU4gc2VydmVycyBjb25maWd1cmVkIG9uIHNlcnZlciBzaWRlLicpO1xuICAgICAgfSBlbHNlIGlmIChoYXNUVVJOICYmICFoYXNUTFMpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdUVVJOIGlzIGNvbmZpZ3VyZWQgc2VydmVyIHNpZGUsIGJ1dCBUVVJOL1RMUyBpcyB1bmF2YWlsYWJsZS4nKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnRjQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWNlU2VydmVycykgfHwgaGFzVFVSTikge1xuICAgICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICAgIHJ0Y0NvbmZpZzoge1xuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAncmVsYXknXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gVFVSTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0VzdGFibGlzaGluZyBXZWJSVEMgY29ubmVjdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGhhc1RjcCA9IGZhbHNlO1xuICAgICAgbGV0IGhhc0lwdjRVZHAgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZUcmlja2xlID0gdGhpcy5yb29tLmVuZ2luZS5jbGllbnQub25Ucmlja2xlO1xuICAgICAgICB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGUgPSAoc2QsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG5ldyBSVENJY2VDYW5kaWRhdGUoc2QpO1xuICAgICAgICAgICAgbGV0IHN0ciA9IFwiXCIuY29uY2F0KGNhbmRpZGF0ZS5wcm90b2NvbCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUuYWRkcmVzcywgXCI6XCIpLmNvbmNhdChjYW5kaWRhdGUucG9ydCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUudHlwZSk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgaWYgKGlzSVBQcml2YXRlKGNhbmRpZGF0ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnIChwcml2YXRlKSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgY2FuZGlkYXRlLnRjcFR5cGUgPT09ICdwYXNzaXZlJykge1xuICAgICAgICAgICAgICAgICAgaGFzVGNwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnIChwYXNzaXZlKSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucHJvdG9jb2wgPT09ICd1ZHAnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNJcHY0VWRwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShzdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRyaWNrbGUpIHtcbiAgICAgICAgICAgIHByZXZUcmlja2xlKHNkLCB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZUVycm9yID0gZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImVycm9yIHdpdGggSUNFIGNhbmRpZGF0ZTogXCIuY29uY2F0KGV2LmVycm9yQ29kZSwgXCIgXCIpLmNvbmNhdChldi5lcnJvclRleHQsIFwiIFwiKS5jb25jYXQoZXYudXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdub3cgdGhlIHJvb20gaXMgY29ubmVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNUY3ApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIElDRS9UQ1AnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSXB2NFVkcCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIHB1YmxpYyBJUHY0IFVEUCBjYW5kaWRhdGVzIHdlcmUgZm91bmQuIFlvdXIgc2VydmVyIGlzIGxpa2VseSBub3QgY29uZmlndXJlZCBjb3JyZWN0bHknKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJUFByaXZhdGUoYWRkcmVzcykge1xuICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIGlmIChwYXJ0c1swXSA9PT0gJzEwJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE5MicgJiYgcGFydHNbMV0gPT09ICcxNjgnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTcyJykge1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgIGlmIChzZWNvbmQgPj0gMTYgJiYgc2Vjb25kIDw9IDMxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIFdlYlNvY2tldENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0Nvbm5lY3RpbmcgdG8gc2lnbmFsIGNvbm5lY3Rpb24gdmlhIFdlYlNvY2tldCc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBpZiAodGhpcy51cmwuc3RhcnRzV2l0aCgnd3M6JykgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnaHR0cDonKSkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBpbnNlY3VyZSwgY2xpZW50cyBtYXkgYmxvY2sgY29ubmVjdGlvbnMgdG8gaXQnKTtcbiAgICAgIH1cbiAgICAgIGxldCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJDb25uZWN0ZWQgdG8gc2VydmVyLCB2ZXJzaW9uIFwiLmNvbmNhdChqb2luUmVzLnNlcnZlclZlcnNpb24sIFwiLlwiKSk7XG4gICAgICBpZiAoKChfYSA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVkaXRpb24pID09PSBTZXJ2ZXJJbmZvX0VkaXRpb24uQ2xvdWQgJiYgKChfYiA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lvbikpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiTGl2ZUtpdCBDbG91ZDogXCIuY29uY2F0KChfYyA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZ2lvbikpO1xuICAgICAgfVxuICAgICAgeWllbGQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdGlvbkNoZWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0TmV4dENoZWNrSWQoKSB7XG4gICAgY29uc3QgbmV4dElkID0gdGhpcy5jaGVja1Jlc3VsdHMuc2l6ZTtcbiAgICB0aGlzLmNoZWNrUmVzdWx0cy5zZXQobmV4dElkLCB7XG4gICAgICBsb2dzOiBbXSxcbiAgICAgIHN0YXR1czogQ2hlY2tTdGF0dXMuSURMRSxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgZGVzY3JpcHRpb246ICcnXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHRJZDtcbiAgfVxuICB1cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKSB7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KGNoZWNrSWQsIGluZm8pO1xuICAgIHRoaXMuZW1pdCgnY2hlY2tVcGRhdGUnLCBjaGVja0lkLCBpbmZvKTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpLmV2ZXJ5KHIgPT4gci5zdGF0dXMgIT09IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gIH1cbiAgZ2V0UmVzdWx0cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoZWNrUmVzdWx0cy52YWx1ZXMoKSk7XG4gIH1cbiAgY3JlYXRlQW5kUnVuQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY2hlY2tJZCA9IHRoaXMuZ2V0TmV4dENoZWNrSWQoKTtcbiAgICAgIGNvbnN0IHRlc3QgPSBuZXcgY2hlY2sodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMub3B0aW9ucyk7XG4gICAgICBjb25zdCBoYW5kbGVVcGRhdGUgPSBpbmZvID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKTtcbiAgICAgIH07XG4gICAgICB0ZXN0Lm9uKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGVzdC5ydW4oKTtcbiAgICAgIHRlc3Qub2ZmKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICBjaGVja1dlYnNvY2tldCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViU29ja2V0Q2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrV2ViUlRDKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJSVENDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tUVVJOKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhUVVJOQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUmVjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhSZWNvbm5lY3RDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tQdWJsaXNoQXVkaW8oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hBdWRpb0NoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1B1Ymxpc2hWaWRlbygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUHVibGlzaFZpZGVvQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblByb3RvY29sKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBpbmZvID0geWllbGQgdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhDb25uZWN0aW9uUHJvdG9jb2xDaGVjayk7XG4gICAgICBpZiAoaW5mby5kYXRhICYmICdwcm90b2NvbCcgaW4gaW5mby5kYXRhKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gaW5mby5kYXRhO1xuICAgICAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSBzdGF0cy5wcm90b2NvbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrQ2xvdWRSZWdpb24oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKENsb3VkUmVnaW9uQ2hlY2spO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVHJ5IHRvIGFuYWx5emUgdGhlIGxvY2FsIHRyYWNrIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUgb2YgYSB0cmFjay5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlcmUgaXMgbm8gcHJvcGVydHkgc3VwcG9ydGVkIGJ5IGFsbCBicm93c2VycyB0byBkZXRlY3Qgd2hldGhlciBhIHZpZGVvIHRyYWNrIG9yaWdpbmF0ZWQgZnJvbSBhIHVzZXItIG9yIGVudmlyb25tZW50LWZhY2luZyBjYW1lcmEgZGV2aWNlLlxuICogRm9yIHRoaXMgcmVhc29uLCB3ZSB1c2UgdGhlIGBmYWNpbmdNb2RlYCBwcm9wZXJ0eSB3aGVuIGF2YWlsYWJsZSwgYnV0IHdpbGwgZmFsbCBiYWNrIG9uIGEgc3RyaW5nLWJhc2VkIGFuYWx5c2lzIG9mIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cbiAqIElmIGJvdGggbWV0aG9kcyBmYWlsLCB0aGUgZGVmYXVsdCBmYWNpbmcgbW9kZSB3aWxsIGJlIHVzZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50cy9mYWNpbmdNb2RlIHwgTUROIGRvY3Mgb24gZmFjaW5nTW9kZX1cbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZnVuY3Rpb24gZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrKGxvY2FsVHJhY2spIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX2E7XG4gIGNvbnN0IHRyYWNrID0gaXNMb2NhbFRyYWNrKGxvY2FsVHJhY2spID8gbG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrIDogbG9jYWxUcmFjaztcbiAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgZmFjaW5nTW9kZTogKF9hID0gb3B0aW9ucy5kZWZhdWx0RmFjaW5nTW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3VzZXInLFxuICAgIGNvbmZpZGVuY2U6ICdsb3cnXG4gIH07XG4gIC8vIDEuIFRyeSB0byBnZXQgZmFjaW5nTW9kZSBmcm9tIHRyYWNrIHNldHRpbmdzLlxuICBpZiAoJ2ZhY2luZ01vZGUnIGluIHRyYWNrU2V0dGluZ3MpIHtcbiAgICBjb25zdCByYXdGYWNpbmdNb2RlID0gdHJhY2tTZXR0aW5ncy5mYWNpbmdNb2RlO1xuICAgIGxpdmVraXRMb2dnZXIudHJhY2UoJ3Jhd0ZhY2luZ01vZGUnLCB7XG4gICAgICByYXdGYWNpbmdNb2RlXG4gICAgfSk7XG4gICAgaWYgKHJhd0ZhY2luZ01vZGUgJiYgdHlwZW9mIHJhd0ZhY2luZ01vZGUgPT09ICdzdHJpbmcnICYmIGlzRmFjaW5nTW9kZVZhbHVlKHJhd0ZhY2luZ01vZGUpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIGZhY2luZ01vZGU6IHJhd0ZhY2luZ01vZGUsXG4gICAgICAgIGNvbmZpZGVuY2U6ICdoaWdoJ1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLy8gMi4gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhpZ2ggY29uZmlkZW5jZSB3ZSB0cnkgdG8gZ2V0IHRoZSBmYWNpbmcgbW9kZSBmcm9tIHRoZSBkZXZpY2UgbGFiZWwuXG4gIGlmIChbJ2xvdycsICdtZWRpdW0nXS5pbmNsdWRlcyhyZXN1bHQuY29uZmlkZW5jZSkpIHtcbiAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKFwiVHJ5IHRvIGdldCBmYWNpbmcgbW9kZSBmcm9tIGRldmljZSBsYWJlbDogKFwiLmNvbmNhdCh0cmFjay5sYWJlbCwgXCIpXCIpKTtcbiAgICBjb25zdCBsYWJlbEFuYWx5c2lzUmVzdWx0ID0gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCh0cmFjay5sYWJlbCk7XG4gICAgaWYgKGxhYmVsQW5hbHlzaXNSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gbGFiZWxBbmFseXNpc1Jlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGtub3duRGV2aWNlTGFiZWxzID0gbmV3IE1hcChbWydvYnMgdmlydHVhbCBjYW1lcmEnLCB7XG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXG59XV0pO1xuY29uc3Qga25vd25EZXZpY2VMYWJlbFNlY3Rpb25zID0gbmV3IE1hcChbWydpcGhvbmUnLCB7XG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXG59XSwgWydpcGFkJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV1dKTtcbi8qKlxuICogQXR0ZW1wdCB0byBhbmFseXplIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwoZGV2aWNlTGFiZWwpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBsYWJlbCA9IGRldmljZUxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBFbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBkZXZpY2UgbGFiZWwgYnV0IHdlIGNhbid0IGluZmVyIGFueXRoaW5nIGZyb20gaXQuXG4gIGlmIChsYWJlbCA9PT0gJycpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8vIENhbiB3ZSBtYXRjaCBhZ2FpbnN0IHdpZGVseSBrbm93biBkZXZpY2UgbGFiZWxzLlxuICBpZiAoa25vd25EZXZpY2VMYWJlbHMuaGFzKGxhYmVsKSkge1xuICAgIHJldHVybiBrbm93bkRldmljZUxhYmVscy5nZXQobGFiZWwpO1xuICB9XG4gIC8vIENhbiB3ZSBtYXRjaCBhZ2FpbnN0IHNlY3Rpb25zIG9mIHRoZSBkZXZpY2UgbGFiZWwuXG4gIHJldHVybiAoX2EgPSBBcnJheS5mcm9tKGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucy5lbnRyaWVzKCkpLmZpbmQoX3JlZiA9PiB7XG4gICAgbGV0IFtzZWN0aW9uXSA9IF9yZWY7XG4gICAgcmV0dXJuIGxhYmVsLmluY2x1ZGVzKHNlY3Rpb24pO1xuICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xufVxuZnVuY3Rpb24gaXNGYWNpbmdNb2RlVmFsdWUoaXRlbSkge1xuICBjb25zdCBhbGxvd2VkVmFsdWVzID0gWyd1c2VyJywgJ2Vudmlyb25tZW50JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGl0ZW0pO1xufVxuXG5leHBvcnQgeyBBdWRpb1ByZXNldHMsIEJhY2t1cENvZGVjUG9saWN5LCBCYXNlS2V5UHJvdmlkZXIsIENoZWNrU3RhdHVzLCBDaGVja2VyLCBDb25uZWN0aW9uQ2hlY2ssIENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdGlvbkVycm9yUmVhc29uLCBDb25uZWN0aW9uUXVhbGl0eSwgQ29ubmVjdGlvblN0YXRlLCBDcml0aWNhbFRpbWVycywgQ3J5cHRvckVycm9yLCBDcnlwdG9yRXJyb3JSZWFzb24sIENyeXB0b3JFdmVudCwgRGF0YVBhY2tldF9LaW5kLCBEZWZhdWx0UmVjb25uZWN0UG9saWN5LCBEZXZpY2VVbnN1cHBvcnRlZEVycm9yLCBEaXNjb25uZWN0UmVhc29uLCBFbmNyeXB0aW9uRXZlbnQsIEVuZ2luZUV2ZW50LCBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciwgS2V5SGFuZGxlckV2ZW50LCBLZXlQcm92aWRlckV2ZW50LCBMaXZla2l0RXJyb3IsIExvY2FsQXVkaW9UcmFjaywgTG9jYWxQYXJ0aWNpcGFudCwgTG9jYWxUcmFjaywgTG9jYWxUcmFja1B1YmxpY2F0aW9uLCBMb2NhbFZpZGVvVHJhY2ssIExvZ0xldmVsLCBMb2dnZXJOYW1lcywgTWVkaWFEZXZpY2VGYWlsdXJlLCBfIGFzIE11dGV4LCBOZWdvdGlhdGlvbkVycm9yLCBQYXJ0aWNpcGFudCwgUGFydGljaXBhbnRFdmVudCwgUGFydGljaXBhbnRJbmZvX0tpbmQgYXMgUGFydGljaXBhbnRLaW5kLCBQdWJsaXNoRGF0YUVycm9yLCBQdWJsaXNoVHJhY2tFcnJvciwgUmVtb3RlQXVkaW9UcmFjaywgUmVtb3RlUGFydGljaXBhbnQsIFJlbW90ZVRyYWNrLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBSZW1vdGVWaWRlb1RyYWNrLCBSb29tLCBSb29tRXZlbnQsIFJwY0Vycm9yLCBTY3JlZW5TaGFyZVByZXNldHMsIFNpZ25hbFJlcXVlc3RFcnJvciwgU3Vic2NyaXB0aW9uRXJyb3IsIFRyYWNrLCBUcmFja0V2ZW50LCBUcmFja0ludmFsaWRFcnJvciwgVHJhY2tQdWJsaWNhdGlvbiwgVHJhY2tUeXBlLCBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlLCBVbnN1cHBvcnRlZFNlcnZlciwgVmlkZW9QcmVzZXQsIFZpZGVvUHJlc2V0cywgVmlkZW9QcmVzZXRzNDMsIFZpZGVvUXVhbGl0eSwgYXR0YWNoVG9FbGVtZW50LCBjb21wYXJlVmVyc2lvbnMsIGNyZWF0ZUF1ZGlvQW5hbHlzZXIsIGNyZWF0ZUUyRUVLZXksIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlciwgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nLCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2ssIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzLCBjcmVhdGVMb2NhbFRyYWNrcywgY3JlYXRlTG9jYWxWaWRlb1RyYWNrLCBkZXJpdmVLZXlzLCBkZXRhY2hUcmFjaywgZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCwgZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrLCBnZXRCcm93c2VyLCBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2ssIGdldEVtcHR5VmlkZW9TdHJlYW1UcmFjaywgZ2V0TG9nZ2VyLCBpbXBvcnRLZXksIGlzQXVkaW9UcmFjaywgaXNCYWNrdXBDb2RlYywgaXNCcm93c2VyU3VwcG9ydGVkLCBpc0UyRUVTdXBwb3J0ZWQsIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCwgaXNMb2NhbFBhcnRpY2lwYW50LCBpc0xvY2FsVHJhY2ssIGlzUmVtb3RlUGFydGljaXBhbnQsIGlzUmVtb3RlVHJhY2ssIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkLCBpc1ZpZGVvRnJhbWUsIGlzVmlkZW9UcmFjaywgbmVlZHNSYnNwVW5lc2NhcGluZywgcGFyc2VSYnNwLCBwcm90b2NvbFZlcnNpb24sIHJhdGNoZXQsIHNldExvZ0V4dGVuc2lvbiwgc2V0TG9nTGV2ZWwsIHN1cHBvcnRzQVYxLCBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtLCBzdXBwb3J0c0R5bmFjYXN0LCBzdXBwb3J0c1ZQOSwgdmVyc2lvbiwgdmlkZW9Db2RlY3MsIHdyaXRlUmJzcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl2ZWtpdC1jbGllbnQuZXNtLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/livekit-client@2.11.3/node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;